   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"LSM9DS1_drivers.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.comm	TimerId,4,4
  20              		.comm	Status,4,4
  21              		.comm	WriteTimerId,4,4
  22              		.comm	WriteTimerStatus,4,4
  23              		.comm	TimerIdReadBytes,4,4
  24              		.comm	StatusReadBytes,4,4
  25              		.comm	settings,40,4
  26              		.comm	gBias,12,4
  27              		.comm	aBias,12,4
  28              		.comm	mBias,12,4
  29              		.comm	gBiasRaw,6,4
  30              		.comm	aBiasRaw,6,4
  31              		.comm	mBiasRaw,6,4
  32              		.comm	_autoCalc,1,1
  33              		.comm	_mAddress,1,1
  34              		.comm	_xgAddress,1,1
  35              		.comm	gRes,4,4
  36              		.comm	aRes,4,4
  37              		.comm	mRes,4,4
  38              		.comm	gx,2,2
  39              		.comm	gy,2,2
  40              		.comm	gz,2,2
  41              		.comm	ax,2,2
  42              		.comm	ay,2,2
  43              		.comm	az,2,2
  44              		.comm	mx,2,2
  45              		.comm	my,2,2
  46              		.comm	mz,2,2
  47              		.comm	temperature,2,2
  48              		.comm	lk,20,4
  49              		.global	indexAccel
  50              		.bss
  51              		.align	2
  54              	indexAccel:
  55 0000 00000000 		.space	4
  56              		.global	magSensitivity
  57              		.data
  58              		.align	2
  61              	magSensitivity:
  62 0000 F7CC1239 		.word	957533431
  63 0004 240B9839 		.word	966265636
  64 0008 9F71E139 		.word	971075999
  65 000c 240B183A 		.word	974654244
  66              		.global	accelMeasurements
  67              		.bss
  68              		.align	2
  71              	accelMeasurements:
  72 0004 00000000 		.space	4
  73              		.global	gyroMeasurements
  74              		.align	2
  77              	gyroMeasurements:
  78 0008 00000000 		.space	4
  79              		.comm	poms,6000,4
  80              		.section	.text.init,"ax",%progbits
  81              		.align	2
  82              		.global	init
  83              		.thumb
  84              		.thumb_func
  86              	init:
  87              	.LFB112:
  88              		.file 1 "../LSM9DS1_drivers.c"
   1:../LSM9DS1_drivers.c **** /*
   2:../LSM9DS1_drivers.c ****  * LSM9DS1_drivers.c
   3:../LSM9DS1_drivers.c ****  *
   4:../LSM9DS1_drivers.c ****  *  Created on: 28-12-2015
   5:../LSM9DS1_drivers.c ****  *      Author: Mateusz
   6:../LSM9DS1_drivers.c ****  */
   7:../LSM9DS1_drivers.c **** 
   8:../LSM9DS1_drivers.c **** #include "LSM9DS1_drivers.h"
   9:../LSM9DS1_drivers.c **** #include "LSM9DS1_Registers.h"
  10:../LSM9DS1_drivers.c **** #include "LSM9DS1_Types.h"
  11:../LSM9DS1_drivers.c **** #include "timerFunctionsLSM.h"
  12:../LSM9DS1_drivers.c **** #include "timerFunctions.h"
  13:../LSM9DS1_drivers.c **** #include <stdint.h>
  14:../LSM9DS1_drivers.c **** #include <inttypes.h>
  15:../LSM9DS1_drivers.c **** #include <math.h>
  16:../LSM9DS1_drivers.c **** #include <stdlib.h>
  17:../LSM9DS1_drivers.c **** 
  18:../LSM9DS1_drivers.c **** #define TRUE 1
  19:../LSM9DS1_drivers.c **** #define FALSE 0
  20:../LSM9DS1_drivers.c **** #define LSM9DS1_COMMUNICATION_TIMEOUT 1000
  21:../LSM9DS1_drivers.c **** 
  22:../LSM9DS1_drivers.c **** 
  23:../LSM9DS1_drivers.c **** char lk[20];
  24:../LSM9DS1_drivers.c **** /*Status = SYSTM001_ERROR;
  25:../LSM9DS1_drivers.c **** TimerId = 0;
  26:../LSM9DS1_drivers.c **** 
  27:../LSM9DS1_drivers.c **** WriteTimerStatus = SYSTM001_ERROR;
  28:../LSM9DS1_drivers.c **** WriteTimerId = 0;*/
  29:../LSM9DS1_drivers.c **** 
  30:../LSM9DS1_drivers.c **** int indexAccel = 0;
  31:../LSM9DS1_drivers.c **** 
  32:../LSM9DS1_drivers.c **** float magSensitivity[4] = {0.00014, 0.00029, 0.00043, 0.00058};
  33:../LSM9DS1_drivers.c **** 
  34:../LSM9DS1_drivers.c **** FILE * accelMeasurements = NULL;
  35:../LSM9DS1_drivers.c **** FILE * gyroMeasurements = NULL;
  36:../LSM9DS1_drivers.c **** 
  37:../LSM9DS1_drivers.c **** typedef struct pomiary
  38:../LSM9DS1_drivers.c **** {
  39:../LSM9DS1_drivers.c **** 	int16_t gxs[1000];
  40:../LSM9DS1_drivers.c **** 	int16_t gys[1000];
  41:../LSM9DS1_drivers.c **** 	int16_t gzs[1000];
  42:../LSM9DS1_drivers.c **** }pomiary;
  43:../LSM9DS1_drivers.c **** 
  44:../LSM9DS1_drivers.c **** pomiary poms;
  45:../LSM9DS1_drivers.c **** 
  46:../LSM9DS1_drivers.c **** void init(interface_mode interface, uint8_t xgAddr, uint8_t mAddr)
  47:../LSM9DS1_drivers.c **** {
  89              		.loc 1 47 0
  90              		.cfi_startproc
  91              		@ args = 0, pretend = 0, frame = 16
  92              		@ frame_needed = 1, uses_anonymous_args = 0
  93              		@ link register save eliminated.
  94 0000 80B4     		push	{r7}
  95              	.LCFI0:
  96              		.cfi_def_cfa_offset 4
  97              		.cfi_offset 7, -4
  98 0002 85B0     		sub	sp, sp, #20
  99              	.LCFI1:
 100              		.cfi_def_cfa_offset 24
 101 0004 00AF     		add	r7, sp, #0
 102              	.LCFI2:
 103              		.cfi_def_cfa_register 7
 104 0006 1346     		mov	r3, r2
 105 0008 0246     		mov	r2, r0
 106 000a FA71     		strb	r2, [r7, #7]
 107 000c 0A46     		mov	r2, r1
 108 000e BA71     		strb	r2, [r7, #6]
 109 0010 7B71     		strb	r3, [r7, #5]
  48:../LSM9DS1_drivers.c **** 	settings.device.commInterface = interface;
 110              		.loc 1 48 0
 111 0012 40F20003 		movw	r3, #:lower16:settings
 112 0016 C0F20003 		movt	r3, #:upper16:settings
 113 001a FA79     		ldrb	r2, [r7, #7]
 114 001c 1A70     		strb	r2, [r3, #0]
  49:../LSM9DS1_drivers.c **** 	settings.device.agAddress = xgAddr;
 115              		.loc 1 49 0
 116 001e 40F20003 		movw	r3, #:lower16:settings
 117 0022 C0F20003 		movt	r3, #:upper16:settings
 118 0026 BA79     		ldrb	r2, [r7, #6]
 119 0028 5A70     		strb	r2, [r3, #1]
  50:../LSM9DS1_drivers.c **** 	settings.device.mAddress = mAddr;
 120              		.loc 1 50 0
 121 002a 40F20003 		movw	r3, #:lower16:settings
 122 002e C0F20003 		movt	r3, #:upper16:settings
 123 0032 7A79     		ldrb	r2, [r7, #5]
 124 0034 9A70     		strb	r2, [r3, #2]
  51:../LSM9DS1_drivers.c **** 
  52:../LSM9DS1_drivers.c **** 	settings.gyro.enabled = TRUE;
 125              		.loc 1 52 0
 126 0036 40F20003 		movw	r3, #:lower16:settings
 127 003a C0F20003 		movt	r3, #:upper16:settings
 128 003e 4FF00102 		mov	r2, #1
 129 0042 1A71     		strb	r2, [r3, #4]
  53:../LSM9DS1_drivers.c **** 	settings.gyro.enableX = TRUE;
 130              		.loc 1 53 0
 131 0044 40F20003 		movw	r3, #:lower16:settings
 132 0048 C0F20003 		movt	r3, #:upper16:settings
 133 004c 4FF00102 		mov	r2, #1
 134 0050 5A74     		strb	r2, [r3, #17]
  54:../LSM9DS1_drivers.c **** 	settings.gyro.enableY = TRUE;
 135              		.loc 1 54 0
 136 0052 40F20003 		movw	r3, #:lower16:settings
 137 0056 C0F20003 		movt	r3, #:upper16:settings
 138 005a 4FF00102 		mov	r2, #1
 139 005e 9A74     		strb	r2, [r3, #18]
  55:../LSM9DS1_drivers.c **** 	settings.gyro.enableZ = TRUE;
 140              		.loc 1 55 0
 141 0060 40F20003 		movw	r3, #:lower16:settings
 142 0064 C0F20003 		movt	r3, #:upper16:settings
 143 0068 4FF00102 		mov	r2, #1
 144 006c DA74     		strb	r2, [r3, #19]
  56:../LSM9DS1_drivers.c **** 	// gyro scale can be 245, 500, or 2000
  57:../LSM9DS1_drivers.c **** 	settings.gyro.scale = 245;
 145              		.loc 1 57 0
 146 006e 40F20003 		movw	r3, #:lower16:settings
 147 0072 C0F20003 		movt	r3, #:upper16:settings
 148 0076 4FF0F502 		mov	r2, #245
 149 007a DA80     		strh	r2, [r3, #6]	@ movhi
  58:../LSM9DS1_drivers.c **** 	// gyro sample rate: value between 1-6
  59:../LSM9DS1_drivers.c **** 	// 1 = 14.9    4 = 238
  60:../LSM9DS1_drivers.c **** 	// 2 = 59.5    5 = 476
  61:../LSM9DS1_drivers.c **** 	// 3 = 119     6 = 952
  62:../LSM9DS1_drivers.c **** 	settings.gyro.sampleRate = 3;
 150              		.loc 1 62 0
 151 007c 40F20003 		movw	r3, #:lower16:settings
 152 0080 C0F20003 		movt	r3, #:upper16:settings
 153 0084 4FF00302 		mov	r2, #3
 154 0088 1A72     		strb	r2, [r3, #8]
  63:../LSM9DS1_drivers.c **** 	// gyro cutoff frequency: value between 0-3
  64:../LSM9DS1_drivers.c **** 	// Actual value of cutoff frequency depends
  65:../LSM9DS1_drivers.c **** 	// on sample rate.
  66:../LSM9DS1_drivers.c **** 	settings.gyro.bandwidth = 0;
 155              		.loc 1 66 0
 156 008a 40F20003 		movw	r3, #:lower16:settings
 157 008e C0F20003 		movt	r3, #:upper16:settings
 158 0092 4FF00002 		mov	r2, #0
 159 0096 5A72     		strb	r2, [r3, #9]
  67:../LSM9DS1_drivers.c **** 	settings.gyro.lowPowerEnable = FALSE;
 160              		.loc 1 67 0
 161 0098 40F20003 		movw	r3, #:lower16:settings
 162 009c C0F20003 		movt	r3, #:upper16:settings
 163 00a0 4FF00002 		mov	r2, #0
 164 00a4 9A72     		strb	r2, [r3, #10]
  68:../LSM9DS1_drivers.c **** 
  69:../LSM9DS1_drivers.c **** 	settings.gyro.HPFEnable = FALSE;
 165              		.loc 1 69 0
 166 00a6 40F20003 		movw	r3, #:lower16:settings
 167 00aa C0F20003 		movt	r3, #:upper16:settings
 168 00ae 4FF00002 		mov	r2, #0
 169 00b2 DA72     		strb	r2, [r3, #11]
  70:../LSM9DS1_drivers.c **** 	// Gyro HPF cutoff frequency: value between 0-9
  71:../LSM9DS1_drivers.c **** 	// Actual value depends on sample rate. Only applies
  72:../LSM9DS1_drivers.c **** 	// if gyroHPFEnable is TRUE.
  73:../LSM9DS1_drivers.c **** 	settings.gyro.HPFCutoff = 0;
 170              		.loc 1 73 0
 171 00b4 40F20003 		movw	r3, #:lower16:settings
 172 00b8 C0F20003 		movt	r3, #:upper16:settings
 173 00bc 4FF00002 		mov	r2, #0
 174 00c0 1A73     		strb	r2, [r3, #12]
  74:../LSM9DS1_drivers.c **** 	settings.gyro.flipX = FALSE;
 175              		.loc 1 74 0
 176 00c2 40F20003 		movw	r3, #:lower16:settings
 177 00c6 C0F20003 		movt	r3, #:upper16:settings
 178 00ca 4FF00002 		mov	r2, #0
 179 00ce 5A73     		strb	r2, [r3, #13]
  75:../LSM9DS1_drivers.c **** 	settings.gyro.flipY = FALSE;
 180              		.loc 1 75 0
 181 00d0 40F20003 		movw	r3, #:lower16:settings
 182 00d4 C0F20003 		movt	r3, #:upper16:settings
 183 00d8 4FF00002 		mov	r2, #0
 184 00dc 9A73     		strb	r2, [r3, #14]
  76:../LSM9DS1_drivers.c **** 	settings.gyro.flipZ = FALSE;
 185              		.loc 1 76 0
 186 00de 40F20003 		movw	r3, #:lower16:settings
 187 00e2 C0F20003 		movt	r3, #:upper16:settings
 188 00e6 4FF00002 		mov	r2, #0
 189 00ea DA73     		strb	r2, [r3, #15]
  77:../LSM9DS1_drivers.c **** 	settings.gyro.orientation = 0;
 190              		.loc 1 77 0
 191 00ec 40F20003 		movw	r3, #:lower16:settings
 192 00f0 C0F20003 		movt	r3, #:upper16:settings
 193 00f4 4FF00002 		mov	r2, #0
 194 00f8 1A74     		strb	r2, [r3, #16]
  78:../LSM9DS1_drivers.c **** 	settings.gyro.latchInterrupt = TRUE;
 195              		.loc 1 78 0
 196 00fa 40F20003 		movw	r3, #:lower16:settings
 197 00fe C0F20003 		movt	r3, #:upper16:settings
 198 0102 4FF00102 		mov	r2, #1
 199 0106 1A75     		strb	r2, [r3, #20]
  79:../LSM9DS1_drivers.c **** 
  80:../LSM9DS1_drivers.c **** 	settings.accel.enabled = TRUE;
 200              		.loc 1 80 0
 201 0108 40F20003 		movw	r3, #:lower16:settings
 202 010c C0F20003 		movt	r3, #:upper16:settings
 203 0110 4FF00102 		mov	r2, #1
 204 0114 9A75     		strb	r2, [r3, #22]
  81:../LSM9DS1_drivers.c **** 	settings.accel.enableX = TRUE;
 205              		.loc 1 81 0
 206 0116 40F20003 		movw	r3, #:lower16:settings
 207 011a C0F20003 		movt	r3, #:upper16:settings
 208 011e 4FF00102 		mov	r2, #1
 209 0122 5A76     		strb	r2, [r3, #25]
  82:../LSM9DS1_drivers.c **** 	settings.accel.enableY = TRUE;
 210              		.loc 1 82 0
 211 0124 40F20003 		movw	r3, #:lower16:settings
 212 0128 C0F20003 		movt	r3, #:upper16:settings
 213 012c 4FF00102 		mov	r2, #1
 214 0130 9A76     		strb	r2, [r3, #26]
  83:../LSM9DS1_drivers.c **** 	settings.accel.enableZ = TRUE;
 215              		.loc 1 83 0
 216 0132 40F20003 		movw	r3, #:lower16:settings
 217 0136 C0F20003 		movt	r3, #:upper16:settings
 218 013a 4FF00102 		mov	r2, #1
 219 013e DA76     		strb	r2, [r3, #27]
  84:../LSM9DS1_drivers.c **** 	// accel scale can be 2, 4, 8, or 16
  85:../LSM9DS1_drivers.c **** 	settings.accel.scale = 2;
 220              		.loc 1 85 0
 221 0140 40F20003 		movw	r3, #:lower16:settings
 222 0144 C0F20003 		movt	r3, #:upper16:settings
 223 0148 4FF00202 		mov	r2, #2
 224 014c DA75     		strb	r2, [r3, #23]
  86:../LSM9DS1_drivers.c **** 	// accel sample rate can be 1-6
  87:../LSM9DS1_drivers.c **** 	// 1 = 10 Hz    4 = 238 Hz
  88:../LSM9DS1_drivers.c **** 	// 2 = 50 Hz    5 = 476 Hz
  89:../LSM9DS1_drivers.c **** 	// 3 = 119 Hz   6 = 952 Hz
  90:../LSM9DS1_drivers.c **** 	settings.accel.sampleRate = 6;
 225              		.loc 1 90 0
 226 014e 40F20003 		movw	r3, #:lower16:settings
 227 0152 C0F20003 		movt	r3, #:upper16:settings
 228 0156 4FF00602 		mov	r2, #6
 229 015a 1A76     		strb	r2, [r3, #24]
  91:../LSM9DS1_drivers.c **** 	// Accel cutoff freqeuncy can be any value between -1 - 3.
  92:../LSM9DS1_drivers.c **** 	// -1 = bandwidth determined by sample rate
  93:../LSM9DS1_drivers.c **** 	// 0 = 408 Hz   2 = 105 Hz
  94:../LSM9DS1_drivers.c **** 	// 1 = 211 Hz   3 = 50 Hz
  95:../LSM9DS1_drivers.c **** 	settings.accel.bandwidth = -1;
 230              		.loc 1 95 0
 231 015c 40F20003 		movw	r3, #:lower16:settings
 232 0160 C0F20003 		movt	r3, #:upper16:settings
 233 0164 4FF0FF02 		mov	r2, #255
 234 0168 1A77     		strb	r2, [r3, #28]
  96:../LSM9DS1_drivers.c **** 	settings.accel.highResEnable = FALSE;
 235              		.loc 1 96 0
 236 016a 40F20003 		movw	r3, #:lower16:settings
 237 016e C0F20003 		movt	r3, #:upper16:settings
 238 0172 4FF00002 		mov	r2, #0
 239 0176 5A77     		strb	r2, [r3, #29]
  97:../LSM9DS1_drivers.c **** 	// accelHighResBandwidth can be any value between 0-3
  98:../LSM9DS1_drivers.c **** 	// LP cutoff is set to a factor of sample rate
  99:../LSM9DS1_drivers.c **** 	// 0 = ODR/50    2 = ODR/9
 100:../LSM9DS1_drivers.c **** 	// 1 = ODR/100   3 = ODR/400
 101:../LSM9DS1_drivers.c **** 	settings.accel.highResBandwidth = 0;
 240              		.loc 1 101 0
 241 0178 40F20003 		movw	r3, #:lower16:settings
 242 017c C0F20003 		movt	r3, #:upper16:settings
 243 0180 4FF00002 		mov	r2, #0
 244 0184 9A77     		strb	r2, [r3, #30]
 102:../LSM9DS1_drivers.c **** 
 103:../LSM9DS1_drivers.c **** 	settings.mag.enabled = TRUE;
 245              		.loc 1 103 0
 246 0186 40F20003 		movw	r3, #:lower16:settings
 247 018a C0F20003 		movt	r3, #:upper16:settings
 248 018e 4FF00102 		mov	r2, #1
 249 0192 DA77     		strb	r2, [r3, #31]
 104:../LSM9DS1_drivers.c **** 	// mag scale can be 4, 8, 12, or 16
 105:../LSM9DS1_drivers.c **** 	settings.mag.scale = 4;
 250              		.loc 1 105 0
 251 0194 40F20003 		movw	r3, #:lower16:settings
 252 0198 C0F20003 		movt	r3, #:upper16:settings
 253 019c 4FF00402 		mov	r2, #4
 254 01a0 83F82020 		strb	r2, [r3, #32]
 106:../LSM9DS1_drivers.c **** 	// mag data rate can be 0-7
 107:../LSM9DS1_drivers.c **** 	// 0 = 0.625 Hz  4 = 10 Hz
 108:../LSM9DS1_drivers.c **** 	// 1 = 1.25 Hz   5 = 20 Hz
 109:../LSM9DS1_drivers.c **** 	// 2 = 2.5 Hz    6 = 40 Hz
 110:../LSM9DS1_drivers.c **** 	// 3 = 5 Hz      7 = 80 Hz
 111:../LSM9DS1_drivers.c **** 	settings.mag.sampleRate = 7;
 255              		.loc 1 111 0
 256 01a4 40F20003 		movw	r3, #:lower16:settings
 257 01a8 C0F20003 		movt	r3, #:upper16:settings
 258 01ac 4FF00702 		mov	r2, #7
 259 01b0 83F82120 		strb	r2, [r3, #33]
 112:../LSM9DS1_drivers.c **** 	settings.mag.tempCompensationEnable = FALSE;
 260              		.loc 1 112 0
 261 01b4 40F20003 		movw	r3, #:lower16:settings
 262 01b8 C0F20003 		movt	r3, #:upper16:settings
 263 01bc 4FF00002 		mov	r2, #0
 264 01c0 83F82220 		strb	r2, [r3, #34]
 113:../LSM9DS1_drivers.c **** 	// magPerformance can be any value between 0-3
 114:../LSM9DS1_drivers.c **** 	// 0 = Low power mode      2 = high performance
 115:../LSM9DS1_drivers.c **** 	// 1 = medium performance  3 = ultra-high performance
 116:../LSM9DS1_drivers.c **** 	settings.mag.XYPerformance = 3;
 265              		.loc 1 116 0
 266 01c4 40F20003 		movw	r3, #:lower16:settings
 267 01c8 C0F20003 		movt	r3, #:upper16:settings
 268 01cc 4FF00302 		mov	r2, #3
 269 01d0 83F82320 		strb	r2, [r3, #35]
 117:../LSM9DS1_drivers.c **** 	settings.mag.ZPerformance = 3;
 270              		.loc 1 117 0
 271 01d4 40F20003 		movw	r3, #:lower16:settings
 272 01d8 C0F20003 		movt	r3, #:upper16:settings
 273 01dc 4FF00302 		mov	r2, #3
 274 01e0 83F82420 		strb	r2, [r3, #36]
 118:../LSM9DS1_drivers.c **** 	settings.mag.lowPowerEnable = FALSE;
 275              		.loc 1 118 0
 276 01e4 40F20003 		movw	r3, #:lower16:settings
 277 01e8 C0F20003 		movt	r3, #:upper16:settings
 278 01ec 4FF00002 		mov	r2, #0
 279 01f0 83F82520 		strb	r2, [r3, #37]
 119:../LSM9DS1_drivers.c **** 	// magOperatingMode can be 0-2
 120:../LSM9DS1_drivers.c **** 	// 0 = continuous conversion
 121:../LSM9DS1_drivers.c **** 	// 1 = single-conversion
 122:../LSM9DS1_drivers.c **** 	// 2 = power down
 123:../LSM9DS1_drivers.c **** 	settings.mag.operatingMode = 0;
 280              		.loc 1 123 0
 281 01f4 40F20003 		movw	r3, #:lower16:settings
 282 01f8 C0F20003 		movt	r3, #:upper16:settings
 283 01fc 4FF00002 		mov	r2, #0
 284 0200 83F82620 		strb	r2, [r3, #38]
 124:../LSM9DS1_drivers.c **** 
 125:../LSM9DS1_drivers.c **** 	settings.temp.enabled = TRUE;
 285              		.loc 1 125 0
 286 0204 40F20003 		movw	r3, #:lower16:settings
 287 0208 C0F20003 		movt	r3, #:upper16:settings
 288 020c 4FF00102 		mov	r2, #1
 289 0210 83F82720 		strb	r2, [r3, #39]
 290              	.LBB2:
 126:../LSM9DS1_drivers.c **** 
 127:../LSM9DS1_drivers.c **** 	for (int i=0; i<3; i++)
 291              		.loc 1 127 0
 292 0214 4FF00003 		mov	r3, #0
 293 0218 FB60     		str	r3, [r7, #12]
 294 021a 3FE0     		b	.L2
 295              	.L3:
 128:../LSM9DS1_drivers.c **** 	{
 129:../LSM9DS1_drivers.c **** 		gBias[i] = 0;
 296              		.loc 1 129 0 discriminator 2
 297 021c 40F20003 		movw	r3, #:lower16:gBias
 298 0220 C0F20003 		movt	r3, #:upper16:gBias
 299 0224 FA68     		ldr	r2, [r7, #12]
 300 0226 4FEA8202 		lsl	r2, r2, #2
 301 022a 9B18     		adds	r3, r3, r2
 302 022c 4FF00002 		mov	r2, #0
 303 0230 1A60     		str	r2, [r3, #0]	@ float
 130:../LSM9DS1_drivers.c **** 		aBias[i] = 0;
 304              		.loc 1 130 0 discriminator 2
 305 0232 40F20003 		movw	r3, #:lower16:aBias
 306 0236 C0F20003 		movt	r3, #:upper16:aBias
 307 023a FA68     		ldr	r2, [r7, #12]
 308 023c 4FEA8202 		lsl	r2, r2, #2
 309 0240 9B18     		adds	r3, r3, r2
 310 0242 4FF00002 		mov	r2, #0
 311 0246 1A60     		str	r2, [r3, #0]	@ float
 131:../LSM9DS1_drivers.c **** 		mBias[i] = 0;
 312              		.loc 1 131 0 discriminator 2
 313 0248 40F20003 		movw	r3, #:lower16:mBias
 314 024c C0F20003 		movt	r3, #:upper16:mBias
 315 0250 FA68     		ldr	r2, [r7, #12]
 316 0252 4FEA8202 		lsl	r2, r2, #2
 317 0256 9B18     		adds	r3, r3, r2
 318 0258 4FF00002 		mov	r2, #0
 319 025c 1A60     		str	r2, [r3, #0]	@ float
 132:../LSM9DS1_drivers.c **** 		gBiasRaw[i] = 0;
 320              		.loc 1 132 0 discriminator 2
 321 025e 40F20003 		movw	r3, #:lower16:gBiasRaw
 322 0262 C0F20003 		movt	r3, #:upper16:gBiasRaw
 323 0266 FA68     		ldr	r2, [r7, #12]
 324 0268 4FF00001 		mov	r1, #0
 325 026c 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 133:../LSM9DS1_drivers.c **** 		aBiasRaw[i] = 0;
 326              		.loc 1 133 0 discriminator 2
 327 0270 40F20003 		movw	r3, #:lower16:aBiasRaw
 328 0274 C0F20003 		movt	r3, #:upper16:aBiasRaw
 329 0278 FA68     		ldr	r2, [r7, #12]
 330 027a 4FF00001 		mov	r1, #0
 331 027e 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 134:../LSM9DS1_drivers.c **** 		mBiasRaw[i] = 0;
 332              		.loc 1 134 0 discriminator 2
 333 0282 40F20003 		movw	r3, #:lower16:mBiasRaw
 334 0286 C0F20003 		movt	r3, #:upper16:mBiasRaw
 335 028a FA68     		ldr	r2, [r7, #12]
 336 028c 4FF00001 		mov	r1, #0
 337 0290 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 127:../LSM9DS1_drivers.c **** 	for (int i=0; i<3; i++)
 338              		.loc 1 127 0 discriminator 2
 339 0294 FB68     		ldr	r3, [r7, #12]
 340 0296 03F10103 		add	r3, r3, #1
 341 029a FB60     		str	r3, [r7, #12]
 342              	.L2:
 127:../LSM9DS1_drivers.c **** 	for (int i=0; i<3; i++)
 343              		.loc 1 127 0 is_stmt 0 discriminator 1
 344 029c FB68     		ldr	r3, [r7, #12]
 345 029e 022B     		cmp	r3, #2
 346 02a0 BCDD     		ble	.L3
 347              	.LBE2:
 135:../LSM9DS1_drivers.c **** 	}
 136:../LSM9DS1_drivers.c **** 
 137:../LSM9DS1_drivers.c **** 	_autoCalc = FALSE;
 348              		.loc 1 137 0 is_stmt 1
 349 02a2 40F20003 		movw	r3, #:lower16:_autoCalc
 350 02a6 C0F20003 		movt	r3, #:upper16:_autoCalc
 351 02aa 4FF00002 		mov	r2, #0
 352 02ae 1A70     		strb	r2, [r3, #0]
 138:../LSM9DS1_drivers.c **** }
 353              		.loc 1 138 0
 354 02b0 07F11407 		add	r7, r7, #20
 355 02b4 BD46     		mov	sp, r7
 356 02b6 80BC     		pop	{r7}
 357 02b8 7047     		bx	lr
 358              		.cfi_endproc
 359              	.LFE112:
 361 02ba 00BF     		.section	.text.begin,"ax",%progbits
 362              		.align	2
 363              		.global	begin
 364              		.thumb
 365              		.thumb_func
 367              	begin:
 368              	.LFB113:
 139:../LSM9DS1_drivers.c **** 
 140:../LSM9DS1_drivers.c **** uint16_t begin(void)
 141:../LSM9DS1_drivers.c **** {
 369              		.loc 1 141 0
 370              		.cfi_startproc
 371              		@ args = 0, pretend = 0, frame = 8
 372              		@ frame_needed = 1, uses_anonymous_args = 0
 373 0000 80B5     		push	{r7, lr}
 374              	.LCFI3:
 375              		.cfi_def_cfa_offset 8
 376              		.cfi_offset 7, -8
 377              		.cfi_offset 14, -4
 378 0002 82B0     		sub	sp, sp, #8
 379              	.LCFI4:
 380              		.cfi_def_cfa_offset 16
 381 0004 00AF     		add	r7, sp, #0
 382              	.LCFI5:
 383              		.cfi_def_cfa_register 7
 142:../LSM9DS1_drivers.c **** 	//! Todo: don't use _xgAddress or _mAddress, duplicating memory
 143:../LSM9DS1_drivers.c **** 	_xgAddress = settings.device.agAddress;
 384              		.loc 1 143 0
 385 0006 40F20003 		movw	r3, #:lower16:settings
 386 000a C0F20003 		movt	r3, #:upper16:settings
 387 000e 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 388 0010 40F20003 		movw	r3, #:lower16:_xgAddress
 389 0014 C0F20003 		movt	r3, #:upper16:_xgAddress
 390 0018 1A70     		strb	r2, [r3, #0]
 144:../LSM9DS1_drivers.c **** 	_mAddress = settings.device.mAddress;
 391              		.loc 1 144 0
 392 001a 40F20003 		movw	r3, #:lower16:settings
 393 001e C0F20003 		movt	r3, #:upper16:settings
 394 0022 9A78     		ldrb	r2, [r3, #2]	@ zero_extendqisi2
 395 0024 40F20003 		movw	r3, #:lower16:_mAddress
 396 0028 C0F20003 		movt	r3, #:upper16:_mAddress
 397 002c 1A70     		strb	r2, [r3, #0]
 145:../LSM9DS1_drivers.c **** 
 146:../LSM9DS1_drivers.c **** 	constrainScales();
 398              		.loc 1 146 0
 399 002e FFF7FEFF 		bl	constrainScales
 147:../LSM9DS1_drivers.c **** 
 148:../LSM9DS1_drivers.c **** 	// Once we have the scale values, we can calculate the resolution
 149:../LSM9DS1_drivers.c **** 	// of each sensor. That's what these functions are for. One for each sensor
 150:../LSM9DS1_drivers.c **** 	calcgRes(); // Calculate DPS / ADC tick, stored in gRes variable
 400              		.loc 1 150 0
 401 0032 FFF7FEFF 		bl	calcgRes
 151:../LSM9DS1_drivers.c **** 	calcmRes(); // Calculate Gs / ADC tick, stored in mRes variable
 402              		.loc 1 151 0
 403 0036 FFF7FEFF 		bl	calcmRes
 152:../LSM9DS1_drivers.c **** 	calcaRes(); // Calculate g / ADC tick, stored in aRes variable
 404              		.loc 1 152 0
 405 003a FFF7FEFF 		bl	calcaRes
 153:../LSM9DS1_drivers.c **** 
 154:../LSM9DS1_drivers.c **** 	if (settings.device.commInterface == IMU_MODE_I2C)	// If we're using I2C
 406              		.loc 1 154 0
 407 003e 40F20003 		movw	r3, #:lower16:settings
 408 0042 C0F20003 		movt	r3, #:upper16:settings
 409 0046 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 410 0048 012B     		cmp	r3, #1
 411 004a 02D1     		bne	.L5
 155:../LSM9DS1_drivers.c **** 		initI2C();	// Initialize I2C
 412              		.loc 1 155 0
 413 004c FFF7FEFF 		bl	initI2C
 414 0050 08E0     		b	.L6
 415              	.L5:
 156:../LSM9DS1_drivers.c **** 	else if (settings.device.commInterface == IMU_MODE_SPI) 	// else, if we're using SPI
 416              		.loc 1 156 0
 417 0052 40F20003 		movw	r3, #:lower16:settings
 418 0056 C0F20003 		movt	r3, #:upper16:settings
 419 005a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 420 005c 002B     		cmp	r3, #0
 421 005e 01D1     		bne	.L6
 157:../LSM9DS1_drivers.c **** 		initSPI();	// Initialize SPI
 422              		.loc 1 157 0
 423 0060 FFF7FEFF 		bl	initSPI
 424              	.L6:
 158:../LSM9DS1_drivers.c **** 
 159:../LSM9DS1_drivers.c **** 	// To verify communication, we can read from the WHO_AM_I register of
 160:../LSM9DS1_drivers.c **** 	// each device. Store those in a variable so we can return them.
 161:../LSM9DS1_drivers.c **** 	uint8_t mTest = mReadByte(WHO_AM_I_M);		// Read the gyro WHO_AM_I
 425              		.loc 1 161 0
 426 0064 4FF00F00 		mov	r0, #15
 427 0068 FFF7FEFF 		bl	mReadByte
 428 006c 0346     		mov	r3, r0
 429 006e FB71     		strb	r3, [r7, #7]
 162:../LSM9DS1_drivers.c **** 	uint8_t xgTest = xgReadByte(WHO_AM_I_XG);	// Read the accel/mag WHO_AM_I
 430              		.loc 1 162 0
 431 0070 4FF00F00 		mov	r0, #15
 432 0074 FFF7FEFF 		bl	xgReadByte
 433 0078 0346     		mov	r3, r0
 434 007a BB71     		strb	r3, [r7, #6]
 163:../LSM9DS1_drivers.c **** 
 164:../LSM9DS1_drivers.c **** 	uint16_t whoAmICombined = (xgTest << 8) | mTest;
 435              		.loc 1 164 0
 436 007c BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 437 007e 4FEA0323 		lsl	r3, r3, #8
 438 0082 9AB2     		uxth	r2, r3
 439 0084 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 440 0086 9BB2     		uxth	r3, r3
 441 0088 1343     		orrs	r3, r3, r2
 442 008a 9BB2     		uxth	r3, r3
 443 008c BB80     		strh	r3, [r7, #4]	@ movhi
 165:../LSM9DS1_drivers.c **** 
 166:../LSM9DS1_drivers.c **** 	if (whoAmICombined != ((WHO_AM_I_AG_RSP << 8) | WHO_AM_I_M_RSP))
 444              		.loc 1 166 0
 445 008e BA88     		ldrh	r2, [r7, #4]
 446 0090 46F63D03 		movw	r3, #26685
 447 0094 9A42     		cmp	r2, r3
 448 0096 02D0     		beq	.L7
 167:../LSM9DS1_drivers.c **** 	{
 168:../LSM9DS1_drivers.c **** 		return 0;
 449              		.loc 1 168 0
 450 0098 4FF00003 		mov	r3, #0
 451 009c 06E0     		b	.L8
 452              	.L7:
 169:../LSM9DS1_drivers.c **** 	}
 170:../LSM9DS1_drivers.c **** 
 171:../LSM9DS1_drivers.c **** 	// Gyro initialization stuff:
 172:../LSM9DS1_drivers.c **** 	initGyro();	// This will "turn on" the gyro. Setting up interrupts, etc.
 453              		.loc 1 172 0
 454 009e FFF7FEFF 		bl	initGyro
 173:../LSM9DS1_drivers.c **** 
 174:../LSM9DS1_drivers.c **** 	// Accelerometer initialization stuff:
 175:../LSM9DS1_drivers.c **** 	initAccel(); // "Turn on" all axes of the accel. Set up interrupts, etc.
 455              		.loc 1 175 0
 456 00a2 FFF7FEFF 		bl	initAccel
 176:../LSM9DS1_drivers.c **** 
 177:../LSM9DS1_drivers.c **** 	// Magnetometer initialization stuff:
 178:../LSM9DS1_drivers.c **** 	initMag(); // "Turn on" all axes of the mag. Set up interrupts, etc.
 457              		.loc 1 178 0
 458 00a6 FFF7FEFF 		bl	initMag
 179:../LSM9DS1_drivers.c **** 
 180:../LSM9DS1_drivers.c **** 	// Once everything is initialized, return the WHO_AM_I registers we read:
 181:../LSM9DS1_drivers.c **** 	return whoAmICombined;
 459              		.loc 1 181 0
 460 00aa BB88     		ldrh	r3, [r7, #4]
 461              	.L8:
 182:../LSM9DS1_drivers.c **** 
 183:../LSM9DS1_drivers.c **** }
 462              		.loc 1 183 0
 463 00ac 1846     		mov	r0, r3
 464 00ae 07F10807 		add	r7, r7, #8
 465 00b2 BD46     		mov	sp, r7
 466 00b4 80BD     		pop	{r7, pc}
 467              		.cfi_endproc
 468              	.LFE113:
 470 00b6 00BF     		.section	.text.constrainScales,"ax",%progbits
 471              		.align	2
 472              		.global	constrainScales
 473              		.thumb
 474              		.thumb_func
 476              	constrainScales:
 477              	.LFB114:
 184:../LSM9DS1_drivers.c **** 
 185:../LSM9DS1_drivers.c **** void constrainScales()
 186:../LSM9DS1_drivers.c **** {
 478              		.loc 1 186 0
 479              		.cfi_startproc
 480              		@ args = 0, pretend = 0, frame = 0
 481              		@ frame_needed = 1, uses_anonymous_args = 0
 482              		@ link register save eliminated.
 483 0000 80B4     		push	{r7}
 484              	.LCFI6:
 485              		.cfi_def_cfa_offset 4
 486              		.cfi_offset 7, -4
 487 0002 00AF     		add	r7, sp, #0
 488              	.LCFI7:
 489              		.cfi_def_cfa_register 7
 187:../LSM9DS1_drivers.c **** 	if ((settings.gyro.scale != 245) && (settings.gyro.scale != 500) && (settings.gyro.scale != 2000))
 490              		.loc 1 187 0
 491 0004 40F20003 		movw	r3, #:lower16:settings
 492 0008 C0F20003 		movt	r3, #:upper16:settings
 493 000c DB88     		ldrh	r3, [r3, #6]
 494 000e F52B     		cmp	r3, #245
 495 0010 16D0     		beq	.L10
 496              		.loc 1 187 0 is_stmt 0 discriminator 1
 497 0012 40F20003 		movw	r3, #:lower16:settings
 498 0016 C0F20003 		movt	r3, #:upper16:settings
 499 001a DB88     		ldrh	r3, [r3, #6]
 500 001c B3F5FA7F 		cmp	r3, #500
 501 0020 0ED0     		beq	.L10
 502 0022 40F20003 		movw	r3, #:lower16:settings
 503 0026 C0F20003 		movt	r3, #:upper16:settings
 504 002a DB88     		ldrh	r3, [r3, #6]
 505 002c B3F5FA6F 		cmp	r3, #2000
 506 0030 06D0     		beq	.L10
 188:../LSM9DS1_drivers.c **** 	{
 189:../LSM9DS1_drivers.c **** 		settings.gyro.scale = 245;
 507              		.loc 1 189 0 is_stmt 1
 508 0032 40F20003 		movw	r3, #:lower16:settings
 509 0036 C0F20003 		movt	r3, #:upper16:settings
 510 003a 4FF0F502 		mov	r2, #245
 511 003e DA80     		strh	r2, [r3, #6]	@ movhi
 512              	.L10:
 190:../LSM9DS1_drivers.c **** 	}
 191:../LSM9DS1_drivers.c **** 
 192:../LSM9DS1_drivers.c **** 	if ((settings.accel.scale != 2) && (settings.accel.scale != 4) && (settings.accel.scale != 8) && (
 513              		.loc 1 192 0
 514 0040 40F20003 		movw	r3, #:lower16:settings
 515 0044 C0F20003 		movt	r3, #:upper16:settings
 516 0048 DB7D     		ldrb	r3, [r3, #23]	@ zero_extendqisi2
 517 004a 022B     		cmp	r3, #2
 518 004c 1BD0     		beq	.L11
 519              		.loc 1 192 0 is_stmt 0 discriminator 1
 520 004e 40F20003 		movw	r3, #:lower16:settings
 521 0052 C0F20003 		movt	r3, #:upper16:settings
 522 0056 DB7D     		ldrb	r3, [r3, #23]	@ zero_extendqisi2
 523 0058 042B     		cmp	r3, #4
 524 005a 14D0     		beq	.L11
 525 005c 40F20003 		movw	r3, #:lower16:settings
 526 0060 C0F20003 		movt	r3, #:upper16:settings
 527 0064 DB7D     		ldrb	r3, [r3, #23]	@ zero_extendqisi2
 528 0066 082B     		cmp	r3, #8
 529 0068 0DD0     		beq	.L11
 530 006a 40F20003 		movw	r3, #:lower16:settings
 531 006e C0F20003 		movt	r3, #:upper16:settings
 532 0072 DB7D     		ldrb	r3, [r3, #23]	@ zero_extendqisi2
 533 0074 102B     		cmp	r3, #16
 534 0076 06D0     		beq	.L11
 193:../LSM9DS1_drivers.c **** 	{
 194:../LSM9DS1_drivers.c **** 		settings.accel.scale = 2;
 535              		.loc 1 194 0 is_stmt 1
 536 0078 40F20003 		movw	r3, #:lower16:settings
 537 007c C0F20003 		movt	r3, #:upper16:settings
 538 0080 4FF00202 		mov	r2, #2
 539 0084 DA75     		strb	r2, [r3, #23]
 540              	.L11:
 195:../LSM9DS1_drivers.c **** 	}
 196:../LSM9DS1_drivers.c **** 
 197:../LSM9DS1_drivers.c **** 	if ((settings.mag.scale != 4) && (settings.mag.scale != 8) && (settings.mag.scale != 12) && (setti
 541              		.loc 1 197 0
 542 0086 40F20003 		movw	r3, #:lower16:settings
 543 008a C0F20003 		movt	r3, #:upper16:settings
 544 008e 93F82030 		ldrb	r3, [r3, #32]	@ zero_extendqisi2
 545 0092 042B     		cmp	r3, #4
 546 0094 1FD0     		beq	.L9
 547              		.loc 1 197 0 is_stmt 0 discriminator 1
 548 0096 40F20003 		movw	r3, #:lower16:settings
 549 009a C0F20003 		movt	r3, #:upper16:settings
 550 009e 93F82030 		ldrb	r3, [r3, #32]	@ zero_extendqisi2
 551 00a2 082B     		cmp	r3, #8
 552 00a4 17D0     		beq	.L9
 553 00a6 40F20003 		movw	r3, #:lower16:settings
 554 00aa C0F20003 		movt	r3, #:upper16:settings
 555 00ae 93F82030 		ldrb	r3, [r3, #32]	@ zero_extendqisi2
 556 00b2 0C2B     		cmp	r3, #12
 557 00b4 0FD0     		beq	.L9
 558 00b6 40F20003 		movw	r3, #:lower16:settings
 559 00ba C0F20003 		movt	r3, #:upper16:settings
 560 00be 93F82030 		ldrb	r3, [r3, #32]	@ zero_extendqisi2
 561 00c2 102B     		cmp	r3, #16
 562 00c4 07D0     		beq	.L9
 198:../LSM9DS1_drivers.c **** 	{
 199:../LSM9DS1_drivers.c **** 		settings.mag.scale = 4;
 563              		.loc 1 199 0 is_stmt 1
 564 00c6 40F20003 		movw	r3, #:lower16:settings
 565 00ca C0F20003 		movt	r3, #:upper16:settings
 566 00ce 4FF00402 		mov	r2, #4
 567 00d2 83F82020 		strb	r2, [r3, #32]
 568              	.L9:
 200:../LSM9DS1_drivers.c **** 	}
 201:../LSM9DS1_drivers.c **** }
 569              		.loc 1 201 0
 570 00d6 BD46     		mov	sp, r7
 571 00d8 80BC     		pop	{r7}
 572 00da 7047     		bx	lr
 573              		.cfi_endproc
 574              	.LFE114:
 576              		.section	.text.calcgRes,"ax",%progbits
 577              		.align	2
 578              		.global	calcgRes
 579              		.thumb
 580              		.thumb_func
 582              	calcgRes:
 583              	.LFB115:
 202:../LSM9DS1_drivers.c **** 
 203:../LSM9DS1_drivers.c **** 
 204:../LSM9DS1_drivers.c **** void calcgRes()
 205:../LSM9DS1_drivers.c **** {
 584              		.loc 1 205 0
 585              		.cfi_startproc
 586              		@ args = 0, pretend = 0, frame = 0
 587              		@ frame_needed = 1, uses_anonymous_args = 0
 588              		@ link register save eliminated.
 589 0000 80B4     		push	{r7}
 590              	.LCFI8:
 591              		.cfi_def_cfa_offset 4
 592              		.cfi_offset 7, -4
 593 0002 00AF     		add	r7, sp, #0
 594              	.LCFI9:
 595              		.cfi_def_cfa_register 7
 206:../LSM9DS1_drivers.c **** 	gRes = ((float) settings.gyro.scale) / 32768.0;
 596              		.loc 1 206 0
 597 0004 40F20003 		movw	r3, #:lower16:settings
 598 0008 C0F20003 		movt	r3, #:upper16:settings
 599 000c DB88     		ldrh	r3, [r3, #6]
 600 000e 07EE903A 		fmsr	s15, r3	@ int
 601 0012 B8EE677A 		fuitos	s14, s15
 602 0016 DFED067A 		flds	s15, .L14
 603 001a C7EE277A 		fdivs	s15, s14, s15
 604 001e 40F20003 		movw	r3, #:lower16:gRes
 605 0022 C0F20003 		movt	r3, #:upper16:gRes
 606 0026 C3ED007A 		fsts	s15, [r3, #0]
 207:../LSM9DS1_drivers.c **** }
 607              		.loc 1 207 0
 608 002a BD46     		mov	sp, r7
 609 002c 80BC     		pop	{r7}
 610 002e 7047     		bx	lr
 611              	.L15:
 612              		.align	2
 613              	.L14:
 614 0030 00000047 		.word	1191182336
 615              		.cfi_endproc
 616              	.LFE115:
 618              		.section	.text.calcaRes,"ax",%progbits
 619              		.align	2
 620              		.global	calcaRes
 621              		.thumb
 622              		.thumb_func
 624              	calcaRes:
 625              	.LFB116:
 208:../LSM9DS1_drivers.c **** 
 209:../LSM9DS1_drivers.c **** void calcaRes()
 210:../LSM9DS1_drivers.c **** {
 626              		.loc 1 210 0
 627              		.cfi_startproc
 628              		@ args = 0, pretend = 0, frame = 0
 629              		@ frame_needed = 1, uses_anonymous_args = 0
 630              		@ link register save eliminated.
 631 0000 80B4     		push	{r7}
 632              	.LCFI10:
 633              		.cfi_def_cfa_offset 4
 634              		.cfi_offset 7, -4
 635 0002 00AF     		add	r7, sp, #0
 636              	.LCFI11:
 637              		.cfi_def_cfa_register 7
 211:../LSM9DS1_drivers.c **** 	aRes = ((float) settings.accel.scale) / 32768.0;
 638              		.loc 1 211 0
 639 0004 40F20003 		movw	r3, #:lower16:settings
 640 0008 C0F20003 		movt	r3, #:upper16:settings
 641 000c DB7D     		ldrb	r3, [r3, #23]	@ zero_extendqisi2
 642 000e 07EE903A 		fmsr	s15, r3	@ int
 643 0012 B8EE677A 		fuitos	s14, s15
 644 0016 DFED067A 		flds	s15, .L17
 645 001a C7EE277A 		fdivs	s15, s14, s15
 646 001e 40F20003 		movw	r3, #:lower16:aRes
 647 0022 C0F20003 		movt	r3, #:upper16:aRes
 648 0026 C3ED007A 		fsts	s15, [r3, #0]
 212:../LSM9DS1_drivers.c **** }
 649              		.loc 1 212 0
 650 002a BD46     		mov	sp, r7
 651 002c 80BC     		pop	{r7}
 652 002e 7047     		bx	lr
 653              	.L18:
 654              		.align	2
 655              	.L17:
 656 0030 00000047 		.word	1191182336
 657              		.cfi_endproc
 658              	.LFE116:
 660              		.section	.text.calcmRes,"ax",%progbits
 661              		.align	2
 662              		.global	calcmRes
 663              		.thumb
 664              		.thumb_func
 666              	calcmRes:
 667              	.LFB117:
 213:../LSM9DS1_drivers.c **** 
 214:../LSM9DS1_drivers.c **** 
 215:../LSM9DS1_drivers.c **** void calcmRes()
 216:../LSM9DS1_drivers.c **** {
 668              		.loc 1 216 0
 669              		.cfi_startproc
 670              		@ args = 0, pretend = 0, frame = 0
 671              		@ frame_needed = 1, uses_anonymous_args = 0
 672              		@ link register save eliminated.
 673 0000 80B4     		push	{r7}
 674              	.LCFI12:
 675              		.cfi_def_cfa_offset 4
 676              		.cfi_offset 7, -4
 677 0002 00AF     		add	r7, sp, #0
 678              	.LCFI13:
 679              		.cfi_def_cfa_register 7
 217:../LSM9DS1_drivers.c **** 	//mRes = ((float) settings.mag.scale) / 32768.0;
 218:../LSM9DS1_drivers.c **** 	switch (settings.mag.scale)
 680              		.loc 1 218 0
 681 0004 40F20003 		movw	r3, #:lower16:settings
 682 0008 C0F20003 		movt	r3, #:upper16:settings
 683 000c 93F82030 		ldrb	r3, [r3, #32]	@ zero_extendqisi2
 684 0010 A3F10403 		sub	r3, r3, #4
 685 0014 0C2B     		cmp	r3, #12
 686 0016 49D8     		bhi	.L19
 687 0018 01A2     		adr	r2, .L25
 688 001a 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 689 001e 00BF     		.align	2
 690              	.L25:
 691 0020 55000000 		.word	.L21+1
 692 0024 AD000000 		.word	.L19+1
 693 0028 AD000000 		.word	.L19+1
 694 002c AD000000 		.word	.L19+1
 695 0030 6B000000 		.word	.L22+1
 696 0034 AD000000 		.word	.L19+1
 697 0038 AD000000 		.word	.L19+1
 698 003c AD000000 		.word	.L19+1
 699 0040 81000000 		.word	.L23+1
 700 0044 AD000000 		.word	.L19+1
 701 0048 AD000000 		.word	.L19+1
 702 004c AD000000 		.word	.L19+1
 703 0050 97000000 		.word	.L24+1
 704              	.L21:
 219:../LSM9DS1_drivers.c **** 	{
 220:../LSM9DS1_drivers.c **** 		case 4:
 221:../LSM9DS1_drivers.c **** 			mRes = magSensitivity[0];
 705              		.loc 1 221 0
 706 0054 40F20003 		movw	r3, #:lower16:magSensitivity
 707 0058 C0F20003 		movt	r3, #:upper16:magSensitivity
 708 005c 1A68     		ldr	r2, [r3, #0]	@ float
 709 005e 40F20003 		movw	r3, #:lower16:mRes
 710 0062 C0F20003 		movt	r3, #:upper16:mRes
 711 0066 1A60     		str	r2, [r3, #0]	@ float
 222:../LSM9DS1_drivers.c **** 			break;
 712              		.loc 1 222 0
 713 0068 20E0     		b	.L19
 714              	.L22:
 223:../LSM9DS1_drivers.c **** 		case 8:
 224:../LSM9DS1_drivers.c **** 			mRes = magSensitivity[1];
 715              		.loc 1 224 0
 716 006a 40F20003 		movw	r3, #:lower16:magSensitivity
 717 006e C0F20003 		movt	r3, #:upper16:magSensitivity
 718 0072 5A68     		ldr	r2, [r3, #4]	@ float
 719 0074 40F20003 		movw	r3, #:lower16:mRes
 720 0078 C0F20003 		movt	r3, #:upper16:mRes
 721 007c 1A60     		str	r2, [r3, #0]	@ float
 225:../LSM9DS1_drivers.c **** 			break;
 722              		.loc 1 225 0
 723 007e 15E0     		b	.L19
 724              	.L23:
 226:../LSM9DS1_drivers.c **** 		case 12:
 227:../LSM9DS1_drivers.c **** 			mRes = magSensitivity[2];
 725              		.loc 1 227 0
 726 0080 40F20003 		movw	r3, #:lower16:magSensitivity
 727 0084 C0F20003 		movt	r3, #:upper16:magSensitivity
 728 0088 9A68     		ldr	r2, [r3, #8]	@ float
 729 008a 40F20003 		movw	r3, #:lower16:mRes
 730 008e C0F20003 		movt	r3, #:upper16:mRes
 731 0092 1A60     		str	r2, [r3, #0]	@ float
 228:../LSM9DS1_drivers.c **** 			break;
 732              		.loc 1 228 0
 733 0094 0AE0     		b	.L19
 734              	.L24:
 229:../LSM9DS1_drivers.c **** 		case 16:
 230:../LSM9DS1_drivers.c **** 			mRes = magSensitivity[3];
 735              		.loc 1 230 0
 736 0096 40F20003 		movw	r3, #:lower16:magSensitivity
 737 009a C0F20003 		movt	r3, #:upper16:magSensitivity
 738 009e DA68     		ldr	r2, [r3, #12]	@ float
 739 00a0 40F20003 		movw	r3, #:lower16:mRes
 740 00a4 C0F20003 		movt	r3, #:upper16:mRes
 741 00a8 1A60     		str	r2, [r3, #0]	@ float
 231:../LSM9DS1_drivers.c **** 			break;
 742              		.loc 1 231 0
 743 00aa 00BF     		nop
 744              	.L19:
 232:../LSM9DS1_drivers.c **** 	}
 233:../LSM9DS1_drivers.c **** 
 234:../LSM9DS1_drivers.c **** }
 745              		.loc 1 234 0
 746 00ac BD46     		mov	sp, r7
 747 00ae 80BC     		pop	{r7}
 748 00b0 7047     		bx	lr
 749              		.cfi_endproc
 750              	.LFE117:
 752 00b2 00BF     		.section	.text.initI2C,"ax",%progbits
 753              		.align	2
 754              		.global	initI2C
 755              		.thumb
 756              		.thumb_func
 758              	initI2C:
 759              	.LFB118:
 235:../LSM9DS1_drivers.c **** 
 236:../LSM9DS1_drivers.c **** void initI2C(void)
 237:../LSM9DS1_drivers.c **** {
 760              		.loc 1 237 0
 761              		.cfi_startproc
 762              		@ args = 0, pretend = 0, frame = 0
 763              		@ frame_needed = 1, uses_anonymous_args = 0
 764              		@ link register save eliminated.
 765 0000 80B4     		push	{r7}
 766              	.LCFI14:
 767              		.cfi_def_cfa_offset 4
 768              		.cfi_offset 7, -4
 769 0002 00AF     		add	r7, sp, #0
 770              	.LCFI15:
 771              		.cfi_def_cfa_register 7
 238:../LSM9DS1_drivers.c **** 	;
 239:../LSM9DS1_drivers.c **** }
 772              		.loc 1 239 0
 773 0004 BD46     		mov	sp, r7
 774 0006 80BC     		pop	{r7}
 775 0008 7047     		bx	lr
 776              		.cfi_endproc
 777              	.LFE118:
 779 000a 00BF     		.section	.text.initSPI,"ax",%progbits
 780              		.align	2
 781              		.global	initSPI
 782              		.thumb
 783              		.thumb_func
 785              	initSPI:
 786              	.LFB119:
 240:../LSM9DS1_drivers.c **** 
 241:../LSM9DS1_drivers.c **** void initSPI(void)
 242:../LSM9DS1_drivers.c **** {
 787              		.loc 1 242 0
 788              		.cfi_startproc
 789              		@ args = 0, pretend = 0, frame = 0
 790              		@ frame_needed = 1, uses_anonymous_args = 0
 791              		@ link register save eliminated.
 792 0000 80B4     		push	{r7}
 793              	.LCFI16:
 794              		.cfi_def_cfa_offset 4
 795              		.cfi_offset 7, -4
 796 0002 00AF     		add	r7, sp, #0
 797              	.LCFI17:
 798              		.cfi_def_cfa_register 7
 243:../LSM9DS1_drivers.c **** 	;
 244:../LSM9DS1_drivers.c **** }
 799              		.loc 1 244 0
 800 0004 BD46     		mov	sp, r7
 801 0006 80BC     		pop	{r7}
 802 0008 7047     		bx	lr
 803              		.cfi_endproc
 804              	.LFE119:
 806 000a 00BF     		.section	.text.I2CreadByte,"ax",%progbits
 807              		.align	2
 808              		.global	I2CreadByte
 809              		.thumb
 810              		.thumb_func
 812              	I2CreadByte:
 813              	.LFB120:
 245:../LSM9DS1_drivers.c **** 
 246:../LSM9DS1_drivers.c **** uint8_t I2CreadByte(uint8_t address, uint8_t subAddress)
 247:../LSM9DS1_drivers.c **** {
 814              		.loc 1 247 0
 815              		.cfi_startproc
 816              		@ args = 0, pretend = 0, frame = 16
 817              		@ frame_needed = 1, uses_anonymous_args = 0
 818 0000 80B5     		push	{r7, lr}
 819              	.LCFI18:
 820              		.cfi_def_cfa_offset 8
 821              		.cfi_offset 7, -8
 822              		.cfi_offset 14, -4
 823 0002 86B0     		sub	sp, sp, #24
 824              	.LCFI19:
 825              		.cfi_def_cfa_offset 32
 826 0004 02AF     		add	r7, sp, #8
 827              	.LCFI20:
 828              		.cfi_def_cfa 7, 24
 829 0006 0246     		mov	r2, r0
 830 0008 0B46     		mov	r3, r1
 831 000a FA71     		strb	r2, [r7, #7]
 832 000c BB71     		strb	r3, [r7, #6]
 248:../LSM9DS1_drivers.c **** 	//I2C001_DataType data1,data2,data3,data4,data5, data6, data7;
 249:../LSM9DS1_drivers.c **** 
 250:../LSM9DS1_drivers.c **** 	uint16_t DataReceive1 = 0x0000;
 833              		.loc 1 250 0
 834 000e 4FF00003 		mov	r3, #0
 835 0012 FB81     		strh	r3, [r7, #14]	@ movhi
 251:../LSM9DS1_drivers.c **** 	addressTimer = address;
 836              		.loc 1 251 0
 837 0014 40F20003 		movw	r3, #:lower16:addressTimer
 838 0018 C0F20003 		movt	r3, #:upper16:addressTimer
 839 001c FA79     		ldrb	r2, [r7, #7]
 840 001e 1A70     		strb	r2, [r3, #0]
 252:../LSM9DS1_drivers.c **** 	subAddressTimer = subAddress;
 841              		.loc 1 252 0
 842 0020 40F20003 		movw	r3, #:lower16:subAddressTimer
 843 0024 C0F20003 		movt	r3, #:upper16:subAddressTimer
 844 0028 BA79     		ldrb	r2, [r7, #6]
 845 002a 1A70     		strb	r2, [r3, #0]
 253:../LSM9DS1_drivers.c **** 
 254:../LSM9DS1_drivers.c **** 	makeTimer(200, SYSTM001_PERIODIC, timerHandlerI2CreadByte, NULL, &Status, &TimerId);
 846              		.loc 1 254 0
 847 002c 40F20003 		movw	r3, #:lower16:Status
 848 0030 C0F20003 		movt	r3, #:upper16:Status
 849 0034 0093     		str	r3, [sp, #0]
 850 0036 40F20003 		movw	r3, #:lower16:TimerId
 851 003a C0F20003 		movt	r3, #:upper16:TimerId
 852 003e 0193     		str	r3, [sp, #4]
 853 0040 4FF0C800 		mov	r0, #200
 854 0044 4FF00101 		mov	r1, #1
 855 0048 40F20002 		movw	r2, #:lower16:timerHandlerI2CreadByte
 856 004c C0F20002 		movt	r2, #:upper16:timerHandlerI2CreadByte
 857 0050 4FF00003 		mov	r3, #0
 858 0054 FFF7FEFF 		bl	makeTimer
 859 0058 00E0     		b	.L31
 860              	.L33:
 255:../LSM9DS1_drivers.c **** 	while(1)
 256:../LSM9DS1_drivers.c **** 	{
 257:../LSM9DS1_drivers.c **** 		if(6 == indexI2CreadByte)
 258:../LSM9DS1_drivers.c **** 		{
 259:../LSM9DS1_drivers.c **** 			removeTimer(&Status, &TimerId);
 260:../LSM9DS1_drivers.c **** 			DataReceive1 = DataReceive2;
 261:../LSM9DS1_drivers.c **** 			indexI2CreadByte = 0;
 262:../LSM9DS1_drivers.c **** 			addressTimer = 0;
 263:../LSM9DS1_drivers.c **** 			subAddressTimer = 0;
 264:../LSM9DS1_drivers.c **** 			DataReceive2 = 0x0000;
 265:../LSM9DS1_drivers.c **** 
 266:../LSM9DS1_drivers.c **** 			Status = SYSTM001_ERROR;
 267:../LSM9DS1_drivers.c **** 			TimerId = 0;
 268:../LSM9DS1_drivers.c **** 			break;
 269:../LSM9DS1_drivers.c **** 		}
 270:../LSM9DS1_drivers.c **** 	}
 861              		.loc 1 270 0
 862 005a 00BF     		nop
 863              	.L31:
 257:../LSM9DS1_drivers.c **** 		if(6 == indexI2CreadByte)
 864              		.loc 1 257 0
 865 005c 40F20003 		movw	r3, #:lower16:indexI2CreadByte
 866 0060 C0F20003 		movt	r3, #:upper16:indexI2CreadByte
 867 0064 1B68     		ldr	r3, [r3, #0]
 868 0066 062B     		cmp	r3, #6
 869 0068 F7D1     		bne	.L33
 259:../LSM9DS1_drivers.c **** 			removeTimer(&Status, &TimerId);
 870              		.loc 1 259 0
 871 006a 40F20000 		movw	r0, #:lower16:Status
 872 006e C0F20000 		movt	r0, #:upper16:Status
 873 0072 40F20001 		movw	r1, #:lower16:TimerId
 874 0076 C0F20001 		movt	r1, #:upper16:TimerId
 875 007a FFF7FEFF 		bl	removeTimer
 260:../LSM9DS1_drivers.c **** 			DataReceive1 = DataReceive2;
 876              		.loc 1 260 0
 877 007e 40F20003 		movw	r3, #:lower16:DataReceive2
 878 0082 C0F20003 		movt	r3, #:upper16:DataReceive2
 879 0086 1B88     		ldrh	r3, [r3, #0]	@ movhi
 880 0088 FB81     		strh	r3, [r7, #14]	@ movhi
 261:../LSM9DS1_drivers.c **** 			indexI2CreadByte = 0;
 881              		.loc 1 261 0
 882 008a 40F20003 		movw	r3, #:lower16:indexI2CreadByte
 883 008e C0F20003 		movt	r3, #:upper16:indexI2CreadByte
 884 0092 4FF00002 		mov	r2, #0
 885 0096 1A60     		str	r2, [r3, #0]
 262:../LSM9DS1_drivers.c **** 			addressTimer = 0;
 886              		.loc 1 262 0
 887 0098 40F20003 		movw	r3, #:lower16:addressTimer
 888 009c C0F20003 		movt	r3, #:upper16:addressTimer
 889 00a0 4FF00002 		mov	r2, #0
 890 00a4 1A70     		strb	r2, [r3, #0]
 263:../LSM9DS1_drivers.c **** 			subAddressTimer = 0;
 891              		.loc 1 263 0
 892 00a6 40F20003 		movw	r3, #:lower16:subAddressTimer
 893 00aa C0F20003 		movt	r3, #:upper16:subAddressTimer
 894 00ae 4FF00002 		mov	r2, #0
 895 00b2 1A70     		strb	r2, [r3, #0]
 264:../LSM9DS1_drivers.c **** 			DataReceive2 = 0x0000;
 896              		.loc 1 264 0
 897 00b4 40F20003 		movw	r3, #:lower16:DataReceive2
 898 00b8 C0F20003 		movt	r3, #:upper16:DataReceive2
 899 00bc 4FF00002 		mov	r2, #0
 900 00c0 1A80     		strh	r2, [r3, #0]	@ movhi
 266:../LSM9DS1_drivers.c **** 			Status = SYSTM001_ERROR;
 901              		.loc 1 266 0
 902 00c2 40F20003 		movw	r3, #:lower16:Status
 903 00c6 C0F20003 		movt	r3, #:upper16:Status
 904 00ca 4FF00202 		mov	r2, #2
 905 00ce 1A60     		str	r2, [r3, #0]
 267:../LSM9DS1_drivers.c **** 			TimerId = 0;
 906              		.loc 1 267 0
 907 00d0 40F20003 		movw	r3, #:lower16:TimerId
 908 00d4 C0F20003 		movt	r3, #:upper16:TimerId
 909 00d8 4FF00002 		mov	r2, #0
 910 00dc 1A60     		str	r2, [r3, #0]
 268:../LSM9DS1_drivers.c **** 			break;
 911              		.loc 1 268 0
 912 00de 00BF     		nop
 271:../LSM9DS1_drivers.c **** 
 272:../LSM9DS1_drivers.c **** 	return (uint8_t)DataReceive1;
 913              		.loc 1 272 0
 914 00e0 FB89     		ldrh	r3, [r7, #14]	@ movhi
 915 00e2 DBB2     		uxtb	r3, r3
 273:../LSM9DS1_drivers.c **** }
 916              		.loc 1 273 0
 917 00e4 1846     		mov	r0, r3
 918 00e6 07F11007 		add	r7, r7, #16
 919 00ea BD46     		mov	sp, r7
 920 00ec 80BD     		pop	{r7, pc}
 921              		.cfi_endproc
 922              	.LFE120:
 924 00ee 00BF     		.section	.text.mReadByte,"ax",%progbits
 925              		.align	2
 926              		.global	mReadByte
 927              		.thumb
 928              		.thumb_func
 930              	mReadByte:
 931              	.LFB121:
 274:../LSM9DS1_drivers.c **** 
 275:../LSM9DS1_drivers.c **** 
 276:../LSM9DS1_drivers.c **** uint8_t mReadByte(uint8_t subAddress)
 277:../LSM9DS1_drivers.c **** {
 932              		.loc 1 277 0
 933              		.cfi_startproc
 934              		@ args = 0, pretend = 0, frame = 8
 935              		@ frame_needed = 1, uses_anonymous_args = 0
 936 0000 80B5     		push	{r7, lr}
 937              	.LCFI21:
 938              		.cfi_def_cfa_offset 8
 939              		.cfi_offset 7, -8
 940              		.cfi_offset 14, -4
 941 0002 82B0     		sub	sp, sp, #8
 942              	.LCFI22:
 943              		.cfi_def_cfa_offset 16
 944 0004 00AF     		add	r7, sp, #0
 945              	.LCFI23:
 946              		.cfi_def_cfa_register 7
 947 0006 0346     		mov	r3, r0
 948 0008 FB71     		strb	r3, [r7, #7]
 278:../LSM9DS1_drivers.c **** 	// Whether we're using I2C or SPI, read a byte using the
 279:../LSM9DS1_drivers.c **** 	// accelerometer-specific I2C address or SPI CS pin.
 280:../LSM9DS1_drivers.c **** 	if (settings.device.commInterface == IMU_MODE_I2C)
 949              		.loc 1 280 0
 950 000a 40F20003 		movw	r3, #:lower16:settings
 951 000e C0F20003 		movt	r3, #:upper16:settings
 952 0012 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 953 0014 012B     		cmp	r3, #1
 954 0016 0BD1     		bne	.L35
 281:../LSM9DS1_drivers.c **** 		return I2CreadByte(_mAddress, subAddress);
 955              		.loc 1 281 0
 956 0018 40F20003 		movw	r3, #:lower16:_mAddress
 957 001c C0F20003 		movt	r3, #:upper16:_mAddress
 958 0020 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 959 0022 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 960 0024 1046     		mov	r0, r2
 961 0026 1946     		mov	r1, r3
 962 0028 FFF7FEFF 		bl	I2CreadByte
 963 002c 0346     		mov	r3, r0
 964 002e 13E0     		b	.L36
 965              	.L35:
 282:../LSM9DS1_drivers.c **** 	else if (settings.device.commInterface == IMU_MODE_SPI)
 966              		.loc 1 282 0
 967 0030 40F20003 		movw	r3, #:lower16:settings
 968 0034 C0F20003 		movt	r3, #:upper16:settings
 969 0038 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 970 003a 002B     		cmp	r3, #0
 971 003c 0BD1     		bne	.L37
 283:../LSM9DS1_drivers.c **** 		return SPIreadByte(_mAddress, subAddress);
 972              		.loc 1 283 0
 973 003e 40F20003 		movw	r3, #:lower16:_mAddress
 974 0042 C0F20003 		movt	r3, #:upper16:_mAddress
 975 0046 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 976 0048 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 977 004a 1046     		mov	r0, r2
 978 004c 1946     		mov	r1, r3
 979 004e FFF7FEFF 		bl	SPIreadByte
 980 0052 0346     		mov	r3, r0
 981 0054 00E0     		b	.L36
 982              	.L37:
 983 0056 FFE7     		b	.L34
 984              	.L36:
 985              	.L34:
 284:../LSM9DS1_drivers.c **** }
 986              		.loc 1 284 0
 987 0058 1846     		mov	r0, r3
 988 005a 07F10807 		add	r7, r7, #8
 989 005e BD46     		mov	sp, r7
 990 0060 80BD     		pop	{r7, pc}
 991              		.cfi_endproc
 992              	.LFE121:
 994 0062 00BF     		.section	.text.SPIreadByte,"ax",%progbits
 995              		.align	2
 996              		.global	SPIreadByte
 997              		.thumb
 998              		.thumb_func
 1000              	SPIreadByte:
 1001              	.LFB122:
 285:../LSM9DS1_drivers.c **** 
 286:../LSM9DS1_drivers.c **** uint8_t SPIreadByte(uint8_t csPin, uint8_t subAddress)
 287:../LSM9DS1_drivers.c **** {
 1002              		.loc 1 287 0
 1003              		.cfi_startproc
 1004              		@ args = 0, pretend = 0, frame = 8
 1005              		@ frame_needed = 1, uses_anonymous_args = 0
 1006              		@ link register save eliminated.
 1007 0000 80B4     		push	{r7}
 1008              	.LCFI24:
 1009              		.cfi_def_cfa_offset 4
 1010              		.cfi_offset 7, -4
 1011 0002 83B0     		sub	sp, sp, #12
 1012              	.LCFI25:
 1013              		.cfi_def_cfa_offset 16
 1014 0004 00AF     		add	r7, sp, #0
 1015              	.LCFI26:
 1016              		.cfi_def_cfa_register 7
 1017 0006 0246     		mov	r2, r0
 1018 0008 0B46     		mov	r3, r1
 1019 000a FA71     		strb	r2, [r7, #7]
 1020 000c BB71     		strb	r3, [r7, #6]
 288:../LSM9DS1_drivers.c **** 	;
 289:../LSM9DS1_drivers.c **** }
 1021              		.loc 1 289 0
 1022 000e 1846     		mov	r0, r3
 1023 0010 07F10C07 		add	r7, r7, #12
 1024 0014 BD46     		mov	sp, r7
 1025 0016 80BC     		pop	{r7}
 1026 0018 7047     		bx	lr
 1027              		.cfi_endproc
 1028              	.LFE122:
 1030 001a 00BF     		.section	.text.xgReadByte,"ax",%progbits
 1031              		.align	2
 1032              		.global	xgReadByte
 1033              		.thumb
 1034              		.thumb_func
 1036              	xgReadByte:
 1037              	.LFB123:
 290:../LSM9DS1_drivers.c **** 
 291:../LSM9DS1_drivers.c **** uint8_t xgReadByte(uint8_t subAddress)
 292:../LSM9DS1_drivers.c **** {
 1038              		.loc 1 292 0
 1039              		.cfi_startproc
 1040              		@ args = 0, pretend = 0, frame = 8
 1041              		@ frame_needed = 1, uses_anonymous_args = 0
 1042 0000 80B5     		push	{r7, lr}
 1043              	.LCFI27:
 1044              		.cfi_def_cfa_offset 8
 1045              		.cfi_offset 7, -8
 1046              		.cfi_offset 14, -4
 1047 0002 82B0     		sub	sp, sp, #8
 1048              	.LCFI28:
 1049              		.cfi_def_cfa_offset 16
 1050 0004 00AF     		add	r7, sp, #0
 1051              	.LCFI29:
 1052              		.cfi_def_cfa_register 7
 1053 0006 0346     		mov	r3, r0
 1054 0008 FB71     		strb	r3, [r7, #7]
 293:../LSM9DS1_drivers.c **** 	// Whether we're using I2C or SPI, read a byte using the
 294:../LSM9DS1_drivers.c **** 	// gyro-specific I2C address or SPI CS pin.
 295:../LSM9DS1_drivers.c **** 	if (settings.device.commInterface == IMU_MODE_I2C)
 1055              		.loc 1 295 0
 1056 000a 40F20003 		movw	r3, #:lower16:settings
 1057 000e C0F20003 		movt	r3, #:upper16:settings
 1058 0012 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1059 0014 012B     		cmp	r3, #1
 1060 0016 0BD1     		bne	.L40
 296:../LSM9DS1_drivers.c **** 		return I2CreadByte(_xgAddress, subAddress);
 1061              		.loc 1 296 0
 1062 0018 40F20003 		movw	r3, #:lower16:_xgAddress
 1063 001c C0F20003 		movt	r3, #:upper16:_xgAddress
 1064 0020 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 1065 0022 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1066 0024 1046     		mov	r0, r2
 1067 0026 1946     		mov	r1, r3
 1068 0028 FFF7FEFF 		bl	I2CreadByte
 1069 002c 0346     		mov	r3, r0
 1070 002e 13E0     		b	.L41
 1071              	.L40:
 297:../LSM9DS1_drivers.c **** 	else if (settings.device.commInterface == IMU_MODE_SPI)
 1072              		.loc 1 297 0
 1073 0030 40F20003 		movw	r3, #:lower16:settings
 1074 0034 C0F20003 		movt	r3, #:upper16:settings
 1075 0038 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1076 003a 002B     		cmp	r3, #0
 1077 003c 0BD1     		bne	.L42
 298:../LSM9DS1_drivers.c **** 		return SPIreadByte(_xgAddress, subAddress);
 1078              		.loc 1 298 0
 1079 003e 40F20003 		movw	r3, #:lower16:_xgAddress
 1080 0042 C0F20003 		movt	r3, #:upper16:_xgAddress
 1081 0046 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 1082 0048 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1083 004a 1046     		mov	r0, r2
 1084 004c 1946     		mov	r1, r3
 1085 004e FFF7FEFF 		bl	SPIreadByte
 1086 0052 0346     		mov	r3, r0
 1087 0054 00E0     		b	.L41
 1088              	.L42:
 1089 0056 FFE7     		b	.L39
 1090              	.L41:
 1091              	.L39:
 299:../LSM9DS1_drivers.c **** }
 1092              		.loc 1 299 0
 1093 0058 1846     		mov	r0, r3
 1094 005a 07F10807 		add	r7, r7, #8
 1095 005e BD46     		mov	sp, r7
 1096 0060 80BD     		pop	{r7, pc}
 1097              		.cfi_endproc
 1098              	.LFE123:
 1100 0062 00BF     		.section	.text.xgReadBytes,"ax",%progbits
 1101              		.align	2
 1102              		.global	xgReadBytes
 1103              		.thumb
 1104              		.thumb_func
 1106              	xgReadBytes:
 1107              	.LFB124:
 300:../LSM9DS1_drivers.c **** 
 301:../LSM9DS1_drivers.c **** void xgReadBytes(uint8_t subAddress, uint8_t * dest, uint8_t count)
 302:../LSM9DS1_drivers.c **** {
 1108              		.loc 1 302 0
 1109              		.cfi_startproc
 1110              		@ args = 0, pretend = 0, frame = 8
 1111              		@ frame_needed = 1, uses_anonymous_args = 0
 1112 0000 80B5     		push	{r7, lr}
 1113              	.LCFI30:
 1114              		.cfi_def_cfa_offset 8
 1115              		.cfi_offset 7, -8
 1116              		.cfi_offset 14, -4
 1117 0002 82B0     		sub	sp, sp, #8
 1118              	.LCFI31:
 1119              		.cfi_def_cfa_offset 16
 1120 0004 00AF     		add	r7, sp, #0
 1121              	.LCFI32:
 1122              		.cfi_def_cfa_register 7
 1123 0006 3960     		str	r1, [r7, #0]
 1124 0008 1346     		mov	r3, r2
 1125 000a 0246     		mov	r2, r0
 1126 000c FA71     		strb	r2, [r7, #7]
 1127 000e BB71     		strb	r3, [r7, #6]
 303:../LSM9DS1_drivers.c **** 	// Whether we're using I2C or SPI, read multiple bytes using the
 304:../LSM9DS1_drivers.c **** 	// gyro-specific I2C address or SPI CS pin.
 305:../LSM9DS1_drivers.c **** 	if (settings.device.commInterface == IMU_MODE_I2C)
 1128              		.loc 1 305 0
 1129 0010 40F20003 		movw	r3, #:lower16:settings
 1130 0014 C0F20003 		movt	r3, #:upper16:settings
 1131 0018 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1132 001a 012B     		cmp	r3, #1
 1133 001c 0CD1     		bne	.L44
 306:../LSM9DS1_drivers.c **** 		I2CreadBytes(_xgAddress, subAddress, dest, count);
 1134              		.loc 1 306 0
 1135 001e 40F20003 		movw	r3, #:lower16:_xgAddress
 1136 0022 C0F20003 		movt	r3, #:upper16:_xgAddress
 1137 0026 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 1138 0028 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 1139 002a BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 1140 002c 0846     		mov	r0, r1
 1141 002e 1146     		mov	r1, r2
 1142 0030 3A68     		ldr	r2, [r7, #0]
 1143 0032 FFF7FEFF 		bl	I2CreadBytes
 1144 0036 12E0     		b	.L43
 1145              	.L44:
 307:../LSM9DS1_drivers.c **** 	else if (settings.device.commInterface == IMU_MODE_SPI)
 1146              		.loc 1 307 0
 1147 0038 40F20003 		movw	r3, #:lower16:settings
 1148 003c C0F20003 		movt	r3, #:upper16:settings
 1149 0040 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1150 0042 002B     		cmp	r3, #0
 1151 0044 0BD1     		bne	.L43
 308:../LSM9DS1_drivers.c **** 		SPIreadBytes(_xgAddress, subAddress, dest, count);
 1152              		.loc 1 308 0
 1153 0046 40F20003 		movw	r3, #:lower16:_xgAddress
 1154 004a C0F20003 		movt	r3, #:upper16:_xgAddress
 1155 004e 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 1156 0050 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 1157 0052 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 1158 0054 0846     		mov	r0, r1
 1159 0056 1146     		mov	r1, r2
 1160 0058 3A68     		ldr	r2, [r7, #0]
 1161 005a FFF7FEFF 		bl	SPIreadBytes
 1162              	.L43:
 309:../LSM9DS1_drivers.c **** }
 1163              		.loc 1 309 0
 1164 005e 07F10807 		add	r7, r7, #8
 1165 0062 BD46     		mov	sp, r7
 1166 0064 80BD     		pop	{r7, pc}
 1167              		.cfi_endproc
 1168              	.LFE124:
 1170              		.section	.text.I2CreadBytes,"ax",%progbits
 1171              		.align	2
 1172              		.global	I2CreadBytes
 1173              		.thumb
 1174              		.thumb_func
 1176              	I2CreadBytes:
 1177              	.LFB125:
 310:../LSM9DS1_drivers.c **** 
 311:../LSM9DS1_drivers.c **** uint8_t I2CreadBytes(uint8_t address, uint8_t subAddress, uint8_t * dest, uint8_t count)
 312:../LSM9DS1_drivers.c **** {
 1178              		.loc 1 312 0
 1179              		.cfi_startproc
 1180              		@ args = 0, pretend = 0, frame = 16
 1181              		@ frame_needed = 1, uses_anonymous_args = 0
 1182 0000 80B5     		push	{r7, lr}
 1183              	.LCFI33:
 1184              		.cfi_def_cfa_offset 8
 1185              		.cfi_offset 7, -8
 1186              		.cfi_offset 14, -4
 1187 0002 86B0     		sub	sp, sp, #24
 1188              	.LCFI34:
 1189              		.cfi_def_cfa_offset 32
 1190 0004 02AF     		add	r7, sp, #8
 1191              	.LCFI35:
 1192              		.cfi_def_cfa 7, 24
 1193 0006 3A60     		str	r2, [r7, #0]
 1194 0008 0246     		mov	r2, r0
 1195 000a FA71     		strb	r2, [r7, #7]
 1196 000c 0A46     		mov	r2, r1
 1197 000e BA71     		strb	r2, [r7, #6]
 1198 0010 7B71     		strb	r3, [r7, #5]
 313:../LSM9DS1_drivers.c **** 	addressTimerI2CReadBytes = address;
 1199              		.loc 1 313 0
 1200 0012 40F20003 		movw	r3, #:lower16:addressTimerI2CReadBytes
 1201 0016 C0F20003 		movt	r3, #:upper16:addressTimerI2CReadBytes
 1202 001a FA79     		ldrb	r2, [r7, #7]
 1203 001c 1A70     		strb	r2, [r3, #0]
 314:../LSM9DS1_drivers.c **** 	subAddressTimerI2CReadBytes = subAddress;
 1204              		.loc 1 314 0
 1205 001e 40F20003 		movw	r3, #:lower16:subAddressTimerI2CReadBytes
 1206 0022 C0F20003 		movt	r3, #:upper16:subAddressTimerI2CReadBytes
 1207 0026 BA79     		ldrb	r2, [r7, #6]
 1208 0028 1A70     		strb	r2, [r3, #0]
 315:../LSM9DS1_drivers.c **** 	makeTimer(300, SYSTM001_PERIODIC, timerHandlerI2CreadBytes, NULL, &StatusReadBytes, &TimerIdReadBy
 1209              		.loc 1 315 0
 1210 002a 40F20003 		movw	r3, #:lower16:StatusReadBytes
 1211 002e C0F20003 		movt	r3, #:upper16:StatusReadBytes
 1212 0032 0093     		str	r3, [sp, #0]
 1213 0034 40F20003 		movw	r3, #:lower16:TimerIdReadBytes
 1214 0038 C0F20003 		movt	r3, #:upper16:TimerIdReadBytes
 1215 003c 0193     		str	r3, [sp, #4]
 1216 003e 4FF49670 		mov	r0, #300
 1217 0042 4FF00101 		mov	r1, #1
 1218 0046 40F20002 		movw	r2, #:lower16:timerHandlerI2CreadBytes
 1219 004a C0F20002 		movt	r2, #:upper16:timerHandlerI2CreadBytes
 1220 004e 4FF00003 		mov	r3, #0
 1221 0052 FFF7FEFF 		bl	makeTimer
 1222 0056 00E0     		b	.L52
 1223              	.L54:
 316:../LSM9DS1_drivers.c **** 
 317:../LSM9DS1_drivers.c **** 	while(1)
 318:../LSM9DS1_drivers.c **** 	{
 319:../LSM9DS1_drivers.c **** 		if(5 == indexI2CreadBytes)
 320:../LSM9DS1_drivers.c **** 		{
 321:../LSM9DS1_drivers.c **** 			removeTimer(&StatusReadBytes, &TimerIdReadBytes);
 322:../LSM9DS1_drivers.c **** 
 323:../LSM9DS1_drivers.c **** 			indexI2CreadBytes = 0;
 324:../LSM9DS1_drivers.c **** 			addressTimerI2CReadBytes = 0;
 325:../LSM9DS1_drivers.c **** 			subAddressTimerI2CReadBytes = 0;
 326:../LSM9DS1_drivers.c **** 
 327:../LSM9DS1_drivers.c **** 			StatusReadBytes = SYSTM001_ERROR;
 328:../LSM9DS1_drivers.c **** 			TimerIdReadBytes = 0;
 329:../LSM9DS1_drivers.c **** 
 330:../LSM9DS1_drivers.c **** 			addressTimerI2CReadBytes = address;
 331:../LSM9DS1_drivers.c **** 			subAddressTimerI2CReadBytes = subAddress;
 332:../LSM9DS1_drivers.c **** 
 333:../LSM9DS1_drivers.c **** 			indexAccel = indexAccel + 1;
 334:../LSM9DS1_drivers.c **** 			subAddressTimerI2CReadBytes = subAddressTimerI2CReadBytes + indexAccel;
 335:../LSM9DS1_drivers.c **** 
 336:../LSM9DS1_drivers.c **** 			if(indexAccel == count)
 337:../LSM9DS1_drivers.c **** 			{
 338:../LSM9DS1_drivers.c **** 				/*dest[0] = (uint8_t)accelerationXYZ[0];
 339:../LSM9DS1_drivers.c **** 				dest[1] = (uint8_t)accelerationXYZ[1];
 340:../LSM9DS1_drivers.c **** 				dest[2] = (uint8_t)accelerationXYZ[2];
 341:../LSM9DS1_drivers.c **** 				dest[3] = (uint8_t)accelerationXYZ[3];
 342:../LSM9DS1_drivers.c **** 				dest[4] = (uint8_t)accelerationXYZ[4];
 343:../LSM9DS1_drivers.c **** 				dest[5] = (uint8_t)accelerationXYZ[5];*/
 344:../LSM9DS1_drivers.c **** 				int k = 0;
 345:../LSM9DS1_drivers.c **** 				for(k = 0; k < count; k++)
 346:../LSM9DS1_drivers.c **** 				{
 347:../LSM9DS1_drivers.c **** 					dest[k] = (uint8_t)accelerationXYZ[k];
 348:../LSM9DS1_drivers.c **** 				}
 349:../LSM9DS1_drivers.c **** 
 350:../LSM9DS1_drivers.c **** 				/*for(k = 0; k < 6; k++)
 351:../LSM9DS1_drivers.c **** 				{
 352:../LSM9DS1_drivers.c **** 					accelerationXYZ[k] = 0;
 353:../LSM9DS1_drivers.c **** 				}*/
 354:../LSM9DS1_drivers.c **** 				indexAccel = 0;
 355:../LSM9DS1_drivers.c **** 
 356:../LSM9DS1_drivers.c **** 				break;
 357:../LSM9DS1_drivers.c **** 			}
 358:../LSM9DS1_drivers.c **** 			else
 359:../LSM9DS1_drivers.c **** 			{
 360:../LSM9DS1_drivers.c **** 				makeTimer(100, SYSTM001_PERIODIC, timerHandlerI2CreadBytes, NULL, &StatusReadBytes, &TimerIdRea
 361:../LSM9DS1_drivers.c **** 			}
 362:../LSM9DS1_drivers.c **** 		}
 363:../LSM9DS1_drivers.c **** 	}
 1224              		.loc 1 363 0
 1225 0058 00BF     		nop
 1226              	.L52:
 319:../LSM9DS1_drivers.c **** 		if(5 == indexI2CreadBytes)
 1227              		.loc 1 319 0
 1228 005a 40F20003 		movw	r3, #:lower16:indexI2CreadBytes
 1229 005e C0F20003 		movt	r3, #:upper16:indexI2CreadBytes
 1230 0062 1B68     		ldr	r3, [r3, #0]
 1231 0064 052B     		cmp	r3, #5
 1232 0066 F7D1     		bne	.L54
 321:../LSM9DS1_drivers.c **** 			removeTimer(&StatusReadBytes, &TimerIdReadBytes);
 1233              		.loc 1 321 0
 1234 0068 40F20000 		movw	r0, #:lower16:StatusReadBytes
 1235 006c C0F20000 		movt	r0, #:upper16:StatusReadBytes
 1236 0070 40F20001 		movw	r1, #:lower16:TimerIdReadBytes
 1237 0074 C0F20001 		movt	r1, #:upper16:TimerIdReadBytes
 1238 0078 FFF7FEFF 		bl	removeTimer
 323:../LSM9DS1_drivers.c **** 			indexI2CreadBytes = 0;
 1239              		.loc 1 323 0
 1240 007c 40F20003 		movw	r3, #:lower16:indexI2CreadBytes
 1241 0080 C0F20003 		movt	r3, #:upper16:indexI2CreadBytes
 1242 0084 4FF00002 		mov	r2, #0
 1243 0088 1A60     		str	r2, [r3, #0]
 324:../LSM9DS1_drivers.c **** 			addressTimerI2CReadBytes = 0;
 1244              		.loc 1 324 0
 1245 008a 40F20003 		movw	r3, #:lower16:addressTimerI2CReadBytes
 1246 008e C0F20003 		movt	r3, #:upper16:addressTimerI2CReadBytes
 1247 0092 4FF00002 		mov	r2, #0
 1248 0096 1A70     		strb	r2, [r3, #0]
 325:../LSM9DS1_drivers.c **** 			subAddressTimerI2CReadBytes = 0;
 1249              		.loc 1 325 0
 1250 0098 40F20003 		movw	r3, #:lower16:subAddressTimerI2CReadBytes
 1251 009c C0F20003 		movt	r3, #:upper16:subAddressTimerI2CReadBytes
 1252 00a0 4FF00002 		mov	r2, #0
 1253 00a4 1A70     		strb	r2, [r3, #0]
 327:../LSM9DS1_drivers.c **** 			StatusReadBytes = SYSTM001_ERROR;
 1254              		.loc 1 327 0
 1255 00a6 40F20003 		movw	r3, #:lower16:StatusReadBytes
 1256 00aa C0F20003 		movt	r3, #:upper16:StatusReadBytes
 1257 00ae 4FF00202 		mov	r2, #2
 1258 00b2 1A60     		str	r2, [r3, #0]
 328:../LSM9DS1_drivers.c **** 			TimerIdReadBytes = 0;
 1259              		.loc 1 328 0
 1260 00b4 40F20003 		movw	r3, #:lower16:TimerIdReadBytes
 1261 00b8 C0F20003 		movt	r3, #:upper16:TimerIdReadBytes
 1262 00bc 4FF00002 		mov	r2, #0
 1263 00c0 1A60     		str	r2, [r3, #0]
 330:../LSM9DS1_drivers.c **** 			addressTimerI2CReadBytes = address;
 1264              		.loc 1 330 0
 1265 00c2 40F20003 		movw	r3, #:lower16:addressTimerI2CReadBytes
 1266 00c6 C0F20003 		movt	r3, #:upper16:addressTimerI2CReadBytes
 1267 00ca FA79     		ldrb	r2, [r7, #7]
 1268 00cc 1A70     		strb	r2, [r3, #0]
 331:../LSM9DS1_drivers.c **** 			subAddressTimerI2CReadBytes = subAddress;
 1269              		.loc 1 331 0
 1270 00ce 40F20003 		movw	r3, #:lower16:subAddressTimerI2CReadBytes
 1271 00d2 C0F20003 		movt	r3, #:upper16:subAddressTimerI2CReadBytes
 1272 00d6 BA79     		ldrb	r2, [r7, #6]
 1273 00d8 1A70     		strb	r2, [r3, #0]
 333:../LSM9DS1_drivers.c **** 			indexAccel = indexAccel + 1;
 1274              		.loc 1 333 0
 1275 00da 40F20003 		movw	r3, #:lower16:indexAccel
 1276 00de C0F20003 		movt	r3, #:upper16:indexAccel
 1277 00e2 1B68     		ldr	r3, [r3, #0]
 1278 00e4 03F10102 		add	r2, r3, #1
 1279 00e8 40F20003 		movw	r3, #:lower16:indexAccel
 1280 00ec C0F20003 		movt	r3, #:upper16:indexAccel
 1281 00f0 1A60     		str	r2, [r3, #0]
 334:../LSM9DS1_drivers.c **** 			subAddressTimerI2CReadBytes = subAddressTimerI2CReadBytes + indexAccel;
 1282              		.loc 1 334 0
 1283 00f2 40F20003 		movw	r3, #:lower16:indexAccel
 1284 00f6 C0F20003 		movt	r3, #:upper16:indexAccel
 1285 00fa 1B68     		ldr	r3, [r3, #0]
 1286 00fc DAB2     		uxtb	r2, r3
 1287 00fe 40F20003 		movw	r3, #:lower16:subAddressTimerI2CReadBytes
 1288 0102 C0F20003 		movt	r3, #:upper16:subAddressTimerI2CReadBytes
 1289 0106 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1290 0108 D318     		adds	r3, r2, r3
 1291 010a DAB2     		uxtb	r2, r3
 1292 010c 40F20003 		movw	r3, #:lower16:subAddressTimerI2CReadBytes
 1293 0110 C0F20003 		movt	r3, #:upper16:subAddressTimerI2CReadBytes
 1294 0114 1A70     		strb	r2, [r3, #0]
 336:../LSM9DS1_drivers.c **** 			if(indexAccel == count)
 1295              		.loc 1 336 0
 1296 0116 7A79     		ldrb	r2, [r7, #5]	@ zero_extendqisi2
 1297 0118 40F20003 		movw	r3, #:lower16:indexAccel
 1298 011c C0F20003 		movt	r3, #:upper16:indexAccel
 1299 0120 1B68     		ldr	r3, [r3, #0]
 1300 0122 9A42     		cmp	r2, r3
 1301 0124 23D1     		bne	.L48
 1302              	.LBB3:
 344:../LSM9DS1_drivers.c **** 				int k = 0;
 1303              		.loc 1 344 0
 1304 0126 4FF00003 		mov	r3, #0
 1305 012a FB60     		str	r3, [r7, #12]
 345:../LSM9DS1_drivers.c **** 				for(k = 0; k < count; k++)
 1306              		.loc 1 345 0
 1307 012c 4FF00003 		mov	r3, #0
 1308 0130 FB60     		str	r3, [r7, #12]
 1309 0132 0FE0     		b	.L49
 1310              	.L50:
 347:../LSM9DS1_drivers.c **** 					dest[k] = (uint8_t)accelerationXYZ[k];
 1311              		.loc 1 347 0 discriminator 2
 1312 0134 FB68     		ldr	r3, [r7, #12]
 1313 0136 3A68     		ldr	r2, [r7, #0]
 1314 0138 D218     		adds	r2, r2, r3
 1315 013a 40F20003 		movw	r3, #:lower16:accelerationXYZ
 1316 013e C0F20003 		movt	r3, #:upper16:accelerationXYZ
 1317 0142 F968     		ldr	r1, [r7, #12]
 1318 0144 33F81130 		ldrh	r3, [r3, r1, lsl #1]
 1319 0148 DBB2     		uxtb	r3, r3
 1320 014a 1370     		strb	r3, [r2, #0]
 345:../LSM9DS1_drivers.c **** 				for(k = 0; k < count; k++)
 1321              		.loc 1 345 0 discriminator 2
 1322 014c FB68     		ldr	r3, [r7, #12]
 1323 014e 03F10103 		add	r3, r3, #1
 1324 0152 FB60     		str	r3, [r7, #12]
 1325              	.L49:
 345:../LSM9DS1_drivers.c **** 				for(k = 0; k < count; k++)
 1326              		.loc 1 345 0 is_stmt 0 discriminator 1
 1327 0154 7A79     		ldrb	r2, [r7, #5]	@ zero_extendqisi2
 1328 0156 FB68     		ldr	r3, [r7, #12]
 1329 0158 9A42     		cmp	r2, r3
 1330 015a EBDC     		bgt	.L50
 354:../LSM9DS1_drivers.c **** 				indexAccel = 0;
 1331              		.loc 1 354 0 is_stmt 1
 1332 015c 40F20003 		movw	r3, #:lower16:indexAccel
 1333 0160 C0F20003 		movt	r3, #:upper16:indexAccel
 1334 0164 4FF00002 		mov	r2, #0
 1335 0168 1A60     		str	r2, [r3, #0]
 356:../LSM9DS1_drivers.c **** 				break;
 1336              		.loc 1 356 0
 1337 016a 00BF     		nop
 1338 016c 16E0     		b	.L53
 1339              	.L48:
 1340              	.LBE3:
 360:../LSM9DS1_drivers.c **** 				makeTimer(100, SYSTM001_PERIODIC, timerHandlerI2CreadBytes, NULL, &StatusReadBytes, &TimerIdRea
 1341              		.loc 1 360 0
 1342 016e 40F20003 		movw	r3, #:lower16:StatusReadBytes
 1343 0172 C0F20003 		movt	r3, #:upper16:StatusReadBytes
 1344 0176 0093     		str	r3, [sp, #0]
 1345 0178 40F20003 		movw	r3, #:lower16:TimerIdReadBytes
 1346 017c C0F20003 		movt	r3, #:upper16:TimerIdReadBytes
 1347 0180 0193     		str	r3, [sp, #4]
 1348 0182 4FF06400 		mov	r0, #100
 1349 0186 4FF00101 		mov	r1, #1
 1350 018a 40F20002 		movw	r2, #:lower16:timerHandlerI2CreadBytes
 1351 018e C0F20002 		movt	r2, #:upper16:timerHandlerI2CreadBytes
 1352 0192 4FF00003 		mov	r3, #0
 1353 0196 FFF7FEFF 		bl	makeTimer
 1354              		.loc 1 363 0
 1355 019a 5DE7     		b	.L54
 1356              	.L53:
 364:../LSM9DS1_drivers.c **** }
 1357              		.loc 1 364 0
 1358 019c 1846     		mov	r0, r3
 1359 019e 07F11007 		add	r7, r7, #16
 1360 01a2 BD46     		mov	sp, r7
 1361 01a4 80BD     		pop	{r7, pc}
 1362              		.cfi_endproc
 1363              	.LFE125:
 1365 01a6 00BF     		.section	.text.SPIreadBytes,"ax",%progbits
 1366              		.align	2
 1367              		.global	SPIreadBytes
 1368              		.thumb
 1369              		.thumb_func
 1371              	SPIreadBytes:
 1372              	.LFB126:
 365:../LSM9DS1_drivers.c **** 
 366:../LSM9DS1_drivers.c **** void SPIreadBytes(uint8_t csPin, uint8_t subAddress, uint8_t * dest, uint8_t count)
 367:../LSM9DS1_drivers.c **** {
 1373              		.loc 1 367 0
 1374              		.cfi_startproc
 1375              		@ args = 0, pretend = 0, frame = 8
 1376              		@ frame_needed = 1, uses_anonymous_args = 0
 1377              		@ link register save eliminated.
 1378 0000 80B4     		push	{r7}
 1379              	.LCFI36:
 1380              		.cfi_def_cfa_offset 4
 1381              		.cfi_offset 7, -4
 1382 0002 83B0     		sub	sp, sp, #12
 1383              	.LCFI37:
 1384              		.cfi_def_cfa_offset 16
 1385 0004 00AF     		add	r7, sp, #0
 1386              	.LCFI38:
 1387              		.cfi_def_cfa_register 7
 1388 0006 3A60     		str	r2, [r7, #0]
 1389 0008 0246     		mov	r2, r0
 1390 000a FA71     		strb	r2, [r7, #7]
 1391 000c 0A46     		mov	r2, r1
 1392 000e BA71     		strb	r2, [r7, #6]
 1393 0010 7B71     		strb	r3, [r7, #5]
 368:../LSM9DS1_drivers.c **** 	;
 369:../LSM9DS1_drivers.c **** }
 1394              		.loc 1 369 0
 1395 0012 07F10C07 		add	r7, r7, #12
 1396 0016 BD46     		mov	sp, r7
 1397 0018 80BC     		pop	{r7}
 1398 001a 7047     		bx	lr
 1399              		.cfi_endproc
 1400              	.LFE126:
 1402              		.section	.text.initGyro,"ax",%progbits
 1403              		.align	2
 1404              		.global	initGyro
 1405              		.thumb
 1406              		.thumb_func
 1408              	initGyro:
 1409              	.LFB127:
 370:../LSM9DS1_drivers.c **** 
 371:../LSM9DS1_drivers.c **** void initGyro(void)
 372:../LSM9DS1_drivers.c **** {
 1410              		.loc 1 372 0
 1411              		.cfi_startproc
 1412              		@ args = 0, pretend = 0, frame = 8
 1413              		@ frame_needed = 1, uses_anonymous_args = 0
 1414 0000 80B5     		push	{r7, lr}
 1415              	.LCFI39:
 1416              		.cfi_def_cfa_offset 8
 1417              		.cfi_offset 7, -8
 1418              		.cfi_offset 14, -4
 1419 0002 82B0     		sub	sp, sp, #8
 1420              	.LCFI40:
 1421              		.cfi_def_cfa_offset 16
 1422 0004 00AF     		add	r7, sp, #0
 1423              	.LCFI41:
 1424              		.cfi_def_cfa_register 7
 373:../LSM9DS1_drivers.c **** 	uint8_t tempRegValue = 0;
 1425              		.loc 1 373 0
 1426 0006 4FF00003 		mov	r3, #0
 1427 000a FB71     		strb	r3, [r7, #7]
 374:../LSM9DS1_drivers.c **** 
 375:../LSM9DS1_drivers.c **** 	// CTRL_REG1_G (Default value: 0x00)
 376:../LSM9DS1_drivers.c **** 	// [ODR_G2][ODR_G1][ODR_G0][FS_G1][FS_G0][0][BW_G1][BW_G0]
 377:../LSM9DS1_drivers.c **** 	// ODR_G[2:0] - Output data rate selection
 378:../LSM9DS1_drivers.c **** 	// FS_G[1:0] - Gyroscope full-scale selection
 379:../LSM9DS1_drivers.c **** 	// BW_G[1:0] - Gyroscope bandwidth selection
 380:../LSM9DS1_drivers.c **** 
 381:../LSM9DS1_drivers.c **** 	// To disable gyro, set sample rate bits to 0. We'll only set sample
 382:../LSM9DS1_drivers.c **** 	// rate if the gyro is enabled.
 383:../LSM9DS1_drivers.c **** 	if (settings.gyro.enabled)
 1428              		.loc 1 383 0
 1429 000c 40F20003 		movw	r3, #:lower16:settings
 1430 0010 C0F20003 		movt	r3, #:upper16:settings
 1431 0014 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1432 0016 002B     		cmp	r3, #0
 1433 0018 07D0     		beq	.L57
 384:../LSM9DS1_drivers.c **** 	{
 385:../LSM9DS1_drivers.c **** 		tempRegValue = (settings.gyro.sampleRate & 0x07) << 5;
 1434              		.loc 1 385 0
 1435 001a 40F20003 		movw	r3, #:lower16:settings
 1436 001e C0F20003 		movt	r3, #:upper16:settings
 1437 0022 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 1438 0024 4FEA4313 		lsl	r3, r3, #5
 1439 0028 FB71     		strb	r3, [r7, #7]
 1440              	.L57:
 386:../LSM9DS1_drivers.c **** 	}
 387:../LSM9DS1_drivers.c **** 
 388:../LSM9DS1_drivers.c **** 	switch (settings.gyro.scale)
 1441              		.loc 1 388 0
 1442 002a 40F20003 		movw	r3, #:lower16:settings
 1443 002e C0F20003 		movt	r3, #:upper16:settings
 1444 0032 DB88     		ldrh	r3, [r3, #6]
 1445 0034 B3F5FA7F 		cmp	r3, #500
 1446 0038 03D0     		beq	.L59
 1447 003a B3F5FA6F 		cmp	r3, #2000
 1448 003e 05D0     		beq	.L60
 1449 0040 09E0     		b	.L58
 1450              	.L59:
 389:../LSM9DS1_drivers.c **** 	{
 390:../LSM9DS1_drivers.c **** 		case 500:
 391:../LSM9DS1_drivers.c **** 			tempRegValue |= (0x1 << 3);
 1451              		.loc 1 391 0
 1452 0042 FB79     		ldrb	r3, [r7, #7]
 1453 0044 43F00803 		orr	r3, r3, #8
 1454 0048 FB71     		strb	r3, [r7, #7]
 392:../LSM9DS1_drivers.c **** 			break;
 1455              		.loc 1 392 0
 1456 004a 04E0     		b	.L58
 1457              	.L60:
 393:../LSM9DS1_drivers.c **** 		case 2000:
 394:../LSM9DS1_drivers.c **** 			tempRegValue |= (0x3 << 3);
 1458              		.loc 1 394 0
 1459 004c FB79     		ldrb	r3, [r7, #7]
 1460 004e 43F01803 		orr	r3, r3, #24
 1461 0052 FB71     		strb	r3, [r7, #7]
 395:../LSM9DS1_drivers.c **** 			break;
 1462              		.loc 1 395 0
 1463 0054 00BF     		nop
 1464              	.L58:
 396:../LSM9DS1_drivers.c **** 		// Otherwise we'll set it to 245 dps (0x0 << 4)
 397:../LSM9DS1_drivers.c **** 	}
 398:../LSM9DS1_drivers.c **** 	tempRegValue |= (settings.gyro.bandwidth & 0x3);
 1465              		.loc 1 398 0
 1466 0056 40F20003 		movw	r3, #:lower16:settings
 1467 005a C0F20003 		movt	r3, #:upper16:settings
 1468 005e 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 1469 0060 DBB2     		uxtb	r3, r3
 1470 0062 03F00303 		and	r3, r3, #3
 1471 0066 DAB2     		uxtb	r2, r3
 1472 0068 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1473 006a 1343     		orrs	r3, r3, r2
 1474 006c DBB2     		uxtb	r3, r3
 1475 006e FB71     		strb	r3, [r7, #7]
 399:../LSM9DS1_drivers.c **** 	xgWriteByte(CTRL_REG1_G, tempRegValue);
 1476              		.loc 1 399 0
 1477 0070 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1478 0072 4FF01000 		mov	r0, #16
 1479 0076 1946     		mov	r1, r3
 1480 0078 FFF7FEFF 		bl	xgWriteByte
 400:../LSM9DS1_drivers.c **** 
 401:../LSM9DS1_drivers.c **** 	// CTRL_REG2_G (Default value: 0x00)
 402:../LSM9DS1_drivers.c **** 	// [0][0][0][0][INT_SEL1][INT_SEL0][OUT_SEL1][OUT_SEL0]
 403:../LSM9DS1_drivers.c **** 	// INT_SEL[1:0] - INT selection configuration
 404:../LSM9DS1_drivers.c **** 	// OUT_SEL[1:0] - Out selection configuration
 405:../LSM9DS1_drivers.c **** 	xgWriteByte(CTRL_REG2_G, 0x00);
 1481              		.loc 1 405 0
 1482 007c 4FF01100 		mov	r0, #17
 1483 0080 4FF00001 		mov	r1, #0
 1484 0084 FFF7FEFF 		bl	xgWriteByte
 406:../LSM9DS1_drivers.c **** 
 407:../LSM9DS1_drivers.c **** 	// CTRL_REG3_G (Default value: 0x00)
 408:../LSM9DS1_drivers.c **** 	// [LP_mode][HP_EN][0][0][HPCF3_G][HPCF2_G][HPCF1_G][HPCF0_G]
 409:../LSM9DS1_drivers.c **** 	// LP_mode - Low-power mode enable (0: disabled, 1: enabled)
 410:../LSM9DS1_drivers.c **** 	// HP_EN - HPF enable (0:disabled, 1: enabled)
 411:../LSM9DS1_drivers.c **** 	// HPCF_G[3:0] - HPF cutoff frequency
 412:../LSM9DS1_drivers.c **** 	tempRegValue = settings.gyro.lowPowerEnable ? (1<<7) : 0;
 1485              		.loc 1 412 0
 1486 0088 40F20003 		movw	r3, #:lower16:settings
 1487 008c C0F20003 		movt	r3, #:upper16:settings
 1488 0090 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
 1489 0092 002B     		cmp	r3, #0
 1490 0094 02D0     		beq	.L61
 1491              		.loc 1 412 0 is_stmt 0 discriminator 1
 1492 0096 4FF08003 		mov	r3, #128
 1493 009a 01E0     		b	.L62
 1494              	.L61:
 1495              		.loc 1 412 0 discriminator 2
 1496 009c 4FF00003 		mov	r3, #0
 1497              	.L62:
 1498              		.loc 1 412 0 discriminator 3
 1499 00a0 FB71     		strb	r3, [r7, #7]
 413:../LSM9DS1_drivers.c **** 	if (settings.gyro.HPFEnable)
 1500              		.loc 1 413 0 is_stmt 1 discriminator 3
 1501 00a2 40F20003 		movw	r3, #:lower16:settings
 1502 00a6 C0F20003 		movt	r3, #:upper16:settings
 1503 00aa DB7A     		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 1504 00ac 002B     		cmp	r3, #0
 1505 00ae 0FD0     		beq	.L63
 414:../LSM9DS1_drivers.c **** 	{
 415:../LSM9DS1_drivers.c **** 		tempRegValue |= ((1<<6) | (settings.gyro.HPFCutoff & 0x0F));
 1506              		.loc 1 415 0
 1507 00b0 40F20003 		movw	r3, #:lower16:settings
 1508 00b4 C0F20003 		movt	r3, #:upper16:settings
 1509 00b8 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1510 00ba DBB2     		uxtb	r3, r3
 1511 00bc 03F00F03 		and	r3, r3, #15
 1512 00c0 DBB2     		uxtb	r3, r3
 1513 00c2 43F04003 		orr	r3, r3, #64
 1514 00c6 DAB2     		uxtb	r2, r3
 1515 00c8 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1516 00ca 1343     		orrs	r3, r3, r2
 1517 00cc DBB2     		uxtb	r3, r3
 1518 00ce FB71     		strb	r3, [r7, #7]
 1519              	.L63:
 416:../LSM9DS1_drivers.c **** 	}
 417:../LSM9DS1_drivers.c **** 	xgWriteByte(CTRL_REG3_G, tempRegValue);
 1520              		.loc 1 417 0
 1521 00d0 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1522 00d2 4FF01200 		mov	r0, #18
 1523 00d6 1946     		mov	r1, r3
 1524 00d8 FFF7FEFF 		bl	xgWriteByte
 418:../LSM9DS1_drivers.c **** 
 419:../LSM9DS1_drivers.c **** 	// CTRL_REG4 (Default value: 0x38)
 420:../LSM9DS1_drivers.c **** 	// [0][0][Zen_G][Yen_G][Xen_G][0][LIR_XL1][4D_XL1]
 421:../LSM9DS1_drivers.c **** 	// Zen_G - Z-axis output enable (0:disable, 1:enable)
 422:../LSM9DS1_drivers.c **** 	// Yen_G - Y-axis output enable (0:disable, 1:enable)
 423:../LSM9DS1_drivers.c **** 	// Xen_G - X-axis output enable (0:disable, 1:enable)
 424:../LSM9DS1_drivers.c **** 	// LIR_XL1 - Latched interrupt (0:not latched, 1:latched)
 425:../LSM9DS1_drivers.c **** 	// 4D_XL1 - 4D option on interrupt (0:6D used, 1:4D used)
 426:../LSM9DS1_drivers.c **** 	tempRegValue = 0;
 1525              		.loc 1 426 0
 1526 00dc 4FF00003 		mov	r3, #0
 1527 00e0 FB71     		strb	r3, [r7, #7]
 427:../LSM9DS1_drivers.c **** 	if (settings.gyro.enableZ) tempRegValue |= (1<<5);
 1528              		.loc 1 427 0
 1529 00e2 40F20003 		movw	r3, #:lower16:settings
 1530 00e6 C0F20003 		movt	r3, #:upper16:settings
 1531 00ea DB7C     		ldrb	r3, [r3, #19]	@ zero_extendqisi2
 1532 00ec 002B     		cmp	r3, #0
 1533 00ee 03D0     		beq	.L64
 1534              		.loc 1 427 0 is_stmt 0 discriminator 1
 1535 00f0 FB79     		ldrb	r3, [r7, #7]
 1536 00f2 43F02003 		orr	r3, r3, #32
 1537 00f6 FB71     		strb	r3, [r7, #7]
 1538              	.L64:
 428:../LSM9DS1_drivers.c **** 	if (settings.gyro.enableY) tempRegValue |= (1<<4);
 1539              		.loc 1 428 0 is_stmt 1
 1540 00f8 40F20003 		movw	r3, #:lower16:settings
 1541 00fc C0F20003 		movt	r3, #:upper16:settings
 1542 0100 9B7C     		ldrb	r3, [r3, #18]	@ zero_extendqisi2
 1543 0102 002B     		cmp	r3, #0
 1544 0104 03D0     		beq	.L65
 1545              		.loc 1 428 0 is_stmt 0 discriminator 1
 1546 0106 FB79     		ldrb	r3, [r7, #7]
 1547 0108 43F01003 		orr	r3, r3, #16
 1548 010c FB71     		strb	r3, [r7, #7]
 1549              	.L65:
 429:../LSM9DS1_drivers.c **** 	if (settings.gyro.enableX) tempRegValue |= (1<<3);
 1550              		.loc 1 429 0 is_stmt 1
 1551 010e 40F20003 		movw	r3, #:lower16:settings
 1552 0112 C0F20003 		movt	r3, #:upper16:settings
 1553 0116 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 1554 0118 002B     		cmp	r3, #0
 1555 011a 03D0     		beq	.L66
 1556              		.loc 1 429 0 is_stmt 0 discriminator 1
 1557 011c FB79     		ldrb	r3, [r7, #7]
 1558 011e 43F00803 		orr	r3, r3, #8
 1559 0122 FB71     		strb	r3, [r7, #7]
 1560              	.L66:
 430:../LSM9DS1_drivers.c **** 	if (settings.gyro.latchInterrupt) tempRegValue |= (1<<1);
 1561              		.loc 1 430 0 is_stmt 1
 1562 0124 40F20003 		movw	r3, #:lower16:settings
 1563 0128 C0F20003 		movt	r3, #:upper16:settings
 1564 012c 1B7D     		ldrb	r3, [r3, #20]	@ zero_extendqisi2
 1565 012e 002B     		cmp	r3, #0
 1566 0130 03D0     		beq	.L67
 1567              		.loc 1 430 0 is_stmt 0 discriminator 1
 1568 0132 FB79     		ldrb	r3, [r7, #7]
 1569 0134 43F00203 		orr	r3, r3, #2
 1570 0138 FB71     		strb	r3, [r7, #7]
 1571              	.L67:
 431:../LSM9DS1_drivers.c **** 	xgWriteByte(CTRL_REG4, tempRegValue);
 1572              		.loc 1 431 0 is_stmt 1
 1573 013a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1574 013c 4FF01E00 		mov	r0, #30
 1575 0140 1946     		mov	r1, r3
 1576 0142 FFF7FEFF 		bl	xgWriteByte
 432:../LSM9DS1_drivers.c **** 
 433:../LSM9DS1_drivers.c **** 	// ORIENT_CFG_G (Default value: 0x00)
 434:../LSM9DS1_drivers.c **** 	// [0][0][SignX_G][SignY_G][SignZ_G][Orient_2][Orient_1][Orient_0]
 435:../LSM9DS1_drivers.c **** 	// SignX_G - Pitch axis (X) angular rate sign (0: positive, 1: negative)
 436:../LSM9DS1_drivers.c **** 	// Orient [2:0] - Directional user orientation selection
 437:../LSM9DS1_drivers.c **** 	tempRegValue = 0;
 1577              		.loc 1 437 0
 1578 0146 4FF00003 		mov	r3, #0
 1579 014a FB71     		strb	r3, [r7, #7]
 438:../LSM9DS1_drivers.c **** 	if (settings.gyro.flipX) tempRegValue |= (1<<5);
 1580              		.loc 1 438 0
 1581 014c 40F20003 		movw	r3, #:lower16:settings
 1582 0150 C0F20003 		movt	r3, #:upper16:settings
 1583 0154 5B7B     		ldrb	r3, [r3, #13]	@ zero_extendqisi2
 1584 0156 002B     		cmp	r3, #0
 1585 0158 03D0     		beq	.L68
 1586              		.loc 1 438 0 is_stmt 0 discriminator 1
 1587 015a FB79     		ldrb	r3, [r7, #7]
 1588 015c 43F02003 		orr	r3, r3, #32
 1589 0160 FB71     		strb	r3, [r7, #7]
 1590              	.L68:
 439:../LSM9DS1_drivers.c **** 	if (settings.gyro.flipY) tempRegValue |= (1<<4);
 1591              		.loc 1 439 0 is_stmt 1
 1592 0162 40F20003 		movw	r3, #:lower16:settings
 1593 0166 C0F20003 		movt	r3, #:upper16:settings
 1594 016a 9B7B     		ldrb	r3, [r3, #14]	@ zero_extendqisi2
 1595 016c 002B     		cmp	r3, #0
 1596 016e 03D0     		beq	.L69
 1597              		.loc 1 439 0 is_stmt 0 discriminator 1
 1598 0170 FB79     		ldrb	r3, [r7, #7]
 1599 0172 43F01003 		orr	r3, r3, #16
 1600 0176 FB71     		strb	r3, [r7, #7]
 1601              	.L69:
 440:../LSM9DS1_drivers.c **** 	if (settings.gyro.flipZ) tempRegValue |= (1<<3);
 1602              		.loc 1 440 0 is_stmt 1
 1603 0178 40F20003 		movw	r3, #:lower16:settings
 1604 017c C0F20003 		movt	r3, #:upper16:settings
 1605 0180 DB7B     		ldrb	r3, [r3, #15]	@ zero_extendqisi2
 1606 0182 002B     		cmp	r3, #0
 1607 0184 03D0     		beq	.L70
 1608              		.loc 1 440 0 is_stmt 0 discriminator 1
 1609 0186 FB79     		ldrb	r3, [r7, #7]
 1610 0188 43F00803 		orr	r3, r3, #8
 1611 018c FB71     		strb	r3, [r7, #7]
 1612              	.L70:
 441:../LSM9DS1_drivers.c **** 	xgWriteByte(ORIENT_CFG_G, tempRegValue);
 1613              		.loc 1 441 0 is_stmt 1
 1614 018e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1615 0190 4FF01300 		mov	r0, #19
 1616 0194 1946     		mov	r1, r3
 1617 0196 FFF7FEFF 		bl	xgWriteByte
 442:../LSM9DS1_drivers.c **** }
 1618              		.loc 1 442 0
 1619 019a 07F10807 		add	r7, r7, #8
 1620 019e BD46     		mov	sp, r7
 1621 01a0 80BD     		pop	{r7, pc}
 1622              		.cfi_endproc
 1623              	.LFE127:
 1625 01a2 00BF     		.section	.text.xgWriteByte,"ax",%progbits
 1626              		.align	2
 1627              		.global	xgWriteByte
 1628              		.thumb
 1629              		.thumb_func
 1631              	xgWriteByte:
 1632              	.LFB128:
 443:../LSM9DS1_drivers.c **** 
 444:../LSM9DS1_drivers.c **** 
 445:../LSM9DS1_drivers.c **** void xgWriteByte(uint8_t subAddress, uint8_t data)
 446:../LSM9DS1_drivers.c **** {
 1633              		.loc 1 446 0
 1634              		.cfi_startproc
 1635              		@ args = 0, pretend = 0, frame = 8
 1636              		@ frame_needed = 1, uses_anonymous_args = 0
 1637 0000 80B5     		push	{r7, lr}
 1638              	.LCFI42:
 1639              		.cfi_def_cfa_offset 8
 1640              		.cfi_offset 7, -8
 1641              		.cfi_offset 14, -4
 1642 0002 82B0     		sub	sp, sp, #8
 1643              	.LCFI43:
 1644              		.cfi_def_cfa_offset 16
 1645 0004 00AF     		add	r7, sp, #0
 1646              	.LCFI44:
 1647              		.cfi_def_cfa_register 7
 1648 0006 0246     		mov	r2, r0
 1649 0008 0B46     		mov	r3, r1
 1650 000a FA71     		strb	r2, [r7, #7]
 1651 000c BB71     		strb	r3, [r7, #6]
 447:../LSM9DS1_drivers.c **** 	// Whether we're using I2C or SPI, write a byte using the
 448:../LSM9DS1_drivers.c **** 	// gyro-specific I2C address or SPI CS pin.
 449:../LSM9DS1_drivers.c **** 	if (settings.device.commInterface == IMU_MODE_I2C)
 1652              		.loc 1 449 0
 1653 000e 40F20003 		movw	r3, #:lower16:settings
 1654 0012 C0F20003 		movt	r3, #:upper16:settings
 1655 0016 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1656 0018 012B     		cmp	r3, #1
 1657 001a 0BD1     		bne	.L71
 450:../LSM9DS1_drivers.c **** 	{
 451:../LSM9DS1_drivers.c **** 		I2CwriteByte(_xgAddress, subAddress, data);
 1658              		.loc 1 451 0
 1659 001c 40F20003 		movw	r3, #:lower16:_xgAddress
 1660 0020 C0F20003 		movt	r3, #:upper16:_xgAddress
 1661 0024 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 1662 0026 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 1663 0028 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 1664 002a 0846     		mov	r0, r1
 1665 002c 1146     		mov	r1, r2
 1666 002e 1A46     		mov	r2, r3
 1667 0030 FFF7FEFF 		bl	I2CwriteByte
 1668              	.L71:
 452:../LSM9DS1_drivers.c **** 	}
 453:../LSM9DS1_drivers.c **** }
 1669              		.loc 1 453 0
 1670 0034 07F10807 		add	r7, r7, #8
 1671 0038 BD46     		mov	sp, r7
 1672 003a 80BD     		pop	{r7, pc}
 1673              		.cfi_endproc
 1674              	.LFE128:
 1676              		.section	.text.I2CwriteByte,"ax",%progbits
 1677              		.align	2
 1678              		.global	I2CwriteByte
 1679              		.thumb
 1680              		.thumb_func
 1682              	I2CwriteByte:
 1683              	.LFB129:
 454:../LSM9DS1_drivers.c **** 
 455:../LSM9DS1_drivers.c **** void I2CwriteByte(uint8_t address, uint8_t subAddress, uint8_t data)
 456:../LSM9DS1_drivers.c **** {
 1684              		.loc 1 456 0
 1685              		.cfi_startproc
 1686              		@ args = 0, pretend = 0, frame = 8
 1687              		@ frame_needed = 1, uses_anonymous_args = 0
 1688 0000 80B5     		push	{r7, lr}
 1689              	.LCFI45:
 1690              		.cfi_def_cfa_offset 8
 1691              		.cfi_offset 7, -8
 1692              		.cfi_offset 14, -4
 1693 0002 84B0     		sub	sp, sp, #16
 1694              	.LCFI46:
 1695              		.cfi_def_cfa_offset 24
 1696 0004 02AF     		add	r7, sp, #8
 1697              	.LCFI47:
 1698              		.cfi_def_cfa 7, 16
 1699 0006 1346     		mov	r3, r2
 1700 0008 0246     		mov	r2, r0
 1701 000a FA71     		strb	r2, [r7, #7]
 1702 000c 0A46     		mov	r2, r1
 1703 000e BA71     		strb	r2, [r7, #6]
 1704 0010 7B71     		strb	r3, [r7, #5]
 457:../LSM9DS1_drivers.c **** 	addressTimerWrite = address;
 1705              		.loc 1 457 0
 1706 0012 40F20003 		movw	r3, #:lower16:addressTimerWrite
 1707 0016 C0F20003 		movt	r3, #:upper16:addressTimerWrite
 1708 001a FA79     		ldrb	r2, [r7, #7]
 1709 001c 1A70     		strb	r2, [r3, #0]
 458:../LSM9DS1_drivers.c **** 	subAddressTimerWrite = subAddress;
 1710              		.loc 1 458 0
 1711 001e 40F20003 		movw	r3, #:lower16:subAddressTimerWrite
 1712 0022 C0F20003 		movt	r3, #:upper16:subAddressTimerWrite
 1713 0026 BA79     		ldrb	r2, [r7, #6]
 1714 0028 1A70     		strb	r2, [r3, #0]
 459:../LSM9DS1_drivers.c **** 	dataWrite = data;
 1715              		.loc 1 459 0
 1716 002a 40F20003 		movw	r3, #:lower16:dataWrite
 1717 002e C0F20003 		movt	r3, #:upper16:dataWrite
 1718 0032 7A79     		ldrb	r2, [r7, #5]
 1719 0034 1A70     		strb	r2, [r3, #0]
 460:../LSM9DS1_drivers.c **** 
 461:../LSM9DS1_drivers.c **** 	makeTimer(50, SYSTM001_PERIODIC, timerHandlerI2CwriteByte, NULL, &WriteTimerStatus, &WriteTimerId)
 1720              		.loc 1 461 0
 1721 0036 40F20003 		movw	r3, #:lower16:WriteTimerStatus
 1722 003a C0F20003 		movt	r3, #:upper16:WriteTimerStatus
 1723 003e 0093     		str	r3, [sp, #0]
 1724 0040 40F20003 		movw	r3, #:lower16:WriteTimerId
 1725 0044 C0F20003 		movt	r3, #:upper16:WriteTimerId
 1726 0048 0193     		str	r3, [sp, #4]
 1727 004a 4FF03200 		mov	r0, #50
 1728 004e 4FF00101 		mov	r1, #1
 1729 0052 40F20002 		movw	r2, #:lower16:timerHandlerI2CwriteByte
 1730 0056 C0F20002 		movt	r2, #:upper16:timerHandlerI2CwriteByte
 1731 005a 4FF00003 		mov	r3, #0
 1732 005e FFF7FEFF 		bl	makeTimer
 1733 0062 00E0     		b	.L76
 1734              	.L77:
 462:../LSM9DS1_drivers.c **** 
 463:../LSM9DS1_drivers.c **** 	while(1)
 464:../LSM9DS1_drivers.c **** 	{
 465:../LSM9DS1_drivers.c **** 		if(4 == indexI2CwriteByte)
 466:../LSM9DS1_drivers.c **** 		{
 467:../LSM9DS1_drivers.c **** 			removeTimer(&WriteTimerStatus, &WriteTimerId);
 468:../LSM9DS1_drivers.c **** 			indexI2CwriteByte = 0;
 469:../LSM9DS1_drivers.c **** 			addressTimerWrite = 0;
 470:../LSM9DS1_drivers.c **** 			subAddressTimerWrite = 0;
 471:../LSM9DS1_drivers.c **** 			WriteTimerStatus = SYSTM001_ERROR;
 472:../LSM9DS1_drivers.c **** 			WriteTimerId = 0;
 473:../LSM9DS1_drivers.c **** 			break;
 474:../LSM9DS1_drivers.c **** 		}
 475:../LSM9DS1_drivers.c **** 	}
 1735              		.loc 1 475 0
 1736 0064 00BF     		nop
 1737              	.L76:
 465:../LSM9DS1_drivers.c **** 		if(4 == indexI2CwriteByte)
 1738              		.loc 1 465 0
 1739 0066 40F20003 		movw	r3, #:lower16:indexI2CwriteByte
 1740 006a C0F20003 		movt	r3, #:upper16:indexI2CwriteByte
 1741 006e 1B68     		ldr	r3, [r3, #0]
 1742 0070 042B     		cmp	r3, #4
 1743 0072 F7D1     		bne	.L77
 467:../LSM9DS1_drivers.c **** 			removeTimer(&WriteTimerStatus, &WriteTimerId);
 1744              		.loc 1 467 0
 1745 0074 40F20000 		movw	r0, #:lower16:WriteTimerStatus
 1746 0078 C0F20000 		movt	r0, #:upper16:WriteTimerStatus
 1747 007c 40F20001 		movw	r1, #:lower16:WriteTimerId
 1748 0080 C0F20001 		movt	r1, #:upper16:WriteTimerId
 1749 0084 FFF7FEFF 		bl	removeTimer
 468:../LSM9DS1_drivers.c **** 			indexI2CwriteByte = 0;
 1750              		.loc 1 468 0
 1751 0088 40F20003 		movw	r3, #:lower16:indexI2CwriteByte
 1752 008c C0F20003 		movt	r3, #:upper16:indexI2CwriteByte
 1753 0090 4FF00002 		mov	r2, #0
 1754 0094 1A60     		str	r2, [r3, #0]
 469:../LSM9DS1_drivers.c **** 			addressTimerWrite = 0;
 1755              		.loc 1 469 0
 1756 0096 40F20003 		movw	r3, #:lower16:addressTimerWrite
 1757 009a C0F20003 		movt	r3, #:upper16:addressTimerWrite
 1758 009e 4FF00002 		mov	r2, #0
 1759 00a2 1A70     		strb	r2, [r3, #0]
 470:../LSM9DS1_drivers.c **** 			subAddressTimerWrite = 0;
 1760              		.loc 1 470 0
 1761 00a4 40F20003 		movw	r3, #:lower16:subAddressTimerWrite
 1762 00a8 C0F20003 		movt	r3, #:upper16:subAddressTimerWrite
 1763 00ac 4FF00002 		mov	r2, #0
 1764 00b0 1A70     		strb	r2, [r3, #0]
 471:../LSM9DS1_drivers.c **** 			WriteTimerStatus = SYSTM001_ERROR;
 1765              		.loc 1 471 0
 1766 00b2 40F20003 		movw	r3, #:lower16:WriteTimerStatus
 1767 00b6 C0F20003 		movt	r3, #:upper16:WriteTimerStatus
 1768 00ba 4FF00202 		mov	r2, #2
 1769 00be 1A60     		str	r2, [r3, #0]
 472:../LSM9DS1_drivers.c **** 			WriteTimerId = 0;
 1770              		.loc 1 472 0
 1771 00c0 40F20003 		movw	r3, #:lower16:WriteTimerId
 1772 00c4 C0F20003 		movt	r3, #:upper16:WriteTimerId
 1773 00c8 4FF00002 		mov	r2, #0
 1774 00cc 1A60     		str	r2, [r3, #0]
 473:../LSM9DS1_drivers.c **** 			break;
 1775              		.loc 1 473 0
 1776 00ce 00BF     		nop
 476:../LSM9DS1_drivers.c **** }
 1777              		.loc 1 476 0
 1778 00d0 07F10807 		add	r7, r7, #8
 1779 00d4 BD46     		mov	sp, r7
 1780 00d6 80BD     		pop	{r7, pc}
 1781              		.cfi_endproc
 1782              	.LFE129:
 1784              		.section	.text.initAccel,"ax",%progbits
 1785              		.align	2
 1786              		.global	initAccel
 1787              		.thumb
 1788              		.thumb_func
 1790              	initAccel:
 1791              	.LFB130:
 477:../LSM9DS1_drivers.c **** 
 478:../LSM9DS1_drivers.c **** void initAccel(void)
 479:../LSM9DS1_drivers.c **** {
 1792              		.loc 1 479 0
 1793              		.cfi_startproc
 1794              		@ args = 0, pretend = 0, frame = 8
 1795              		@ frame_needed = 1, uses_anonymous_args = 0
 1796 0000 80B5     		push	{r7, lr}
 1797              	.LCFI48:
 1798              		.cfi_def_cfa_offset 8
 1799              		.cfi_offset 7, -8
 1800              		.cfi_offset 14, -4
 1801 0002 82B0     		sub	sp, sp, #8
 1802              	.LCFI49:
 1803              		.cfi_def_cfa_offset 16
 1804 0004 00AF     		add	r7, sp, #0
 1805              	.LCFI50:
 1806              		.cfi_def_cfa_register 7
 480:../LSM9DS1_drivers.c **** 	uint8_t tempRegValue = 0;
 1807              		.loc 1 480 0
 1808 0006 4FF00003 		mov	r3, #0
 1809 000a FB71     		strb	r3, [r7, #7]
 481:../LSM9DS1_drivers.c **** 
 482:../LSM9DS1_drivers.c **** 	//	CTRL_REG5_XL (0x1F) (Default value: 0x38)
 483:../LSM9DS1_drivers.c **** 	//	[DEC_1][DEC_0][Zen_XL][Yen_XL][Zen_XL][0][0][0]
 484:../LSM9DS1_drivers.c **** 	//	DEC[0:1] - Decimation of accel data on OUT REG and FIFO.
 485:../LSM9DS1_drivers.c **** 	//		00: None, 01: 2 samples, 10: 4 samples 11: 8 samples
 486:../LSM9DS1_drivers.c **** 	//	Zen_XL - Z-axis output enabled
 487:../LSM9DS1_drivers.c **** 	//	Yen_XL - Y-axis output enabled
 488:../LSM9DS1_drivers.c **** 	//	Xen_XL - X-axis output enabled
 489:../LSM9DS1_drivers.c **** 	if (settings.accel.enableZ) tempRegValue |= (1<<5);
 1810              		.loc 1 489 0
 1811 000c 40F20003 		movw	r3, #:lower16:settings
 1812 0010 C0F20003 		movt	r3, #:upper16:settings
 1813 0014 DB7E     		ldrb	r3, [r3, #27]	@ zero_extendqisi2
 1814 0016 002B     		cmp	r3, #0
 1815 0018 03D0     		beq	.L79
 1816              		.loc 1 489 0 is_stmt 0 discriminator 1
 1817 001a FB79     		ldrb	r3, [r7, #7]
 1818 001c 43F02003 		orr	r3, r3, #32
 1819 0020 FB71     		strb	r3, [r7, #7]
 1820              	.L79:
 490:../LSM9DS1_drivers.c **** 	if (settings.accel.enableY) tempRegValue |= (1<<4);
 1821              		.loc 1 490 0 is_stmt 1
 1822 0022 40F20003 		movw	r3, #:lower16:settings
 1823 0026 C0F20003 		movt	r3, #:upper16:settings
 1824 002a 9B7E     		ldrb	r3, [r3, #26]	@ zero_extendqisi2
 1825 002c 002B     		cmp	r3, #0
 1826 002e 03D0     		beq	.L80
 1827              		.loc 1 490 0 is_stmt 0 discriminator 1
 1828 0030 FB79     		ldrb	r3, [r7, #7]
 1829 0032 43F01003 		orr	r3, r3, #16
 1830 0036 FB71     		strb	r3, [r7, #7]
 1831              	.L80:
 491:../LSM9DS1_drivers.c **** 	if (settings.accel.enableX) tempRegValue |= (1<<3);
 1832              		.loc 1 491 0 is_stmt 1
 1833 0038 40F20003 		movw	r3, #:lower16:settings
 1834 003c C0F20003 		movt	r3, #:upper16:settings
 1835 0040 5B7E     		ldrb	r3, [r3, #25]	@ zero_extendqisi2
 1836 0042 002B     		cmp	r3, #0
 1837 0044 03D0     		beq	.L81
 1838              		.loc 1 491 0 is_stmt 0 discriminator 1
 1839 0046 FB79     		ldrb	r3, [r7, #7]
 1840 0048 43F00803 		orr	r3, r3, #8
 1841 004c FB71     		strb	r3, [r7, #7]
 1842              	.L81:
 492:../LSM9DS1_drivers.c **** 
 493:../LSM9DS1_drivers.c **** 	xgWriteByte(CTRL_REG5_XL, tempRegValue);
 1843              		.loc 1 493 0 is_stmt 1
 1844 004e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1845 0050 4FF01F00 		mov	r0, #31
 1846 0054 1946     		mov	r1, r3
 1847 0056 FFF7FEFF 		bl	xgWriteByte
 494:../LSM9DS1_drivers.c **** 
 495:../LSM9DS1_drivers.c **** 	// CTRL_REG6_XL (0x20) (Default value: 0x00)
 496:../LSM9DS1_drivers.c **** 	// [ODR_XL2][ODR_XL1][ODR_XL0][FS1_XL][FS0_XL][BW_SCAL_ODR][BW_XL1][BW_XL0]
 497:../LSM9DS1_drivers.c **** 	// ODR_XL[2:0] - Output data rate & power mode selection
 498:../LSM9DS1_drivers.c **** 	// FS_XL[1:0] - Full-scale selection
 499:../LSM9DS1_drivers.c **** 	// BW_SCAL_ODR - Bandwidth selection
 500:../LSM9DS1_drivers.c **** 	// BW_XL[1:0] - Anti-aliasing filter bandwidth selection
 501:../LSM9DS1_drivers.c **** 	tempRegValue = 0;
 1848              		.loc 1 501 0
 1849 005a 4FF00003 		mov	r3, #0
 1850 005e FB71     		strb	r3, [r7, #7]
 502:../LSM9DS1_drivers.c **** 	// To disable the accel, set the sampleRate bits to 0.
 503:../LSM9DS1_drivers.c **** 	if (settings.accel.enabled)
 1851              		.loc 1 503 0
 1852 0060 40F20003 		movw	r3, #:lower16:settings
 1853 0064 C0F20003 		movt	r3, #:upper16:settings
 1854 0068 9B7D     		ldrb	r3, [r3, #22]	@ zero_extendqisi2
 1855 006a 002B     		cmp	r3, #0
 1856 006c 0BD0     		beq	.L82
 504:../LSM9DS1_drivers.c **** 	{
 505:../LSM9DS1_drivers.c **** 		tempRegValue |= ((settings.accel.sampleRate & 0x07) << 5);
 1857              		.loc 1 505 0
 1858 006e 40F20003 		movw	r3, #:lower16:settings
 1859 0072 C0F20003 		movt	r3, #:upper16:settings
 1860 0076 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 1861 0078 4FEA4313 		lsl	r3, r3, #5
 1862 007c DAB2     		uxtb	r2, r3
 1863 007e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1864 0080 1343     		orrs	r3, r3, r2
 1865 0082 DBB2     		uxtb	r3, r3
 1866 0084 FB71     		strb	r3, [r7, #7]
 1867              	.L82:
 506:../LSM9DS1_drivers.c **** 	}
 507:../LSM9DS1_drivers.c **** 	switch (settings.accel.scale)
 1868              		.loc 1 507 0
 1869 0086 40F20003 		movw	r3, #:lower16:settings
 1870 008a C0F20003 		movt	r3, #:upper16:settings
 1871 008e DB7D     		ldrb	r3, [r3, #23]	@ zero_extendqisi2
 1872 0090 082B     		cmp	r3, #8
 1873 0092 08D0     		beq	.L85
 1874 0094 102B     		cmp	r3, #16
 1875 0096 0BD0     		beq	.L86
 1876 0098 042B     		cmp	r3, #4
 1877 009a 0ED1     		bne	.L83
 1878              	.L84:
 508:../LSM9DS1_drivers.c **** 	{
 509:../LSM9DS1_drivers.c **** 		case 4:
 510:../LSM9DS1_drivers.c **** 			tempRegValue |= (0x2 << 3);
 1879              		.loc 1 510 0
 1880 009c FB79     		ldrb	r3, [r7, #7]
 1881 009e 43F01003 		orr	r3, r3, #16
 1882 00a2 FB71     		strb	r3, [r7, #7]
 511:../LSM9DS1_drivers.c **** 			break;
 1883              		.loc 1 511 0
 1884 00a4 09E0     		b	.L83
 1885              	.L85:
 512:../LSM9DS1_drivers.c **** 		case 8:
 513:../LSM9DS1_drivers.c **** 			tempRegValue |= (0x3 << 3);
 1886              		.loc 1 513 0
 1887 00a6 FB79     		ldrb	r3, [r7, #7]
 1888 00a8 43F01803 		orr	r3, r3, #24
 1889 00ac FB71     		strb	r3, [r7, #7]
 514:../LSM9DS1_drivers.c **** 			break;
 1890              		.loc 1 514 0
 1891 00ae 04E0     		b	.L83
 1892              	.L86:
 515:../LSM9DS1_drivers.c **** 		case 16:
 516:../LSM9DS1_drivers.c **** 			tempRegValue |= (0x1 << 3);
 1893              		.loc 1 516 0
 1894 00b0 FB79     		ldrb	r3, [r7, #7]
 1895 00b2 43F00803 		orr	r3, r3, #8
 1896 00b6 FB71     		strb	r3, [r7, #7]
 517:../LSM9DS1_drivers.c **** 			break;
 1897              		.loc 1 517 0
 1898 00b8 00BF     		nop
 1899              	.L83:
 518:../LSM9DS1_drivers.c **** 		// Otherwise it'll be set to 2g (0x0 << 3)
 519:../LSM9DS1_drivers.c **** 	}
 520:../LSM9DS1_drivers.c **** 	if (settings.accel.bandwidth >= 0)
 1900              		.loc 1 520 0
 1901 00ba 40F20003 		movw	r3, #:lower16:settings
 1902 00be C0F20003 		movt	r3, #:upper16:settings
 1903 00c2 1B7F     		ldrb	r3, [r3, #28]	@ zero_extendqisi2
 1904 00c4 5BB2     		sxtb	r3, r3
 1905 00c6 002B     		cmp	r3, #0
 1906 00c8 0FDB     		blt	.L87
 521:../LSM9DS1_drivers.c **** 	{
 522:../LSM9DS1_drivers.c **** 		tempRegValue |= (1<<2); // Set BW_SCAL_ODR
 1907              		.loc 1 522 0
 1908 00ca FB79     		ldrb	r3, [r7, #7]
 1909 00cc 43F00403 		orr	r3, r3, #4
 1910 00d0 FB71     		strb	r3, [r7, #7]
 523:../LSM9DS1_drivers.c **** 		tempRegValue |= (settings.accel.bandwidth & 0x03);
 1911              		.loc 1 523 0
 1912 00d2 40F20003 		movw	r3, #:lower16:settings
 1913 00d6 C0F20003 		movt	r3, #:upper16:settings
 1914 00da 1B7F     		ldrb	r3, [r3, #28]	@ zero_extendqisi2
 1915 00dc 03F00303 		and	r3, r3, #3
 1916 00e0 DAB2     		uxtb	r2, r3
 1917 00e2 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1918 00e4 1343     		orrs	r3, r3, r2
 1919 00e6 DBB2     		uxtb	r3, r3
 1920 00e8 FB71     		strb	r3, [r7, #7]
 1921              	.L87:
 524:../LSM9DS1_drivers.c **** 	}
 525:../LSM9DS1_drivers.c **** 	xgWriteByte(CTRL_REG6_XL, tempRegValue);
 1922              		.loc 1 525 0
 1923 00ea FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1924 00ec 4FF02000 		mov	r0, #32
 1925 00f0 1946     		mov	r1, r3
 1926 00f2 FFF7FEFF 		bl	xgWriteByte
 526:../LSM9DS1_drivers.c **** 
 527:../LSM9DS1_drivers.c **** 	// CTRL_REG7_XL (0x21) (Default value: 0x00)
 528:../LSM9DS1_drivers.c **** 	// [HR][DCF1][DCF0][0][0][FDS][0][HPIS1]
 529:../LSM9DS1_drivers.c **** 	// HR - High resolution mode (0: disable, 1: enable)
 530:../LSM9DS1_drivers.c **** 	// DCF[1:0] - Digital filter cutoff frequency
 531:../LSM9DS1_drivers.c **** 	// FDS - Filtered data selection
 532:../LSM9DS1_drivers.c **** 	// HPIS1 - HPF enabled for interrupt function
 533:../LSM9DS1_drivers.c **** 	tempRegValue = 0;
 1927              		.loc 1 533 0
 1928 00f6 4FF00003 		mov	r3, #0
 1929 00fa FB71     		strb	r3, [r7, #7]
 534:../LSM9DS1_drivers.c **** 	if (settings.accel.highResEnable)
 1930              		.loc 1 534 0
 1931 00fc 40F20003 		movw	r3, #:lower16:settings
 1932 0100 C0F20003 		movt	r3, #:upper16:settings
 1933 0104 5B7F     		ldrb	r3, [r3, #29]	@ zero_extendqisi2
 1934 0106 002B     		cmp	r3, #0
 1935 0108 11D0     		beq	.L88
 535:../LSM9DS1_drivers.c **** 	{
 536:../LSM9DS1_drivers.c **** 		tempRegValue |= (1<<7); // Set HR bit
 1936              		.loc 1 536 0
 1937 010a FB79     		ldrb	r3, [r7, #7]
 1938 010c 63F07F03 		orn	r3, r3, #127
 1939 0110 FB71     		strb	r3, [r7, #7]
 537:../LSM9DS1_drivers.c **** 		tempRegValue |= (settings.accel.highResBandwidth & 0x3) << 5;
 1940              		.loc 1 537 0
 1941 0112 40F20003 		movw	r3, #:lower16:settings
 1942 0116 C0F20003 		movt	r3, #:upper16:settings
 1943 011a 9B7F     		ldrb	r3, [r3, #30]	@ zero_extendqisi2
 1944 011c 03F00303 		and	r3, r3, #3
 1945 0120 4FEA4313 		lsl	r3, r3, #5
 1946 0124 DAB2     		uxtb	r2, r3
 1947 0126 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1948 0128 1343     		orrs	r3, r3, r2
 1949 012a DBB2     		uxtb	r3, r3
 1950 012c FB71     		strb	r3, [r7, #7]
 1951              	.L88:
 538:../LSM9DS1_drivers.c **** 	}
 539:../LSM9DS1_drivers.c **** 	xgWriteByte(CTRL_REG7_XL, tempRegValue);
 1952              		.loc 1 539 0
 1953 012e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1954 0130 4FF02100 		mov	r0, #33
 1955 0134 1946     		mov	r1, r3
 1956 0136 FFF7FEFF 		bl	xgWriteByte
 540:../LSM9DS1_drivers.c **** }
 1957              		.loc 1 540 0
 1958 013a 07F10807 		add	r7, r7, #8
 1959 013e BD46     		mov	sp, r7
 1960 0140 80BD     		pop	{r7, pc}
 1961              		.cfi_endproc
 1962              	.LFE130:
 1964 0142 00BF     		.section	.text.initMag,"ax",%progbits
 1965              		.align	2
 1966              		.global	initMag
 1967              		.thumb
 1968              		.thumb_func
 1970              	initMag:
 1971              	.LFB131:
 541:../LSM9DS1_drivers.c **** 
 542:../LSM9DS1_drivers.c **** void initMag(void)
 543:../LSM9DS1_drivers.c **** {
 1972              		.loc 1 543 0
 1973              		.cfi_startproc
 1974              		@ args = 0, pretend = 0, frame = 8
 1975              		@ frame_needed = 1, uses_anonymous_args = 0
 1976 0000 80B5     		push	{r7, lr}
 1977              	.LCFI51:
 1978              		.cfi_def_cfa_offset 8
 1979              		.cfi_offset 7, -8
 1980              		.cfi_offset 14, -4
 1981 0002 82B0     		sub	sp, sp, #8
 1982              	.LCFI52:
 1983              		.cfi_def_cfa_offset 16
 1984 0004 00AF     		add	r7, sp, #0
 1985              	.LCFI53:
 1986              		.cfi_def_cfa_register 7
 544:../LSM9DS1_drivers.c **** 	uint8_t tempRegValue = 0;
 1987              		.loc 1 544 0
 1988 0006 4FF00003 		mov	r3, #0
 1989 000a FB71     		strb	r3, [r7, #7]
 545:../LSM9DS1_drivers.c **** 
 546:../LSM9DS1_drivers.c **** 	// CTRL_REG1_M (Default value: 0x10)
 547:../LSM9DS1_drivers.c **** 	// [TEMP_COMP][OM1][OM0][DO2][DO1][DO0][0][ST]
 548:../LSM9DS1_drivers.c **** 	// TEMP_COMP - Temperature compensation
 549:../LSM9DS1_drivers.c **** 	// OM[1:0] - X & Y axes op mode selection
 550:../LSM9DS1_drivers.c **** 	//	00:low-power, 01:medium performance
 551:../LSM9DS1_drivers.c **** 	//	10: high performance, 11:ultra-high performance
 552:../LSM9DS1_drivers.c **** 	// DO[2:0] - Output data rate selection
 553:../LSM9DS1_drivers.c **** 	// ST - Self-test enable
 554:../LSM9DS1_drivers.c **** 	if (settings.mag.tempCompensationEnable) tempRegValue |= (1<<7);
 1990              		.loc 1 554 0
 1991 000c 40F20003 		movw	r3, #:lower16:settings
 1992 0010 C0F20003 		movt	r3, #:upper16:settings
 1993 0014 93F82230 		ldrb	r3, [r3, #34]	@ zero_extendqisi2
 1994 0018 002B     		cmp	r3, #0
 1995 001a 03D0     		beq	.L90
 1996              		.loc 1 554 0 is_stmt 0 discriminator 1
 1997 001c FB79     		ldrb	r3, [r7, #7]
 1998 001e 63F07F03 		orn	r3, r3, #127
 1999 0022 FB71     		strb	r3, [r7, #7]
 2000              	.L90:
 555:../LSM9DS1_drivers.c **** 	tempRegValue |= (settings.mag.XYPerformance & 0x3) << 5;
 2001              		.loc 1 555 0 is_stmt 1
 2002 0024 40F20003 		movw	r3, #:lower16:settings
 2003 0028 C0F20003 		movt	r3, #:upper16:settings
 2004 002c 93F82330 		ldrb	r3, [r3, #35]	@ zero_extendqisi2
 2005 0030 03F00303 		and	r3, r3, #3
 2006 0034 4FEA4313 		lsl	r3, r3, #5
 2007 0038 DAB2     		uxtb	r2, r3
 2008 003a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2009 003c 1343     		orrs	r3, r3, r2
 2010 003e DBB2     		uxtb	r3, r3
 2011 0040 FB71     		strb	r3, [r7, #7]
 556:../LSM9DS1_drivers.c **** 	tempRegValue |= (settings.mag.sampleRate & 0x7) << 2;
 2012              		.loc 1 556 0
 2013 0042 40F20003 		movw	r3, #:lower16:settings
 2014 0046 C0F20003 		movt	r3, #:upper16:settings
 2015 004a 93F82130 		ldrb	r3, [r3, #33]	@ zero_extendqisi2
 2016 004e 03F00703 		and	r3, r3, #7
 2017 0052 4FEA8303 		lsl	r3, r3, #2
 2018 0056 DAB2     		uxtb	r2, r3
 2019 0058 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2020 005a 1343     		orrs	r3, r3, r2
 2021 005c DBB2     		uxtb	r3, r3
 2022 005e FB71     		strb	r3, [r7, #7]
 557:../LSM9DS1_drivers.c **** 	mWriteByte(CTRL_REG1_M, tempRegValue);
 2023              		.loc 1 557 0
 2024 0060 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2025 0062 4FF02000 		mov	r0, #32
 2026 0066 1946     		mov	r1, r3
 2027 0068 FFF7FEFF 		bl	mWriteByte
 558:../LSM9DS1_drivers.c **** 
 559:../LSM9DS1_drivers.c **** 	// CTRL_REG2_M (Default value 0x00)
 560:../LSM9DS1_drivers.c **** 	// [0][FS1][FS0][0][REBOOT][SOFT_RST][0][0]
 561:../LSM9DS1_drivers.c **** 	// FS[1:0] - Full-scale configuration
 562:../LSM9DS1_drivers.c **** 	// REBOOT - Reboot memory content (0:normal, 1:reboot)
 563:../LSM9DS1_drivers.c **** 	// SOFT_RST - Reset config and user registers (0:default, 1:reset)
 564:../LSM9DS1_drivers.c **** 	tempRegValue = 0;
 2028              		.loc 1 564 0
 2029 006c 4FF00003 		mov	r3, #0
 2030 0070 FB71     		strb	r3, [r7, #7]
 565:../LSM9DS1_drivers.c **** 	switch (settings.mag.scale)
 2031              		.loc 1 565 0
 2032 0072 40F20003 		movw	r3, #:lower16:settings
 2033 0076 C0F20003 		movt	r3, #:upper16:settings
 2034 007a 93F82030 		ldrb	r3, [r3, #32]	@ zero_extendqisi2
 2035 007e 0C2B     		cmp	r3, #12
 2036 0080 08D0     		beq	.L93
 2037 0082 102B     		cmp	r3, #16
 2038 0084 0BD0     		beq	.L94
 2039 0086 082B     		cmp	r3, #8
 2040 0088 0ED1     		bne	.L91
 2041              	.L92:
 566:../LSM9DS1_drivers.c **** 	{
 567:../LSM9DS1_drivers.c **** 	case 8:
 568:../LSM9DS1_drivers.c **** 		tempRegValue |= (0x1 << 5);
 2042              		.loc 1 568 0
 2043 008a FB79     		ldrb	r3, [r7, #7]
 2044 008c 43F02003 		orr	r3, r3, #32
 2045 0090 FB71     		strb	r3, [r7, #7]
 569:../LSM9DS1_drivers.c **** 		break;
 2046              		.loc 1 569 0
 2047 0092 09E0     		b	.L91
 2048              	.L93:
 570:../LSM9DS1_drivers.c **** 	case 12:
 571:../LSM9DS1_drivers.c **** 		tempRegValue |= (0x2 << 5);
 2049              		.loc 1 571 0
 2050 0094 FB79     		ldrb	r3, [r7, #7]
 2051 0096 43F04003 		orr	r3, r3, #64
 2052 009a FB71     		strb	r3, [r7, #7]
 572:../LSM9DS1_drivers.c **** 		break;
 2053              		.loc 1 572 0
 2054 009c 04E0     		b	.L91
 2055              	.L94:
 573:../LSM9DS1_drivers.c **** 	case 16:
 574:../LSM9DS1_drivers.c **** 		tempRegValue |= (0x3 << 5);
 2056              		.loc 1 574 0
 2057 009e FB79     		ldrb	r3, [r7, #7]
 2058 00a0 43F06003 		orr	r3, r3, #96
 2059 00a4 FB71     		strb	r3, [r7, #7]
 575:../LSM9DS1_drivers.c **** 		break;
 2060              		.loc 1 575 0
 2061 00a6 00BF     		nop
 2062              	.L91:
 576:../LSM9DS1_drivers.c **** 	// Otherwise we'll default to 4 gauss (00)
 577:../LSM9DS1_drivers.c **** 	}
 578:../LSM9DS1_drivers.c **** 	mWriteByte(CTRL_REG2_M, tempRegValue); // +/-4Gauss
 2063              		.loc 1 578 0
 2064 00a8 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2065 00aa 4FF02100 		mov	r0, #33
 2066 00ae 1946     		mov	r1, r3
 2067 00b0 FFF7FEFF 		bl	mWriteByte
 579:../LSM9DS1_drivers.c **** 
 580:../LSM9DS1_drivers.c **** 	// CTRL_REG3_M (Default value: 0x03)
 581:../LSM9DS1_drivers.c **** 	// [I2C_DISABLE][0][LP][0][0][SIM][MD1][MD0]
 582:../LSM9DS1_drivers.c **** 	// I2C_DISABLE - Disable I2C interace (0:enable, 1:disable)
 583:../LSM9DS1_drivers.c **** 	// LP - Low-power mode cofiguration (1:enable)
 584:../LSM9DS1_drivers.c **** 	// SIM - SPI mode selection (0:write-only, 1:read/write enable)
 585:../LSM9DS1_drivers.c **** 	// MD[1:0] - Operating mode
 586:../LSM9DS1_drivers.c **** 	//	00:continuous conversion, 01:single-conversion,
 587:../LSM9DS1_drivers.c **** 	//  10,11: Power-down
 588:../LSM9DS1_drivers.c **** 	tempRegValue = 0;
 2068              		.loc 1 588 0
 2069 00b4 4FF00003 		mov	r3, #0
 2070 00b8 FB71     		strb	r3, [r7, #7]
 589:../LSM9DS1_drivers.c **** 	if (settings.mag.lowPowerEnable) tempRegValue |= (1<<5);
 2071              		.loc 1 589 0
 2072 00ba 40F20003 		movw	r3, #:lower16:settings
 2073 00be C0F20003 		movt	r3, #:upper16:settings
 2074 00c2 93F82530 		ldrb	r3, [r3, #37]	@ zero_extendqisi2
 2075 00c6 002B     		cmp	r3, #0
 2076 00c8 03D0     		beq	.L95
 2077              		.loc 1 589 0 is_stmt 0 discriminator 1
 2078 00ca FB79     		ldrb	r3, [r7, #7]
 2079 00cc 43F02003 		orr	r3, r3, #32
 2080 00d0 FB71     		strb	r3, [r7, #7]
 2081              	.L95:
 590:../LSM9DS1_drivers.c **** 	tempRegValue |= (settings.mag.operatingMode & 0x3);
 2082              		.loc 1 590 0 is_stmt 1
 2083 00d2 40F20003 		movw	r3, #:lower16:settings
 2084 00d6 C0F20003 		movt	r3, #:upper16:settings
 2085 00da 93F82630 		ldrb	r3, [r3, #38]	@ zero_extendqisi2
 2086 00de DBB2     		uxtb	r3, r3
 2087 00e0 03F00303 		and	r3, r3, #3
 2088 00e4 DAB2     		uxtb	r2, r3
 2089 00e6 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2090 00e8 1343     		orrs	r3, r3, r2
 2091 00ea DBB2     		uxtb	r3, r3
 2092 00ec FB71     		strb	r3, [r7, #7]
 591:../LSM9DS1_drivers.c **** 	mWriteByte(CTRL_REG3_M, tempRegValue); // Continuous conversion mode
 2093              		.loc 1 591 0
 2094 00ee FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2095 00f0 4FF02200 		mov	r0, #34
 2096 00f4 1946     		mov	r1, r3
 2097 00f6 FFF7FEFF 		bl	mWriteByte
 592:../LSM9DS1_drivers.c **** 
 593:../LSM9DS1_drivers.c **** 	// CTRL_REG4_M (Default value: 0x00)
 594:../LSM9DS1_drivers.c **** 	// [0][0][0][0][OMZ1][OMZ0][BLE][0]
 595:../LSM9DS1_drivers.c **** 	// OMZ[1:0] - Z-axis operative mode selection
 596:../LSM9DS1_drivers.c **** 	//	00:low-power mode, 01:medium performance
 597:../LSM9DS1_drivers.c **** 	//	10:high performance, 10:ultra-high performance
 598:../LSM9DS1_drivers.c **** 	// BLE - Big/little endian data
 599:../LSM9DS1_drivers.c **** 	tempRegValue = 0;
 2098              		.loc 1 599 0
 2099 00fa 4FF00003 		mov	r3, #0
 2100 00fe FB71     		strb	r3, [r7, #7]
 600:../LSM9DS1_drivers.c **** 	tempRegValue = (settings.mag.ZPerformance & 0x3) << 2;
 2101              		.loc 1 600 0
 2102 0100 40F20003 		movw	r3, #:lower16:settings
 2103 0104 C0F20003 		movt	r3, #:upper16:settings
 2104 0108 93F82430 		ldrb	r3, [r3, #36]	@ zero_extendqisi2
 2105 010c 03F00303 		and	r3, r3, #3
 2106 0110 DBB2     		uxtb	r3, r3
 2107 0112 4FEA8303 		lsl	r3, r3, #2
 2108 0116 FB71     		strb	r3, [r7, #7]
 601:../LSM9DS1_drivers.c **** 	mWriteByte(CTRL_REG4_M, tempRegValue);
 2109              		.loc 1 601 0
 2110 0118 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2111 011a 4FF02300 		mov	r0, #35
 2112 011e 1946     		mov	r1, r3
 2113 0120 FFF7FEFF 		bl	mWriteByte
 602:../LSM9DS1_drivers.c **** 
 603:../LSM9DS1_drivers.c **** 	// CTRL_REG5_M (Default value: 0x00)
 604:../LSM9DS1_drivers.c **** 	// [0][BDU][0][0][0][0][0][0]
 605:../LSM9DS1_drivers.c **** 	// BDU - Block data update for magnetic data
 606:../LSM9DS1_drivers.c **** 	//	0:continuous, 1:not updated until MSB/LSB are read
 607:../LSM9DS1_drivers.c **** 	tempRegValue = 0;
 2114              		.loc 1 607 0
 2115 0124 4FF00003 		mov	r3, #0
 2116 0128 FB71     		strb	r3, [r7, #7]
 608:../LSM9DS1_drivers.c **** 	mWriteByte(CTRL_REG5_M, tempRegValue);
 2117              		.loc 1 608 0
 2118 012a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2119 012c 4FF02400 		mov	r0, #36
 2120 0130 1946     		mov	r1, r3
 2121 0132 FFF7FEFF 		bl	mWriteByte
 609:../LSM9DS1_drivers.c **** }
 2122              		.loc 1 609 0
 2123 0136 07F10807 		add	r7, r7, #8
 2124 013a BD46     		mov	sp, r7
 2125 013c 80BD     		pop	{r7, pc}
 2126              		.cfi_endproc
 2127              	.LFE131:
 2129 013e 00BF     		.section	.text.mWriteByte,"ax",%progbits
 2130              		.align	2
 2131              		.global	mWriteByte
 2132              		.thumb
 2133              		.thumb_func
 2135              	mWriteByte:
 2136              	.LFB132:
 610:../LSM9DS1_drivers.c **** 
 611:../LSM9DS1_drivers.c **** void mWriteByte(uint8_t subAddress, uint8_t data)
 612:../LSM9DS1_drivers.c **** {
 2137              		.loc 1 612 0
 2138              		.cfi_startproc
 2139              		@ args = 0, pretend = 0, frame = 8
 2140              		@ frame_needed = 1, uses_anonymous_args = 0
 2141 0000 80B5     		push	{r7, lr}
 2142              	.LCFI54:
 2143              		.cfi_def_cfa_offset 8
 2144              		.cfi_offset 7, -8
 2145              		.cfi_offset 14, -4
 2146 0002 82B0     		sub	sp, sp, #8
 2147              	.LCFI55:
 2148              		.cfi_def_cfa_offset 16
 2149 0004 00AF     		add	r7, sp, #0
 2150              	.LCFI56:
 2151              		.cfi_def_cfa_register 7
 2152 0006 0246     		mov	r2, r0
 2153 0008 0B46     		mov	r3, r1
 2154 000a FA71     		strb	r2, [r7, #7]
 2155 000c BB71     		strb	r3, [r7, #6]
 613:../LSM9DS1_drivers.c **** 	// Whether we're using I2C or SPI, write a byte using the
 614:../LSM9DS1_drivers.c **** 	// accelerometer-specific I2C address or SPI CS pin.
 615:../LSM9DS1_drivers.c **** 	if (settings.device.commInterface == IMU_MODE_I2C)
 2156              		.loc 1 615 0
 2157 000e 40F20003 		movw	r3, #:lower16:settings
 2158 0012 C0F20003 		movt	r3, #:upper16:settings
 2159 0016 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2160 0018 012B     		cmp	r3, #1
 2161 001a 0CD1     		bne	.L96
 616:../LSM9DS1_drivers.c **** 	{
 617:../LSM9DS1_drivers.c **** 		return I2CwriteByte(_mAddress, subAddress, data);
 2162              		.loc 1 617 0
 2163 001c 40F20003 		movw	r3, #:lower16:_mAddress
 2164 0020 C0F20003 		movt	r3, #:upper16:_mAddress
 2165 0024 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 2166 0026 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 2167 0028 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 2168 002a 0846     		mov	r0, r1
 2169 002c 1146     		mov	r1, r2
 2170 002e 1A46     		mov	r2, r3
 2171 0030 FFF7FEFF 		bl	I2CwriteByte
 2172 0034 00BF     		nop
 2173              	.L96:
 618:../LSM9DS1_drivers.c **** 	}
 619:../LSM9DS1_drivers.c **** }
 2174              		.loc 1 619 0
 2175 0036 07F10807 		add	r7, r7, #8
 2176 003a BD46     		mov	sp, r7
 2177 003c 80BD     		pop	{r7, pc}
 2178              		.cfi_endproc
 2179              	.LFE132:
 2181 003e 00BF     		.section	.text.enableFIFO,"ax",%progbits
 2182              		.align	2
 2183              		.global	enableFIFO
 2184              		.thumb
 2185              		.thumb_func
 2187              	enableFIFO:
 2188              	.LFB133:
 620:../LSM9DS1_drivers.c **** 
 621:../LSM9DS1_drivers.c **** void enableFIFO(bool enable)
 622:../LSM9DS1_drivers.c **** {
 2189              		.loc 1 622 0
 2190              		.cfi_startproc
 2191              		@ args = 0, pretend = 0, frame = 16
 2192              		@ frame_needed = 1, uses_anonymous_args = 0
 2193 0000 80B5     		push	{r7, lr}
 2194              	.LCFI57:
 2195              		.cfi_def_cfa_offset 8
 2196              		.cfi_offset 7, -8
 2197              		.cfi_offset 14, -4
 2198 0002 84B0     		sub	sp, sp, #16
 2199              	.LCFI58:
 2200              		.cfi_def_cfa_offset 24
 2201 0004 00AF     		add	r7, sp, #0
 2202              	.LCFI59:
 2203              		.cfi_def_cfa_register 7
 2204 0006 0346     		mov	r3, r0
 2205 0008 FB71     		strb	r3, [r7, #7]
 623:../LSM9DS1_drivers.c **** 	uint8_t temp = xgReadByte(CTRL_REG9);
 2206              		.loc 1 623 0
 2207 000a 4FF02300 		mov	r0, #35
 2208 000e FFF7FEFF 		bl	xgReadByte
 2209 0012 0346     		mov	r3, r0
 2210 0014 FB73     		strb	r3, [r7, #15]
 624:../LSM9DS1_drivers.c **** 	if(enable)
 2211              		.loc 1 624 0
 2212 0016 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2213 0018 002B     		cmp	r3, #0
 2214 001a 04D0     		beq	.L99
 625:../LSM9DS1_drivers.c **** 	{
 626:../LSM9DS1_drivers.c **** 		temp |= (1<<1);
 2215              		.loc 1 626 0
 2216 001c FB7B     		ldrb	r3, [r7, #15]
 2217 001e 43F00203 		orr	r3, r3, #2
 2218 0022 FB73     		strb	r3, [r7, #15]
 2219 0024 03E0     		b	.L100
 2220              	.L99:
 627:../LSM9DS1_drivers.c **** 	}
 628:../LSM9DS1_drivers.c **** 	else
 629:../LSM9DS1_drivers.c **** 	{
 630:../LSM9DS1_drivers.c **** 		temp &= ~(1<<1);
 2221              		.loc 1 630 0
 2222 0026 FB7B     		ldrb	r3, [r7, #15]
 2223 0028 23F00203 		bic	r3, r3, #2
 2224 002c FB73     		strb	r3, [r7, #15]
 2225              	.L100:
 631:../LSM9DS1_drivers.c **** 	}
 632:../LSM9DS1_drivers.c **** 
 633:../LSM9DS1_drivers.c **** 	xgWriteByte(CTRL_REG9, temp);
 2226              		.loc 1 633 0
 2227 002e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 2228 0030 4FF02300 		mov	r0, #35
 2229 0034 1946     		mov	r1, r3
 2230 0036 FFF7FEFF 		bl	xgWriteByte
 634:../LSM9DS1_drivers.c **** }
 2231              		.loc 1 634 0
 2232 003a 07F11007 		add	r7, r7, #16
 2233 003e BD46     		mov	sp, r7
 2234 0040 80BD     		pop	{r7, pc}
 2235              		.cfi_endproc
 2236              	.LFE133:
 2238 0042 00BF     		.section	.text.setFIFO,"ax",%progbits
 2239              		.align	2
 2240              		.global	setFIFO
 2241              		.thumb
 2242              		.thumb_func
 2244              	setFIFO:
 2245              	.LFB134:
 635:../LSM9DS1_drivers.c **** 
 636:../LSM9DS1_drivers.c **** void setFIFO(fifoMode_type fifoMode, uint8_t fifoThs)
 637:../LSM9DS1_drivers.c **** {
 2246              		.loc 1 637 0
 2247              		.cfi_startproc
 2248              		@ args = 0, pretend = 0, frame = 16
 2249              		@ frame_needed = 1, uses_anonymous_args = 0
 2250 0000 80B5     		push	{r7, lr}
 2251              	.LCFI60:
 2252              		.cfi_def_cfa_offset 8
 2253              		.cfi_offset 7, -8
 2254              		.cfi_offset 14, -4
 2255 0002 84B0     		sub	sp, sp, #16
 2256              	.LCFI61:
 2257              		.cfi_def_cfa_offset 24
 2258 0004 00AF     		add	r7, sp, #0
 2259              	.LCFI62:
 2260              		.cfi_def_cfa_register 7
 2261 0006 0246     		mov	r2, r0
 2262 0008 0B46     		mov	r3, r1
 2263 000a FA71     		strb	r2, [r7, #7]
 2264 000c BB71     		strb	r3, [r7, #6]
 638:../LSM9DS1_drivers.c **** 	// Limit threshold - 0x1F (31) is the maximum. If more than that was asked
 639:../LSM9DS1_drivers.c **** 	// limit it to the maximum.
 640:../LSM9DS1_drivers.c **** 	uint8_t threshold = fifoThs <= 0x1F ? fifoThs : 0x1F;
 2265              		.loc 1 640 0
 2266 000e BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 2267 0010 1F2B     		cmp	r3, #31
 2268 0012 28BF     		it	cs
 2269 0014 1F23     		movcs	r3, #31
 2270 0016 FB73     		strb	r3, [r7, #15]
 641:../LSM9DS1_drivers.c **** 	xgWriteByte(FIFO_CTRL, ((fifoMode & 0x7) << 5) | (threshold & 0x1F));
 2271              		.loc 1 641 0
 2272 0018 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2273 001a 4FEA4313 		lsl	r3, r3, #5
 2274 001e DAB2     		uxtb	r2, r3
 2275 0020 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 2276 0022 03F01F03 		and	r3, r3, #31
 2277 0026 DBB2     		uxtb	r3, r3
 2278 0028 1343     		orrs	r3, r3, r2
 2279 002a DBB2     		uxtb	r3, r3
 2280 002c DBB2     		uxtb	r3, r3
 2281 002e 4FF02E00 		mov	r0, #46
 2282 0032 1946     		mov	r1, r3
 2283 0034 FFF7FEFF 		bl	xgWriteByte
 642:../LSM9DS1_drivers.c **** }
 2284              		.loc 1 642 0
 2285 0038 07F11007 		add	r7, r7, #16
 2286 003c BD46     		mov	sp, r7
 2287 003e 80BD     		pop	{r7, pc}
 2288              		.cfi_endproc
 2289              	.LFE134:
 2291              		.section	.text.readGyro1,"ax",%progbits
 2292              		.align	2
 2293              		.global	readGyro1
 2294              		.thumb
 2295              		.thumb_func
 2297              	readGyro1:
 2298              	.LFB135:
 643:../LSM9DS1_drivers.c **** 
 644:../LSM9DS1_drivers.c **** void readGyro1(void)
 645:../LSM9DS1_drivers.c **** {
 2299              		.loc 1 645 0
 2300              		.cfi_startproc
 2301              		@ args = 0, pretend = 0, frame = 16
 2302              		@ frame_needed = 1, uses_anonymous_args = 0
 2303 0000 80B5     		push	{r7, lr}
 2304              	.LCFI63:
 2305              		.cfi_def_cfa_offset 8
 2306              		.cfi_offset 7, -8
 2307              		.cfi_offset 14, -4
 2308 0002 84B0     		sub	sp, sp, #16
 2309              	.LCFI64:
 2310              		.cfi_def_cfa_offset 24
 2311 0004 00AF     		add	r7, sp, #0
 2312              	.LCFI65:
 2313              		.cfi_def_cfa_register 7
 646:../LSM9DS1_drivers.c **** 	/*for(int g = 0; g < 3; g++){*/
 647:../LSM9DS1_drivers.c **** 	uint8_t temp[6]; // We'll read six bytes from the gyro into temp
 648:../LSM9DS1_drivers.c **** 	xgReadBytes(OUT_X_L_G, temp, 6); // Read 6 bytes, beginning at OUT_X_L_G
 2314              		.loc 1 648 0
 2315 0006 07F10403 		add	r3, r7, #4
 2316 000a 4FF01800 		mov	r0, #24
 2317 000e 1946     		mov	r1, r3
 2318 0010 4FF00602 		mov	r2, #6
 2319 0014 FFF7FEFF 		bl	xgReadBytes
 649:../LSM9DS1_drivers.c **** 	gx = ((int8_t)temp[1] << 8) | (int8_t)temp[0]; // Store x-axis values into gx
 2320              		.loc 1 649 0
 2321 0018 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 2322 001a DBB2     		uxtb	r3, r3
 2323 001c 5BB2     		sxtb	r3, r3
 2324 001e 4FEA0323 		lsl	r3, r3, #8
 2325 0022 9AB2     		uxth	r2, r3
 2326 0024 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 2327 0026 DBB2     		uxtb	r3, r3
 2328 0028 5BB2     		sxtb	r3, r3
 2329 002a 9BB2     		uxth	r3, r3
 2330 002c 1343     		orrs	r3, r3, r2
 2331 002e 9AB2     		uxth	r2, r3
 2332 0030 40F20003 		movw	r3, #:lower16:gx
 2333 0034 C0F20003 		movt	r3, #:upper16:gx
 2334 0038 1A80     		strh	r2, [r3, #0]	@ movhi
 650:../LSM9DS1_drivers.c **** 
 651:../LSM9DS1_drivers.c **** 	//gx = ((int8_t)temp[0] << 8) | (int8_t)temp[1]; // Store x-axis values into gx
 652:../LSM9DS1_drivers.c **** 
 653:../LSM9DS1_drivers.c **** 
 654:../LSM9DS1_drivers.c **** 	gy = (temp[3] << 8) | temp[2]; // Store y-axis values into gy
 2335              		.loc 1 654 0
 2336 003a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2337 003c 4FEA0323 		lsl	r3, r3, #8
 2338 0040 9AB2     		uxth	r2, r3
 2339 0042 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 2340 0044 1343     		orrs	r3, r3, r2
 2341 0046 9AB2     		uxth	r2, r3
 2342 0048 40F20003 		movw	r3, #:lower16:gy
 2343 004c C0F20003 		movt	r3, #:upper16:gy
 2344 0050 1A80     		strh	r2, [r3, #0]	@ movhi
 655:../LSM9DS1_drivers.c **** 
 656:../LSM9DS1_drivers.c **** 	//gy = (temp[2] << 8) | temp[3];
 657:../LSM9DS1_drivers.c **** 
 658:../LSM9DS1_drivers.c **** 	gz = (temp[5] << 8) | temp[4]; // Store z-axis values into gz
 2345              		.loc 1 658 0
 2346 0052 7B7A     		ldrb	r3, [r7, #9]	@ zero_extendqisi2
 2347 0054 4FEA0323 		lsl	r3, r3, #8
 2348 0058 9AB2     		uxth	r2, r3
 2349 005a 3B7A     		ldrb	r3, [r7, #8]	@ zero_extendqisi2
 2350 005c 1343     		orrs	r3, r3, r2
 2351 005e 9AB2     		uxth	r2, r3
 2352 0060 40F20003 		movw	r3, #:lower16:gz
 2353 0064 C0F20003 		movt	r3, #:upper16:gz
 2354 0068 1A80     		strh	r2, [r3, #0]	@ movhi
 659:../LSM9DS1_drivers.c **** 
 660:../LSM9DS1_drivers.c **** 	//gz = (temp[4] << 8) | temp[5];
 661:../LSM9DS1_drivers.c **** 
 662:../LSM9DS1_drivers.c **** 	/*if(g == 2)
 663:../LSM9DS1_drivers.c **** 	{
 664:../LSM9DS1_drivers.c **** 
 665:../LSM9DS1_drivers.c **** 		int flu = 0;
 666:../LSM9DS1_drivers.c **** 	}*/
 667:../LSM9DS1_drivers.c **** 
 668:../LSM9DS1_drivers.c **** 	if (_autoCalc)
 2355              		.loc 1 668 0
 2356 006a 40F20003 		movw	r3, #:lower16:_autoCalc
 2357 006e C0F20003 		movt	r3, #:upper16:_autoCalc
 2358 0072 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2359 0074 002B     		cmp	r3, #0
 2360 0076 3BD0     		beq	.L103
 669:../LSM9DS1_drivers.c **** 	{
 670:../LSM9DS1_drivers.c **** 		gx -= gBiasRaw[X_AXIS];
 2361              		.loc 1 670 0
 2362 0078 40F20003 		movw	r3, #:lower16:gx
 2363 007c C0F20003 		movt	r3, #:upper16:gx
 2364 0080 1B88     		ldrh	r3, [r3, #0]
 2365 0082 9AB2     		uxth	r2, r3
 2366 0084 40F20003 		movw	r3, #:lower16:gBiasRaw
 2367 0088 C0F20003 		movt	r3, #:upper16:gBiasRaw
 2368 008c 1B88     		ldrh	r3, [r3, #0]
 2369 008e 9BB2     		uxth	r3, r3
 2370 0090 D31A     		subs	r3, r2, r3
 2371 0092 9BB2     		uxth	r3, r3
 2372 0094 9AB2     		uxth	r2, r3
 2373 0096 40F20003 		movw	r3, #:lower16:gx
 2374 009a C0F20003 		movt	r3, #:upper16:gx
 2375 009e 1A80     		strh	r2, [r3, #0]	@ movhi
 671:../LSM9DS1_drivers.c **** 		gy -= gBiasRaw[Y_AXIS];
 2376              		.loc 1 671 0
 2377 00a0 40F20003 		movw	r3, #:lower16:gy
 2378 00a4 C0F20003 		movt	r3, #:upper16:gy
 2379 00a8 1B88     		ldrh	r3, [r3, #0]
 2380 00aa 9AB2     		uxth	r2, r3
 2381 00ac 40F20003 		movw	r3, #:lower16:gBiasRaw
 2382 00b0 C0F20003 		movt	r3, #:upper16:gBiasRaw
 2383 00b4 5B88     		ldrh	r3, [r3, #2]
 2384 00b6 9BB2     		uxth	r3, r3
 2385 00b8 D31A     		subs	r3, r2, r3
 2386 00ba 9BB2     		uxth	r3, r3
 2387 00bc 9AB2     		uxth	r2, r3
 2388 00be 40F20003 		movw	r3, #:lower16:gy
 2389 00c2 C0F20003 		movt	r3, #:upper16:gy
 2390 00c6 1A80     		strh	r2, [r3, #0]	@ movhi
 672:../LSM9DS1_drivers.c **** 		gz -= gBiasRaw[Z_AXIS];
 2391              		.loc 1 672 0
 2392 00c8 40F20003 		movw	r3, #:lower16:gz
 2393 00cc C0F20003 		movt	r3, #:upper16:gz
 2394 00d0 1B88     		ldrh	r3, [r3, #0]
 2395 00d2 9AB2     		uxth	r2, r3
 2396 00d4 40F20003 		movw	r3, #:lower16:gBiasRaw
 2397 00d8 C0F20003 		movt	r3, #:upper16:gBiasRaw
 2398 00dc 9B88     		ldrh	r3, [r3, #4]
 2399 00de 9BB2     		uxth	r3, r3
 2400 00e0 D31A     		subs	r3, r2, r3
 2401 00e2 9BB2     		uxth	r3, r3
 2402 00e4 9AB2     		uxth	r2, r3
 2403 00e6 40F20003 		movw	r3, #:lower16:gz
 2404 00ea C0F20003 		movt	r3, #:upper16:gz
 2405 00ee 1A80     		strh	r2, [r3, #0]	@ movhi
 2406              	.L103:
 673:../LSM9DS1_drivers.c **** 	}
 674:../LSM9DS1_drivers.c **** 	gx = calcGyro(gx);
 2407              		.loc 1 674 0
 2408 00f0 40F20003 		movw	r3, #:lower16:gx
 2409 00f4 C0F20003 		movt	r3, #:upper16:gx
 2410 00f8 1B88     		ldrh	r3, [r3, #0]
 2411 00fa 1BB2     		sxth	r3, r3
 2412 00fc 1846     		mov	r0, r3
 2413 00fe FFF7FEFF 		bl	calcGyro
 2414 0102 07EE900A 		fmsr	s15, r0
 2415 0106 FDEEE77A 		ftosizs	s15, s15
 2416 010a 17EE903A 		fmrs	r3, s15	@ int
 2417 010e 9AB2     		uxth	r2, r3
 2418 0110 40F20003 		movw	r3, #:lower16:gx
 2419 0114 C0F20003 		movt	r3, #:upper16:gx
 2420 0118 1A80     		strh	r2, [r3, #0]	@ movhi
 675:../LSM9DS1_drivers.c **** 	gy = calcGyro(gy);
 2421              		.loc 1 675 0
 2422 011a 40F20003 		movw	r3, #:lower16:gy
 2423 011e C0F20003 		movt	r3, #:upper16:gy
 2424 0122 1B88     		ldrh	r3, [r3, #0]
 2425 0124 1BB2     		sxth	r3, r3
 2426 0126 1846     		mov	r0, r3
 2427 0128 FFF7FEFF 		bl	calcGyro
 2428 012c 07EE900A 		fmsr	s15, r0
 2429 0130 FDEEE77A 		ftosizs	s15, s15
 2430 0134 17EE903A 		fmrs	r3, s15	@ int
 2431 0138 9AB2     		uxth	r2, r3
 2432 013a 40F20003 		movw	r3, #:lower16:gy
 2433 013e C0F20003 		movt	r3, #:upper16:gy
 2434 0142 1A80     		strh	r2, [r3, #0]	@ movhi
 676:../LSM9DS1_drivers.c **** 	gz = calcGyro(gz);
 2435              		.loc 1 676 0
 2436 0144 40F20003 		movw	r3, #:lower16:gz
 2437 0148 C0F20003 		movt	r3, #:upper16:gz
 2438 014c 1B88     		ldrh	r3, [r3, #0]
 2439 014e 1BB2     		sxth	r3, r3
 2440 0150 1846     		mov	r0, r3
 2441 0152 FFF7FEFF 		bl	calcGyro
 2442 0156 07EE900A 		fmsr	s15, r0
 2443 015a FDEEE77A 		ftosizs	s15, s15
 2444 015e 17EE903A 		fmrs	r3, s15	@ int
 2445 0162 9AB2     		uxth	r2, r3
 2446 0164 40F20003 		movw	r3, #:lower16:gz
 2447 0168 C0F20003 		movt	r3, #:upper16:gz
 2448 016c 1A80     		strh	r2, [r3, #0]	@ movhi
 2449              	.LBB4:
 677:../LSM9DS1_drivers.c **** 
 678:../LSM9DS1_drivers.c **** 	/*poms.gxs[g] = gx;
 679:../LSM9DS1_drivers.c **** 	poms.gys[g] = gy;
 680:../LSM9DS1_drivers.c **** 	poms.gzs[g] = gz;*/
 681:../LSM9DS1_drivers.c **** 
 682:../LSM9DS1_drivers.c **** 	for(int k = 0; k < 6; k++)
 2450              		.loc 1 682 0
 2451 016e 4FF00003 		mov	r3, #0
 2452 0172 FB60     		str	r3, [r7, #12]
 2453 0174 0CE0     		b	.L104
 2454              	.L105:
 683:../LSM9DS1_drivers.c **** 	{
 684:../LSM9DS1_drivers.c **** 		accelerationXYZ[k] = 0;
 2455              		.loc 1 684 0 discriminator 2
 2456 0176 40F20003 		movw	r3, #:lower16:accelerationXYZ
 2457 017a C0F20003 		movt	r3, #:upper16:accelerationXYZ
 2458 017e FA68     		ldr	r2, [r7, #12]
 2459 0180 4FF00001 		mov	r1, #0
 2460 0184 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 682:../LSM9DS1_drivers.c **** 	for(int k = 0; k < 6; k++)
 2461              		.loc 1 682 0 discriminator 2
 2462 0188 FB68     		ldr	r3, [r7, #12]
 2463 018a 03F10103 		add	r3, r3, #1
 2464 018e FB60     		str	r3, [r7, #12]
 2465              	.L104:
 682:../LSM9DS1_drivers.c **** 	for(int k = 0; k < 6; k++)
 2466              		.loc 1 682 0 is_stmt 0 discriminator 1
 2467 0190 FB68     		ldr	r3, [r7, #12]
 2468 0192 052B     		cmp	r3, #5
 2469 0194 EFDD     		ble	.L105
 2470              	.LBE4:
 685:../LSM9DS1_drivers.c **** 	}
 686:../LSM9DS1_drivers.c **** 	//}
 687:../LSM9DS1_drivers.c **** }
 2471              		.loc 1 687 0 is_stmt 1
 2472 0196 07F11007 		add	r7, r7, #16
 2473 019a BD46     		mov	sp, r7
 2474 019c 80BD     		pop	{r7, pc}
 2475              		.cfi_endproc
 2476              	.LFE135:
 2478 019e 00BF     		.section	.text.readAccel1,"ax",%progbits
 2479              		.align	2
 2480              		.global	readAccel1
 2481              		.thumb
 2482              		.thumb_func
 2484              	readAccel1:
 2485              	.LFB136:
 688:../LSM9DS1_drivers.c **** 
 689:../LSM9DS1_drivers.c **** void readAccel1(void)
 690:../LSM9DS1_drivers.c **** {
 2486              		.loc 1 690 0
 2487              		.cfi_startproc
 2488              		@ args = 0, pretend = 0, frame = 16
 2489              		@ frame_needed = 1, uses_anonymous_args = 0
 2490 0000 80B5     		push	{r7, lr}
 2491              	.LCFI66:
 2492              		.cfi_def_cfa_offset 8
 2493              		.cfi_offset 7, -8
 2494              		.cfi_offset 14, -4
 2495 0002 84B0     		sub	sp, sp, #16
 2496              	.LCFI67:
 2497              		.cfi_def_cfa_offset 24
 2498 0004 00AF     		add	r7, sp, #0
 2499              	.LCFI68:
 2500              		.cfi_def_cfa_register 7
 691:../LSM9DS1_drivers.c **** 	uint8_t temp[6]; // We'll read six bytes from the accelerometer into temp
 692:../LSM9DS1_drivers.c **** 	int index = 0;
 2501              		.loc 1 692 0
 2502 0006 4FF00003 		mov	r3, #0
 2503 000a 3B60     		str	r3, [r7, #0]
 693:../LSM9DS1_drivers.c **** 
 694:../LSM9DS1_drivers.c **** 	xgReadBytes(OUT_X_L_XL, temp, 6); // Read 6 bytes, beginning at OUT_X_L_XL
 2504              		.loc 1 694 0
 2505 000c 07F10403 		add	r3, r7, #4
 2506 0010 4FF02800 		mov	r0, #40
 2507 0014 1946     		mov	r1, r3
 2508 0016 4FF00602 		mov	r2, #6
 2509 001a FFF7FEFF 		bl	xgReadBytes
 695:../LSM9DS1_drivers.c **** 
 696:../LSM9DS1_drivers.c **** 	ax = (temp[1] << 8) | temp[0]; // Store x-axis values into ax
 2510              		.loc 1 696 0
 2511 001e 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 2512 0020 4FEA0323 		lsl	r3, r3, #8
 2513 0024 9AB2     		uxth	r2, r3
 2514 0026 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 2515 0028 1343     		orrs	r3, r3, r2
 2516 002a 9AB2     		uxth	r2, r3
 2517 002c 40F20003 		movw	r3, #:lower16:ax
 2518 0030 C0F20003 		movt	r3, #:upper16:ax
 2519 0034 1A80     		strh	r2, [r3, #0]	@ movhi
 697:../LSM9DS1_drivers.c **** 	ay = (temp[3] << 8) | temp[2]; // Store y-axis values into ay
 2520              		.loc 1 697 0
 2521 0036 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2522 0038 4FEA0323 		lsl	r3, r3, #8
 2523 003c 9AB2     		uxth	r2, r3
 2524 003e BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 2525 0040 1343     		orrs	r3, r3, r2
 2526 0042 9AB2     		uxth	r2, r3
 2527 0044 40F20003 		movw	r3, #:lower16:ay
 2528 0048 C0F20003 		movt	r3, #:upper16:ay
 2529 004c 1A80     		strh	r2, [r3, #0]	@ movhi
 698:../LSM9DS1_drivers.c **** 	az = (temp[5] << 8) | temp[4]; // Store z-axis values into az
 2530              		.loc 1 698 0
 2531 004e 7B7A     		ldrb	r3, [r7, #9]	@ zero_extendqisi2
 2532 0050 4FEA0323 		lsl	r3, r3, #8
 2533 0054 9AB2     		uxth	r2, r3
 2534 0056 3B7A     		ldrb	r3, [r7, #8]	@ zero_extendqisi2
 2535 0058 1343     		orrs	r3, r3, r2
 2536 005a 9AB2     		uxth	r2, r3
 2537 005c 40F20003 		movw	r3, #:lower16:az
 2538 0060 C0F20003 		movt	r3, #:upper16:az
 2539 0064 1A80     		strh	r2, [r3, #0]	@ movhi
 699:../LSM9DS1_drivers.c **** 
 700:../LSM9DS1_drivers.c **** 	if (_autoCalc)
 2540              		.loc 1 700 0
 2541 0066 40F20003 		movw	r3, #:lower16:_autoCalc
 2542 006a C0F20003 		movt	r3, #:upper16:_autoCalc
 2543 006e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2544 0070 002B     		cmp	r3, #0
 2545 0072 3BD0     		beq	.L107
 701:../LSM9DS1_drivers.c **** 	{
 702:../LSM9DS1_drivers.c **** 		ax -= aBiasRaw[X_AXIS];
 2546              		.loc 1 702 0
 2547 0074 40F20003 		movw	r3, #:lower16:ax
 2548 0078 C0F20003 		movt	r3, #:upper16:ax
 2549 007c 1B88     		ldrh	r3, [r3, #0]
 2550 007e 9AB2     		uxth	r2, r3
 2551 0080 40F20003 		movw	r3, #:lower16:aBiasRaw
 2552 0084 C0F20003 		movt	r3, #:upper16:aBiasRaw
 2553 0088 1B88     		ldrh	r3, [r3, #0]
 2554 008a 9BB2     		uxth	r3, r3
 2555 008c D31A     		subs	r3, r2, r3
 2556 008e 9BB2     		uxth	r3, r3
 2557 0090 9AB2     		uxth	r2, r3
 2558 0092 40F20003 		movw	r3, #:lower16:ax
 2559 0096 C0F20003 		movt	r3, #:upper16:ax
 2560 009a 1A80     		strh	r2, [r3, #0]	@ movhi
 703:../LSM9DS1_drivers.c **** 		ay -= aBiasRaw[Y_AXIS];
 2561              		.loc 1 703 0
 2562 009c 40F20003 		movw	r3, #:lower16:ay
 2563 00a0 C0F20003 		movt	r3, #:upper16:ay
 2564 00a4 1B88     		ldrh	r3, [r3, #0]
 2565 00a6 9AB2     		uxth	r2, r3
 2566 00a8 40F20003 		movw	r3, #:lower16:aBiasRaw
 2567 00ac C0F20003 		movt	r3, #:upper16:aBiasRaw
 2568 00b0 5B88     		ldrh	r3, [r3, #2]
 2569 00b2 9BB2     		uxth	r3, r3
 2570 00b4 D31A     		subs	r3, r2, r3
 2571 00b6 9BB2     		uxth	r3, r3
 2572 00b8 9AB2     		uxth	r2, r3
 2573 00ba 40F20003 		movw	r3, #:lower16:ay
 2574 00be C0F20003 		movt	r3, #:upper16:ay
 2575 00c2 1A80     		strh	r2, [r3, #0]	@ movhi
 704:../LSM9DS1_drivers.c **** 		az -= aBiasRaw[Z_AXIS];
 2576              		.loc 1 704 0
 2577 00c4 40F20003 		movw	r3, #:lower16:az
 2578 00c8 C0F20003 		movt	r3, #:upper16:az
 2579 00cc 1B88     		ldrh	r3, [r3, #0]
 2580 00ce 9AB2     		uxth	r2, r3
 2581 00d0 40F20003 		movw	r3, #:lower16:aBiasRaw
 2582 00d4 C0F20003 		movt	r3, #:upper16:aBiasRaw
 2583 00d8 9B88     		ldrh	r3, [r3, #4]
 2584 00da 9BB2     		uxth	r3, r3
 2585 00dc D31A     		subs	r3, r2, r3
 2586 00de 9BB2     		uxth	r3, r3
 2587 00e0 9AB2     		uxth	r2, r3
 2588 00e2 40F20003 		movw	r3, #:lower16:az
 2589 00e6 C0F20003 		movt	r3, #:upper16:az
 2590 00ea 1A80     		strh	r2, [r3, #0]	@ movhi
 2591              	.L107:
 705:../LSM9DS1_drivers.c **** 	}
 706:../LSM9DS1_drivers.c **** 
 707:../LSM9DS1_drivers.c **** 	ax = calcAccel(ax);
 2592              		.loc 1 707 0
 2593 00ec 40F20003 		movw	r3, #:lower16:ax
 2594 00f0 C0F20003 		movt	r3, #:upper16:ax
 2595 00f4 1B88     		ldrh	r3, [r3, #0]
 2596 00f6 1BB2     		sxth	r3, r3
 2597 00f8 1846     		mov	r0, r3
 2598 00fa FFF7FEFF 		bl	calcAccel
 2599 00fe 07EE900A 		fmsr	s15, r0
 2600 0102 FDEEE77A 		ftosizs	s15, s15
 2601 0106 17EE903A 		fmrs	r3, s15	@ int
 2602 010a 9AB2     		uxth	r2, r3
 2603 010c 40F20003 		movw	r3, #:lower16:ax
 2604 0110 C0F20003 		movt	r3, #:upper16:ax
 2605 0114 1A80     		strh	r2, [r3, #0]	@ movhi
 708:../LSM9DS1_drivers.c **** 	ay = calcAccel(ay);
 2606              		.loc 1 708 0
 2607 0116 40F20003 		movw	r3, #:lower16:ay
 2608 011a C0F20003 		movt	r3, #:upper16:ay
 2609 011e 1B88     		ldrh	r3, [r3, #0]
 2610 0120 1BB2     		sxth	r3, r3
 2611 0122 1846     		mov	r0, r3
 2612 0124 FFF7FEFF 		bl	calcAccel
 2613 0128 07EE900A 		fmsr	s15, r0
 2614 012c FDEEE77A 		ftosizs	s15, s15
 2615 0130 17EE903A 		fmrs	r3, s15	@ int
 2616 0134 9AB2     		uxth	r2, r3
 2617 0136 40F20003 		movw	r3, #:lower16:ay
 2618 013a C0F20003 		movt	r3, #:upper16:ay
 2619 013e 1A80     		strh	r2, [r3, #0]	@ movhi
 709:../LSM9DS1_drivers.c **** 	az = calcAccel(az);
 2620              		.loc 1 709 0
 2621 0140 40F20003 		movw	r3, #:lower16:az
 2622 0144 C0F20003 		movt	r3, #:upper16:az
 2623 0148 1B88     		ldrh	r3, [r3, #0]
 2624 014a 1BB2     		sxth	r3, r3
 2625 014c 1846     		mov	r0, r3
 2626 014e FFF7FEFF 		bl	calcAccel
 2627 0152 07EE900A 		fmsr	s15, r0
 2628 0156 FDEEE77A 		ftosizs	s15, s15
 2629 015a 17EE903A 		fmrs	r3, s15	@ int
 2630 015e 9AB2     		uxth	r2, r3
 2631 0160 40F20003 		movw	r3, #:lower16:az
 2632 0164 C0F20003 		movt	r3, #:upper16:az
 2633 0168 1A80     		strh	r2, [r3, #0]	@ movhi
 710:../LSM9DS1_drivers.c **** 
 711:../LSM9DS1_drivers.c **** 	toAscii(ax, &index);
 2634              		.loc 1 711 0
 2635 016a 40F20003 		movw	r3, #:lower16:ax
 2636 016e C0F20003 		movt	r3, #:upper16:ax
 2637 0172 1B88     		ldrh	r3, [r3, #0]
 2638 0174 1AB2     		sxth	r2, r3
 2639 0176 3B46     		mov	r3, r7
 2640 0178 1046     		mov	r0, r2
 2641 017a 1946     		mov	r1, r3
 2642 017c FFF7FEFF 		bl	toAscii
 712:../LSM9DS1_drivers.c **** 	toAscii(ay, &index);
 2643              		.loc 1 712 0
 2644 0180 40F20003 		movw	r3, #:lower16:ay
 2645 0184 C0F20003 		movt	r3, #:upper16:ay
 2646 0188 1B88     		ldrh	r3, [r3, #0]
 2647 018a 1AB2     		sxth	r2, r3
 2648 018c 3B46     		mov	r3, r7
 2649 018e 1046     		mov	r0, r2
 2650 0190 1946     		mov	r1, r3
 2651 0192 FFF7FEFF 		bl	toAscii
 713:../LSM9DS1_drivers.c **** 	toAscii(az, &index);
 2652              		.loc 1 713 0
 2653 0196 40F20003 		movw	r3, #:lower16:az
 2654 019a C0F20003 		movt	r3, #:upper16:az
 2655 019e 1B88     		ldrh	r3, [r3, #0]
 2656 01a0 1AB2     		sxth	r2, r3
 2657 01a2 3B46     		mov	r3, r7
 2658 01a4 1046     		mov	r0, r2
 2659 01a6 1946     		mov	r1, r3
 2660 01a8 FFF7FEFF 		bl	toAscii
 2661              	.LBB5:
 714:../LSM9DS1_drivers.c **** 
 715:../LSM9DS1_drivers.c **** 	/*lk[0] = '0' + ax;
 716:../LSM9DS1_drivers.c **** 	lk[1] = '0' + ay;
 717:../LSM9DS1_drivers.c **** 	lk[2] = '0' + az;*/
 718:../LSM9DS1_drivers.c **** 	for(int k = 0; k < 6; k++)
 2662              		.loc 1 718 0
 2663 01ac 4FF00003 		mov	r3, #0
 2664 01b0 FB60     		str	r3, [r7, #12]
 2665 01b2 0CE0     		b	.L108
 2666              	.L109:
 719:../LSM9DS1_drivers.c **** 	{
 720:../LSM9DS1_drivers.c **** 		accelerationXYZ[k] = 0;
 2667              		.loc 1 720 0 discriminator 2
 2668 01b4 40F20003 		movw	r3, #:lower16:accelerationXYZ
 2669 01b8 C0F20003 		movt	r3, #:upper16:accelerationXYZ
 2670 01bc FA68     		ldr	r2, [r7, #12]
 2671 01be 4FF00001 		mov	r1, #0
 2672 01c2 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 718:../LSM9DS1_drivers.c **** 	for(int k = 0; k < 6; k++)
 2673              		.loc 1 718 0 discriminator 2
 2674 01c6 FB68     		ldr	r3, [r7, #12]
 2675 01c8 03F10103 		add	r3, r3, #1
 2676 01cc FB60     		str	r3, [r7, #12]
 2677              	.L108:
 718:../LSM9DS1_drivers.c **** 	for(int k = 0; k < 6; k++)
 2678              		.loc 1 718 0 is_stmt 0 discriminator 1
 2679 01ce FB68     		ldr	r3, [r7, #12]
 2680 01d0 052B     		cmp	r3, #5
 2681 01d2 EFDD     		ble	.L109
 2682              	.LBE5:
 721:../LSM9DS1_drivers.c **** 	}
 722:../LSM9DS1_drivers.c **** 
 723:../LSM9DS1_drivers.c **** }
 2683              		.loc 1 723 0 is_stmt 1
 2684 01d4 07F11007 		add	r7, r7, #16
 2685 01d8 BD46     		mov	sp, r7
 2686 01da 80BD     		pop	{r7, pc}
 2687              		.cfi_endproc
 2688              	.LFE136:
 2690              		.section	.text.toAscii,"ax",%progbits
 2691              		.align	2
 2692              		.global	toAscii
 2693              		.thumb
 2694              		.thumb_func
 2696              	toAscii:
 2697              	.LFB137:
 724:../LSM9DS1_drivers.c **** 
 725:../LSM9DS1_drivers.c **** void toAscii(int16_t accel, int *index)
 726:../LSM9DS1_drivers.c **** {
 2698              		.loc 1 726 0
 2699              		.cfi_startproc
 2700              		@ args = 0, pretend = 0, frame = 16
 2701              		@ frame_needed = 1, uses_anonymous_args = 0
 2702              		@ link register save eliminated.
 2703 0000 80B4     		push	{r7}
 2704              	.LCFI69:
 2705              		.cfi_def_cfa_offset 4
 2706              		.cfi_offset 7, -4
 2707 0002 85B0     		sub	sp, sp, #20
 2708              	.LCFI70:
 2709              		.cfi_def_cfa_offset 24
 2710 0004 00AF     		add	r7, sp, #0
 2711              	.LCFI71:
 2712              		.cfi_def_cfa_register 7
 2713 0006 0346     		mov	r3, r0
 2714 0008 3960     		str	r1, [r7, #0]
 2715 000a FB80     		strh	r3, [r7, #6]	@ movhi
 727:../LSM9DS1_drivers.c **** 	int i  = *index;
 2716              		.loc 1 727 0
 2717 000c 3B68     		ldr	r3, [r7, #0]
 2718 000e 1B68     		ldr	r3, [r3, #0]
 2719 0010 FB60     		str	r3, [r7, #12]
 728:../LSM9DS1_drivers.c **** 
 729:../LSM9DS1_drivers.c **** 	if(accel < 0)
 2720              		.loc 1 729 0
 2721 0012 B7F90630 		ldrsh	r3, [r7, #6]
 2722 0016 002B     		cmp	r3, #0
 2723 0018 21DA     		bge	.L111
 730:../LSM9DS1_drivers.c **** 	{
 731:../LSM9DS1_drivers.c **** 		lk[i] = '-';
 2724              		.loc 1 731 0
 2725 001a 40F20003 		movw	r3, #:lower16:lk
 2726 001e C0F20003 		movt	r3, #:upper16:lk
 2727 0022 FA68     		ldr	r2, [r7, #12]
 2728 0024 9B18     		adds	r3, r3, r2
 2729 0026 4FF02D02 		mov	r2, #45
 2730 002a 1A70     		strb	r2, [r3, #0]
 732:../LSM9DS1_drivers.c **** 
 733:../LSM9DS1_drivers.c **** 		i++;
 2731              		.loc 1 733 0
 2732 002c FB68     		ldr	r3, [r7, #12]
 2733 002e 03F10103 		add	r3, r3, #1
 2734 0032 FB60     		str	r3, [r7, #12]
 734:../LSM9DS1_drivers.c **** 
 735:../LSM9DS1_drivers.c **** 		lk[i] = '0' + abs(accel);
 2735              		.loc 1 735 0
 2736 0034 B7F90630 		ldrsh	r3, [r7, #6]
 2737 0038 002B     		cmp	r3, #0
 2738 003a B8BF     		it	lt
 2739 003c 5B42     		rsblt	r3, r3, #0
 2740 003e DBB2     		uxtb	r3, r3
 2741 0040 03F13003 		add	r3, r3, #48
 2742 0044 DAB2     		uxtb	r2, r3
 2743 0046 40F20003 		movw	r3, #:lower16:lk
 2744 004a C0F20003 		movt	r3, #:upper16:lk
 2745 004e F968     		ldr	r1, [r7, #12]
 2746 0050 5B18     		adds	r3, r3, r1
 2747 0052 1A70     		strb	r2, [r3, #0]
 736:../LSM9DS1_drivers.c **** 
 737:../LSM9DS1_drivers.c **** 		i++;
 2748              		.loc 1 737 0
 2749 0054 FB68     		ldr	r3, [r7, #12]
 2750 0056 03F10103 		add	r3, r3, #1
 2751 005a FB60     		str	r3, [r7, #12]
 2752 005c 13E0     		b	.L112
 2753              	.L111:
 738:../LSM9DS1_drivers.c **** 	}
 739:../LSM9DS1_drivers.c **** 	else
 740:../LSM9DS1_drivers.c **** 	{
 741:../LSM9DS1_drivers.c **** 		lk[i] = '0' + abs(accel);
 2754              		.loc 1 741 0
 2755 005e B7F90630 		ldrsh	r3, [r7, #6]
 2756 0062 002B     		cmp	r3, #0
 2757 0064 B8BF     		it	lt
 2758 0066 5B42     		rsblt	r3, r3, #0
 2759 0068 DBB2     		uxtb	r3, r3
 2760 006a 03F13003 		add	r3, r3, #48
 2761 006e DAB2     		uxtb	r2, r3
 2762 0070 40F20003 		movw	r3, #:lower16:lk
 2763 0074 C0F20003 		movt	r3, #:upper16:lk
 2764 0078 F968     		ldr	r1, [r7, #12]
 2765 007a 5B18     		adds	r3, r3, r1
 2766 007c 1A70     		strb	r2, [r3, #0]
 742:../LSM9DS1_drivers.c **** 
 743:../LSM9DS1_drivers.c **** 		i++;
 2767              		.loc 1 743 0
 2768 007e FB68     		ldr	r3, [r7, #12]
 2769 0080 03F10103 		add	r3, r3, #1
 2770 0084 FB60     		str	r3, [r7, #12]
 2771              	.L112:
 744:../LSM9DS1_drivers.c **** 	}
 745:../LSM9DS1_drivers.c **** 	*index = i;
 2772              		.loc 1 745 0
 2773 0086 3B68     		ldr	r3, [r7, #0]
 2774 0088 FA68     		ldr	r2, [r7, #12]
 2775 008a 1A60     		str	r2, [r3, #0]
 746:../LSM9DS1_drivers.c **** }
 2776              		.loc 1 746 0
 2777 008c 07F11407 		add	r7, r7, #20
 2778 0090 BD46     		mov	sp, r7
 2779 0092 80BC     		pop	{r7}
 2780 0094 7047     		bx	lr
 2781              		.cfi_endproc
 2782              	.LFE137:
 2784              		.global	__aeabi_f2d
 2785              		.global	__aeabi_ddiv
 2786              		.global	__aeabi_d2iz
 2787 0096 00BF     		.section	.text.calibrate,"ax",%progbits
 2788              		.align	2
 2789              		.global	calibrate
 2790              		.thumb
 2791              		.thumb_func
 2793              	calibrate:
 2794              	.LFB138:
 747:../LSM9DS1_drivers.c **** 
 748:../LSM9DS1_drivers.c **** void calibrate(bool autoCalc)
 749:../LSM9DS1_drivers.c **** {
 2795              		.loc 1 749 0
 2796              		.cfi_startproc
 2797              		@ args = 0, pretend = 0, frame = 48
 2798              		@ frame_needed = 1, uses_anonymous_args = 0
 2799 0000 B0B5     		push	{r4, r5, r7, lr}
 2800              	.LCFI72:
 2801              		.cfi_def_cfa_offset 16
 2802              		.cfi_offset 4, -16
 2803              		.cfi_offset 5, -12
 2804              		.cfi_offset 7, -8
 2805              		.cfi_offset 14, -4
 2806 0002 8CB0     		sub	sp, sp, #48
 2807              	.LCFI73:
 2808              		.cfi_def_cfa_offset 64
 2809 0004 00AF     		add	r7, sp, #0
 2810              	.LCFI74:
 2811              		.cfi_def_cfa_register 7
 2812 0006 0346     		mov	r3, r0
 2813 0008 FB71     		strb	r3, [r7, #7]
 750:../LSM9DS1_drivers.c **** 	uint8_t data[6] = {0, 0, 0, 0, 0, 0};
 2814              		.loc 1 750 0
 2815 000a 4FF00003 		mov	r3, #0
 2816 000e 87F82430 		strb	r3, [r7, #36]
 2817 0012 4FF00003 		mov	r3, #0
 2818 0016 87F82530 		strb	r3, [r7, #37]
 2819 001a 4FF00003 		mov	r3, #0
 2820 001e 87F82630 		strb	r3, [r7, #38]
 2821 0022 4FF00003 		mov	r3, #0
 2822 0026 87F82730 		strb	r3, [r7, #39]
 2823 002a 4FF00003 		mov	r3, #0
 2824 002e 87F82830 		strb	r3, [r7, #40]
 2825 0032 4FF00003 		mov	r3, #0
 2826 0036 87F82930 		strb	r3, [r7, #41]
 751:../LSM9DS1_drivers.c **** 	uint8_t samples = 0;
 2827              		.loc 1 751 0
 2828 003a 4FF00003 		mov	r3, #0
 2829 003e 87F82B30 		strb	r3, [r7, #43]
 752:../LSM9DS1_drivers.c **** 	int ii;
 753:../LSM9DS1_drivers.c **** 	int32_t aBiasRawTemp[3] = {0, 0, 0};
 2830              		.loc 1 753 0
 2831 0042 4FF00003 		mov	r3, #0
 2832 0046 BB61     		str	r3, [r7, #24]
 2833 0048 4FF00003 		mov	r3, #0
 2834 004c FB61     		str	r3, [r7, #28]
 2835 004e 4FF00003 		mov	r3, #0
 2836 0052 3B62     		str	r3, [r7, #32]
 754:../LSM9DS1_drivers.c **** 	int32_t gBiasRawTemp[3] = {0, 0, 0};
 2837              		.loc 1 754 0
 2838 0054 4FF00003 		mov	r3, #0
 2839 0058 FB60     		str	r3, [r7, #12]
 2840 005a 4FF00003 		mov	r3, #0
 2841 005e 3B61     		str	r3, [r7, #16]
 2842 0060 4FF00003 		mov	r3, #0
 2843 0064 7B61     		str	r3, [r7, #20]
 755:../LSM9DS1_drivers.c **** 
 756:../LSM9DS1_drivers.c **** 	// Turn on FIFO and set threshold to 32 samples
 757:../LSM9DS1_drivers.c **** 	enableFIFO(TRUE);
 2844              		.loc 1 757 0
 2845 0066 4FF00100 		mov	r0, #1
 2846 006a FFF7FEFF 		bl	enableFIFO
 758:../LSM9DS1_drivers.c **** 	setFIFO(FIFO_THS, 0x1F);
 2847              		.loc 1 758 0
 2848 006e 4FF00100 		mov	r0, #1
 2849 0072 4FF01F01 		mov	r1, #31
 2850 0076 FFF7FEFF 		bl	setFIFO
 759:../LSM9DS1_drivers.c **** 	/*while (samples < 29)
 760:../LSM9DS1_drivers.c **** 	{*/
 761:../LSM9DS1_drivers.c **** 		samples = (xgReadByte(FIFO_SRC) & 0x3F); // Read number of stored samples
 2851              		.loc 1 761 0
 2852 007a 4FF02F00 		mov	r0, #47
 2853 007e FFF7FEFF 		bl	xgReadByte
 2854 0082 0346     		mov	r3, r0
 2855 0084 03F03F03 		and	r3, r3, #63
 2856 0088 87F82B30 		strb	r3, [r7, #43]
 762:../LSM9DS1_drivers.c **** 		samples = 10;
 2857              		.loc 1 762 0
 2858 008c 4FF00A03 		mov	r3, #10
 2859 0090 87F82B30 		strb	r3, [r7, #43]
 763:../LSM9DS1_drivers.c **** 	//}
 764:../LSM9DS1_drivers.c **** 	for(ii = 0; ii < samples ; ii++)
 2860              		.loc 1 764 0
 2861 0094 4FF00003 		mov	r3, #0
 2862 0098 FB62     		str	r3, [r7, #44]
 2863 009a 59E0     		b	.L114
 2864              	.L115:
 765:../LSM9DS1_drivers.c **** 	{	// Read the gyro data stored in the FIFO
 766:../LSM9DS1_drivers.c **** 		readGyro1();
 2865              		.loc 1 766 0 discriminator 2
 2866 009c FFF7FEFF 		bl	readGyro1
 767:../LSM9DS1_drivers.c **** 		gBiasRawTemp[0] += gx;
 2867              		.loc 1 767 0 discriminator 2
 2868 00a0 FA68     		ldr	r2, [r7, #12]
 2869 00a2 40F20003 		movw	r3, #:lower16:gx
 2870 00a6 C0F20003 		movt	r3, #:upper16:gx
 2871 00aa 1B88     		ldrh	r3, [r3, #0]
 2872 00ac 1BB2     		sxth	r3, r3
 2873 00ae D318     		adds	r3, r2, r3
 2874 00b0 FB60     		str	r3, [r7, #12]
 768:../LSM9DS1_drivers.c **** 		gBiasRawTemp[1] += gy;
 2875              		.loc 1 768 0 discriminator 2
 2876 00b2 3A69     		ldr	r2, [r7, #16]
 2877 00b4 40F20003 		movw	r3, #:lower16:gy
 2878 00b8 C0F20003 		movt	r3, #:upper16:gy
 2879 00bc 1B88     		ldrh	r3, [r3, #0]
 2880 00be 1BB2     		sxth	r3, r3
 2881 00c0 D318     		adds	r3, r2, r3
 2882 00c2 3B61     		str	r3, [r7, #16]
 769:../LSM9DS1_drivers.c **** 		gBiasRawTemp[2] += gz;
 2883              		.loc 1 769 0 discriminator 2
 2884 00c4 7A69     		ldr	r2, [r7, #20]
 2885 00c6 40F20003 		movw	r3, #:lower16:gz
 2886 00ca C0F20003 		movt	r3, #:upper16:gz
 2887 00ce 1B88     		ldrh	r3, [r3, #0]
 2888 00d0 1BB2     		sxth	r3, r3
 2889 00d2 D318     		adds	r3, r2, r3
 2890 00d4 7B61     		str	r3, [r7, #20]
 770:../LSM9DS1_drivers.c **** 
 771:../LSM9DS1_drivers.c **** 		readAccel1();
 2891              		.loc 1 771 0 discriminator 2
 2892 00d6 FFF7FEFF 		bl	readAccel1
 772:../LSM9DS1_drivers.c **** 		aBiasRawTemp[0] += ax;
 2893              		.loc 1 772 0 discriminator 2
 2894 00da BA69     		ldr	r2, [r7, #24]
 2895 00dc 40F20003 		movw	r3, #:lower16:ax
 2896 00e0 C0F20003 		movt	r3, #:upper16:ax
 2897 00e4 1B88     		ldrh	r3, [r3, #0]
 2898 00e6 1BB2     		sxth	r3, r3
 2899 00e8 D318     		adds	r3, r2, r3
 2900 00ea BB61     		str	r3, [r7, #24]
 773:../LSM9DS1_drivers.c **** 		aBiasRawTemp[1] += ay;
 2901              		.loc 1 773 0 discriminator 2
 2902 00ec FA69     		ldr	r2, [r7, #28]
 2903 00ee 40F20003 		movw	r3, #:lower16:ay
 2904 00f2 C0F20003 		movt	r3, #:upper16:ay
 2905 00f6 1B88     		ldrh	r3, [r3, #0]
 2906 00f8 1BB2     		sxth	r3, r3
 2907 00fa D318     		adds	r3, r2, r3
 2908 00fc FB61     		str	r3, [r7, #28]
 774:../LSM9DS1_drivers.c **** 		aBiasRawTemp[2] += az - (int16_t)(1./aRes); // Assumes sensor facing up!
 2909              		.loc 1 774 0 discriminator 2
 2910 00fe 3C6A     		ldr	r4, [r7, #32]
 2911 0100 40F20003 		movw	r3, #:lower16:az
 2912 0104 C0F20003 		movt	r3, #:upper16:az
 2913 0108 1B88     		ldrh	r3, [r3, #0]
 2914 010a 1DB2     		sxth	r5, r3
 2915 010c 40F20003 		movw	r3, #:lower16:aRes
 2916 0110 C0F20003 		movt	r3, #:upper16:aRes
 2917 0114 1B68     		ldr	r3, [r3, #0]	@ float
 2918 0116 1846     		mov	r0, r3	@ float
 2919 0118 FFF7FEFF 		bl	__aeabi_f2d
 2920 011c 0246     		mov	r2, r0
 2921 011e 0B46     		mov	r3, r1
 2922 0120 4FF00000 		mov	r0, #0
 2923 0124 4FF00001 		mov	r1, #0
 2924 0128 C3F6F071 		movt	r1, 16368
 2925 012c FFF7FEFF 		bl	__aeabi_ddiv
 2926 0130 0246     		mov	r2, r0
 2927 0132 0B46     		mov	r3, r1
 2928 0134 1046     		mov	r0, r2
 2929 0136 1946     		mov	r1, r3
 2930 0138 FFF7FEFF 		bl	__aeabi_d2iz
 2931 013c 0346     		mov	r3, r0
 2932 013e 9BB2     		uxth	r3, r3
 2933 0140 1BB2     		sxth	r3, r3
 2934 0142 EB1A     		subs	r3, r5, r3
 2935 0144 E318     		adds	r3, r4, r3
 2936 0146 3B62     		str	r3, [r7, #32]
 764:../LSM9DS1_drivers.c **** 	for(ii = 0; ii < samples ; ii++)
 2937              		.loc 1 764 0 discriminator 2
 2938 0148 FB6A     		ldr	r3, [r7, #44]
 2939 014a 03F10103 		add	r3, r3, #1
 2940 014e FB62     		str	r3, [r7, #44]
 2941              	.L114:
 764:../LSM9DS1_drivers.c **** 	for(ii = 0; ii < samples ; ii++)
 2942              		.loc 1 764 0 is_stmt 0 discriminator 1
 2943 0150 97F82B20 		ldrb	r2, [r7, #43]	@ zero_extendqisi2
 2944 0154 FB6A     		ldr	r3, [r7, #44]
 2945 0156 9A42     		cmp	r2, r3
 2946 0158 A0DC     		bgt	.L115
 775:../LSM9DS1_drivers.c **** 	}
 776:../LSM9DS1_drivers.c **** 	for (ii = 0; ii < 3; ii++)
 2947              		.loc 1 776 0 is_stmt 1
 2948 015a 4FF00003 		mov	r3, #0
 2949 015e FB62     		str	r3, [r7, #44]
 2950 0160 55E0     		b	.L116
 2951              	.L117:
 777:../LSM9DS1_drivers.c **** 	{
 778:../LSM9DS1_drivers.c **** 		gBiasRaw[ii] = gBiasRawTemp[ii] / samples;
 2952              		.loc 1 778 0 discriminator 2
 2953 0162 FB6A     		ldr	r3, [r7, #44]
 2954 0164 4FEA8303 		lsl	r3, r3, #2
 2955 0168 07F13002 		add	r2, r7, #48
 2956 016c D318     		adds	r3, r2, r3
 2957 016e 53F8242C 		ldr	r2, [r3, #-36]
 2958 0172 97F82B30 		ldrb	r3, [r7, #43]	@ zero_extendqisi2
 2959 0176 92FBF3F3 		sdiv	r3, r2, r3
 2960 017a 99B2     		uxth	r1, r3
 2961 017c 40F20003 		movw	r3, #:lower16:gBiasRaw
 2962 0180 C0F20003 		movt	r3, #:upper16:gBiasRaw
 2963 0184 FA6A     		ldr	r2, [r7, #44]
 2964 0186 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 779:../LSM9DS1_drivers.c **** 		gBias[ii] = calcGyro(gBiasRaw[ii]);
 2965              		.loc 1 779 0 discriminator 2
 2966 018a 40F20003 		movw	r3, #:lower16:gBiasRaw
 2967 018e C0F20003 		movt	r3, #:upper16:gBiasRaw
 2968 0192 FA6A     		ldr	r2, [r7, #44]
 2969 0194 33F81230 		ldrh	r3, [r3, r2, lsl #1]
 2970 0198 1BB2     		sxth	r3, r3
 2971 019a 1846     		mov	r0, r3
 2972 019c FFF7FEFF 		bl	calcGyro
 2973 01a0 0246     		mov	r2, r0	@ float
 2974 01a2 40F20003 		movw	r3, #:lower16:gBias
 2975 01a6 C0F20003 		movt	r3, #:upper16:gBias
 2976 01aa F96A     		ldr	r1, [r7, #44]
 2977 01ac 4FEA8101 		lsl	r1, r1, #2
 2978 01b0 5B18     		adds	r3, r3, r1
 2979 01b2 1A60     		str	r2, [r3, #0]	@ float
 780:../LSM9DS1_drivers.c **** 		aBiasRaw[ii] = aBiasRawTemp[ii] / samples;
 2980              		.loc 1 780 0 discriminator 2
 2981 01b4 FB6A     		ldr	r3, [r7, #44]
 2982 01b6 4FEA8303 		lsl	r3, r3, #2
 2983 01ba 07F13002 		add	r2, r7, #48
 2984 01be D318     		adds	r3, r2, r3
 2985 01c0 53F8182C 		ldr	r2, [r3, #-24]
 2986 01c4 97F82B30 		ldrb	r3, [r7, #43]	@ zero_extendqisi2
 2987 01c8 92FBF3F3 		sdiv	r3, r2, r3
 2988 01cc 99B2     		uxth	r1, r3
 2989 01ce 40F20003 		movw	r3, #:lower16:aBiasRaw
 2990 01d2 C0F20003 		movt	r3, #:upper16:aBiasRaw
 2991 01d6 FA6A     		ldr	r2, [r7, #44]
 2992 01d8 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 781:../LSM9DS1_drivers.c **** 		aBias[ii] = calcAccel(aBiasRaw[ii]);
 2993              		.loc 1 781 0 discriminator 2
 2994 01dc 40F20003 		movw	r3, #:lower16:aBiasRaw
 2995 01e0 C0F20003 		movt	r3, #:upper16:aBiasRaw
 2996 01e4 FA6A     		ldr	r2, [r7, #44]
 2997 01e6 33F81230 		ldrh	r3, [r3, r2, lsl #1]
 2998 01ea 1BB2     		sxth	r3, r3
 2999 01ec 1846     		mov	r0, r3
 3000 01ee FFF7FEFF 		bl	calcAccel
 3001 01f2 0246     		mov	r2, r0	@ float
 3002 01f4 40F20003 		movw	r3, #:lower16:aBias
 3003 01f8 C0F20003 		movt	r3, #:upper16:aBias
 3004 01fc F96A     		ldr	r1, [r7, #44]
 3005 01fe 4FEA8101 		lsl	r1, r1, #2
 3006 0202 5B18     		adds	r3, r3, r1
 3007 0204 1A60     		str	r2, [r3, #0]	@ float
 776:../LSM9DS1_drivers.c **** 	for (ii = 0; ii < 3; ii++)
 3008              		.loc 1 776 0 discriminator 2
 3009 0206 FB6A     		ldr	r3, [r7, #44]
 3010 0208 03F10103 		add	r3, r3, #1
 3011 020c FB62     		str	r3, [r7, #44]
 3012              	.L116:
 776:../LSM9DS1_drivers.c **** 	for (ii = 0; ii < 3; ii++)
 3013              		.loc 1 776 0 is_stmt 0 discriminator 1
 3014 020e FB6A     		ldr	r3, [r7, #44]
 3015 0210 022B     		cmp	r3, #2
 3016 0212 A6DD     		ble	.L117
 782:../LSM9DS1_drivers.c **** 	}
 783:../LSM9DS1_drivers.c **** 
 784:../LSM9DS1_drivers.c **** 	enableFIFO(FALSE);
 3017              		.loc 1 784 0 is_stmt 1
 3018 0214 4FF00000 		mov	r0, #0
 3019 0218 FFF7FEFF 		bl	enableFIFO
 785:../LSM9DS1_drivers.c **** 	setFIFO(FIFO_OFF, 0x00);
 3020              		.loc 1 785 0
 3021 021c 4FF00000 		mov	r0, #0
 3022 0220 4FF00001 		mov	r1, #0
 3023 0224 FFF7FEFF 		bl	setFIFO
 786:../LSM9DS1_drivers.c **** 
 787:../LSM9DS1_drivers.c **** 	if (autoCalc) _autoCalc = TRUE;
 3024              		.loc 1 787 0
 3025 0228 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3026 022a 002B     		cmp	r3, #0
 3027 022c 06D0     		beq	.L113
 3028              		.loc 1 787 0 is_stmt 0 discriminator 1
 3029 022e 40F20003 		movw	r3, #:lower16:_autoCalc
 3030 0232 C0F20003 		movt	r3, #:upper16:_autoCalc
 3031 0236 4FF00102 		mov	r2, #1
 3032 023a 1A70     		strb	r2, [r3, #0]
 3033              	.L113:
 788:../LSM9DS1_drivers.c **** }
 3034              		.loc 1 788 0 is_stmt 1
 3035 023c 07F13007 		add	r7, r7, #48
 3036 0240 BD46     		mov	sp, r7
 3037 0242 B0BD     		pop	{r4, r5, r7, pc}
 3038              		.cfi_endproc
 3039              	.LFE138:
 3041              		.section	.text.magAvailable,"ax",%progbits
 3042              		.align	2
 3043              		.global	magAvailable
 3044              		.thumb
 3045              		.thumb_func
 3047              	magAvailable:
 3048              	.LFB139:
 789:../LSM9DS1_drivers.c **** 
 790:../LSM9DS1_drivers.c **** uint8_t magAvailable(lsm9ds1_axis axis)
 791:../LSM9DS1_drivers.c **** {
 3049              		.loc 1 791 0
 3050              		.cfi_startproc
 3051              		@ args = 0, pretend = 0, frame = 16
 3052              		@ frame_needed = 1, uses_anonymous_args = 0
 3053 0000 80B5     		push	{r7, lr}
 3054              	.LCFI75:
 3055              		.cfi_def_cfa_offset 8
 3056              		.cfi_offset 7, -8
 3057              		.cfi_offset 14, -4
 3058 0002 84B0     		sub	sp, sp, #16
 3059              	.LCFI76:
 3060              		.cfi_def_cfa_offset 24
 3061 0004 00AF     		add	r7, sp, #0
 3062              	.LCFI77:
 3063              		.cfi_def_cfa_register 7
 3064 0006 0346     		mov	r3, r0
 3065 0008 FB71     		strb	r3, [r7, #7]
 792:../LSM9DS1_drivers.c **** 	uint8_t status;
 793:../LSM9DS1_drivers.c **** 	status = mReadByte(STATUS_REG_M);
 3066              		.loc 1 793 0
 3067 000a 4FF02700 		mov	r0, #39
 3068 000e FFF7FEFF 		bl	mReadByte
 3069 0012 0346     		mov	r3, r0
 3070 0014 FB73     		strb	r3, [r7, #15]
 794:../LSM9DS1_drivers.c **** 
 795:../LSM9DS1_drivers.c **** 	return ((status & (1<<axis)) >> axis);
 3071              		.loc 1 795 0
 3072 0016 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 3073 0018 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3074 001a 4FF00101 		mov	r1, #1
 3075 001e 01FA03F3 		lsl	r3, r1, r3
 3076 0022 1A40     		ands	r2, r2, r3
 3077 0024 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3078 0026 42FA03F3 		asr	r3, r2, r3
 3079 002a DBB2     		uxtb	r3, r3
 796:../LSM9DS1_drivers.c **** }
 3080              		.loc 1 796 0
 3081 002c 1846     		mov	r0, r3
 3082 002e 07F11007 		add	r7, r7, #16
 3083 0032 BD46     		mov	sp, r7
 3084 0034 80BD     		pop	{r7, pc}
 3085              		.cfi_endproc
 3086              	.LFE139:
 3088 0036 00BF     		.section	.text.readMag1,"ax",%progbits
 3089              		.align	2
 3090              		.global	readMag1
 3091              		.thumb
 3092              		.thumb_func
 3094              	readMag1:
 3095              	.LFB140:
 797:../LSM9DS1_drivers.c **** 
 798:../LSM9DS1_drivers.c **** void readMag1(void)
 799:../LSM9DS1_drivers.c **** {
 3096              		.loc 1 799 0
 3097              		.cfi_startproc
 3098              		@ args = 0, pretend = 0, frame = 8
 3099              		@ frame_needed = 1, uses_anonymous_args = 0
 3100 0000 80B5     		push	{r7, lr}
 3101              	.LCFI78:
 3102              		.cfi_def_cfa_offset 8
 3103              		.cfi_offset 7, -8
 3104              		.cfi_offset 14, -4
 3105 0002 82B0     		sub	sp, sp, #8
 3106              	.LCFI79:
 3107              		.cfi_def_cfa_offset 16
 3108 0004 00AF     		add	r7, sp, #0
 3109              	.LCFI80:
 3110              		.cfi_def_cfa_register 7
 800:../LSM9DS1_drivers.c **** 	//for(int kl = 0; kl < 10; kl++){
 801:../LSM9DS1_drivers.c **** 	uint8_t temp[6]; // We'll read six bytes from the mag into temp
 802:../LSM9DS1_drivers.c **** 	mReadBytes(OUT_X_L_M, temp, 6); // Read 6 bytes, beginning at OUT_X_L_M
 3111              		.loc 1 802 0
 3112 0006 3B46     		mov	r3, r7
 3113 0008 4FF02800 		mov	r0, #40
 3114 000c 1946     		mov	r1, r3
 3115 000e 4FF00602 		mov	r2, #6
 3116 0012 FFF7FEFF 		bl	mReadBytes
 803:../LSM9DS1_drivers.c **** 	mx = (temp[1] << 8) | temp[0]; // Store x-axis values into mx
 3117              		.loc 1 803 0
 3118 0016 7B78     		ldrb	r3, [r7, #1]	@ zero_extendqisi2
 3119 0018 4FEA0323 		lsl	r3, r3, #8
 3120 001c 9AB2     		uxth	r2, r3
 3121 001e 3B78     		ldrb	r3, [r7, #0]	@ zero_extendqisi2
 3122 0020 1343     		orrs	r3, r3, r2
 3123 0022 9AB2     		uxth	r2, r3
 3124 0024 40F20003 		movw	r3, #:lower16:mx
 3125 0028 C0F20003 		movt	r3, #:upper16:mx
 3126 002c 1A80     		strh	r2, [r3, #0]	@ movhi
 804:../LSM9DS1_drivers.c **** 	my = (temp[3] << 8) | temp[2]; // Store y-axis values into my
 3127              		.loc 1 804 0
 3128 002e FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 3129 0030 4FEA0323 		lsl	r3, r3, #8
 3130 0034 9AB2     		uxth	r2, r3
 3131 0036 BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 3132 0038 1343     		orrs	r3, r3, r2
 3133 003a 9AB2     		uxth	r2, r3
 3134 003c 40F20003 		movw	r3, #:lower16:my
 3135 0040 C0F20003 		movt	r3, #:upper16:my
 3136 0044 1A80     		strh	r2, [r3, #0]	@ movhi
 805:../LSM9DS1_drivers.c **** 	mz = (temp[5] << 8) | temp[4]; // Store z-axis values into mz
 3137              		.loc 1 805 0
 3138 0046 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 3139 0048 4FEA0323 		lsl	r3, r3, #8
 3140 004c 9AB2     		uxth	r2, r3
 3141 004e 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 3142 0050 1343     		orrs	r3, r3, r2
 3143 0052 9AB2     		uxth	r2, r3
 3144 0054 40F20003 		movw	r3, #:lower16:mz
 3145 0058 C0F20003 		movt	r3, #:upper16:mz
 3146 005c 1A80     		strh	r2, [r3, #0]	@ movhi
 806:../LSM9DS1_drivers.c **** 
 807:../LSM9DS1_drivers.c **** 	mx = calcMag(mx);
 3147              		.loc 1 807 0
 3148 005e 40F20003 		movw	r3, #:lower16:mx
 3149 0062 C0F20003 		movt	r3, #:upper16:mx
 3150 0066 1B88     		ldrh	r3, [r3, #0]
 3151 0068 1BB2     		sxth	r3, r3
 3152 006a 1846     		mov	r0, r3
 3153 006c FFF7FEFF 		bl	calcMag
 3154 0070 07EE900A 		fmsr	s15, r0
 3155 0074 FDEEE77A 		ftosizs	s15, s15
 3156 0078 17EE903A 		fmrs	r3, s15	@ int
 3157 007c 9AB2     		uxth	r2, r3
 3158 007e 40F20003 		movw	r3, #:lower16:mx
 3159 0082 C0F20003 		movt	r3, #:upper16:mx
 3160 0086 1A80     		strh	r2, [r3, #0]	@ movhi
 808:../LSM9DS1_drivers.c **** 	my = calcMag(my);
 3161              		.loc 1 808 0
 3162 0088 40F20003 		movw	r3, #:lower16:my
 3163 008c C0F20003 		movt	r3, #:upper16:my
 3164 0090 1B88     		ldrh	r3, [r3, #0]
 3165 0092 1BB2     		sxth	r3, r3
 3166 0094 1846     		mov	r0, r3
 3167 0096 FFF7FEFF 		bl	calcMag
 3168 009a 07EE900A 		fmsr	s15, r0
 3169 009e FDEEE77A 		ftosizs	s15, s15
 3170 00a2 17EE903A 		fmrs	r3, s15	@ int
 3171 00a6 9AB2     		uxth	r2, r3
 3172 00a8 40F20003 		movw	r3, #:lower16:my
 3173 00ac C0F20003 		movt	r3, #:upper16:my
 3174 00b0 1A80     		strh	r2, [r3, #0]	@ movhi
 809:../LSM9DS1_drivers.c **** 	mz = calcMag(mz);
 3175              		.loc 1 809 0
 3176 00b2 40F20003 		movw	r3, #:lower16:mz
 3177 00b6 C0F20003 		movt	r3, #:upper16:mz
 3178 00ba 1B88     		ldrh	r3, [r3, #0]
 3179 00bc 1BB2     		sxth	r3, r3
 3180 00be 1846     		mov	r0, r3
 3181 00c0 FFF7FEFF 		bl	calcMag
 3182 00c4 07EE900A 		fmsr	s15, r0
 3183 00c8 FDEEE77A 		ftosizs	s15, s15
 3184 00cc 17EE903A 		fmrs	r3, s15	@ int
 3185 00d0 9AB2     		uxth	r2, r3
 3186 00d2 40F20003 		movw	r3, #:lower16:mz
 3187 00d6 C0F20003 		movt	r3, #:upper16:mz
 3188 00da 1A80     		strh	r2, [r3, #0]	@ movhi
 810:../LSM9DS1_drivers.c **** 	/*}*/
 811:../LSM9DS1_drivers.c **** 
 812:../LSM9DS1_drivers.c **** 
 813:../LSM9DS1_drivers.c **** }
 3189              		.loc 1 813 0
 3190 00dc 07F10807 		add	r7, r7, #8
 3191 00e0 BD46     		mov	sp, r7
 3192 00e2 80BD     		pop	{r7, pc}
 3193              		.cfi_endproc
 3194              	.LFE140:
 3196              		.section	.text.calibrateMag,"ax",%progbits
 3197              		.align	2
 3198              		.global	calibrateMag
 3199              		.thumb
 3200              		.thumb_func
 3202              	calibrateMag:
 3203              	.LFB141:
 814:../LSM9DS1_drivers.c **** 
 815:../LSM9DS1_drivers.c **** void calibrateMag(bool loadIn)
 816:../LSM9DS1_drivers.c **** {
 3204              		.loc 1 816 0
 3205              		.cfi_startproc
 3206              		@ args = 0, pretend = 0, frame = 40
 3207              		@ frame_needed = 1, uses_anonymous_args = 0
 3208 0000 80B5     		push	{r7, lr}
 3209              	.LCFI81:
 3210              		.cfi_def_cfa_offset 8
 3211              		.cfi_offset 7, -8
 3212              		.cfi_offset 14, -4
 3213 0002 8AB0     		sub	sp, sp, #40
 3214              	.LCFI82:
 3215              		.cfi_def_cfa_offset 48
 3216 0004 00AF     		add	r7, sp, #0
 3217              	.LCFI83:
 3218              		.cfi_def_cfa_register 7
 3219 0006 0346     		mov	r3, r0
 3220 0008 FB71     		strb	r3, [r7, #7]
 817:../LSM9DS1_drivers.c **** 	int i, j;
 818:../LSM9DS1_drivers.c **** 	int16_t magMin[3] = {0, 0, 0};
 3221              		.loc 1 818 0
 3222 000a 4FF00003 		mov	r3, #0
 3223 000e 3B83     		strh	r3, [r7, #24]	@ movhi
 3224 0010 4FF00003 		mov	r3, #0
 3225 0014 7B83     		strh	r3, [r7, #26]	@ movhi
 3226 0016 4FF00003 		mov	r3, #0
 3227 001a BB83     		strh	r3, [r7, #28]	@ movhi
 819:../LSM9DS1_drivers.c **** 	int16_t magMax[3] = {0, 0, 0}; // The road warrior
 3228              		.loc 1 819 0
 3229 001c 4FF00003 		mov	r3, #0
 3230 0020 3B82     		strh	r3, [r7, #16]	@ movhi
 3231 0022 4FF00003 		mov	r3, #0
 3232 0026 7B82     		strh	r3, [r7, #18]	@ movhi
 3233 0028 4FF00003 		mov	r3, #0
 3234 002c BB82     		strh	r3, [r7, #20]	@ movhi
 820:../LSM9DS1_drivers.c **** 
 821:../LSM9DS1_drivers.c **** 	for (i=0; i<128; i++)
 3235              		.loc 1 821 0
 3236 002e 4FF00003 		mov	r3, #0
 3237 0032 7B62     		str	r3, [r7, #36]
 3238 0034 7CE0     		b	.L123
 3239              	.L133:
 3240              	.LBB6:
 822:../LSM9DS1_drivers.c **** 	{
 823:../LSM9DS1_drivers.c **** 		//tu nie wiem
 824:../LSM9DS1_drivers.c **** 		while (!magAvailable(i))
 3241              		.loc 1 824 0
 3242 0036 00BF     		nop
 3243              	.L124:
 3244              		.loc 1 824 0 is_stmt 0 discriminator 1
 3245 0038 7B6A     		ldr	r3, [r7, #36]
 3246 003a DBB2     		uxtb	r3, r3
 3247 003c 1846     		mov	r0, r3
 3248 003e FFF7FEFF 		bl	magAvailable
 3249 0042 0346     		mov	r3, r0
 3250 0044 002B     		cmp	r3, #0
 3251 0046 F7D0     		beq	.L124
 825:../LSM9DS1_drivers.c **** 			;
 826:../LSM9DS1_drivers.c **** 		readMag1();
 3252              		.loc 1 826 0 is_stmt 1
 3253 0048 FFF7FEFF 		bl	readMag1
 827:../LSM9DS1_drivers.c **** 		int16_t magTemp[3] = {0, 0, 0};
 3254              		.loc 1 827 0
 3255 004c 4FF00003 		mov	r3, #0
 3256 0050 3B81     		strh	r3, [r7, #8]	@ movhi
 3257 0052 4FF00003 		mov	r3, #0
 3258 0056 7B81     		strh	r3, [r7, #10]	@ movhi
 3259 0058 4FF00003 		mov	r3, #0
 3260 005c BB81     		strh	r3, [r7, #12]	@ movhi
 828:../LSM9DS1_drivers.c **** 		magTemp[0] = mx;
 3261              		.loc 1 828 0
 3262 005e 40F20003 		movw	r3, #:lower16:mx
 3263 0062 C0F20003 		movt	r3, #:upper16:mx
 3264 0066 1B88     		ldrh	r3, [r3, #0]
 3265 0068 3B81     		strh	r3, [r7, #8]	@ movhi
 829:../LSM9DS1_drivers.c **** 		magTemp[1] = my;
 3266              		.loc 1 829 0
 3267 006a 40F20003 		movw	r3, #:lower16:my
 3268 006e C0F20003 		movt	r3, #:upper16:my
 3269 0072 1B88     		ldrh	r3, [r3, #0]
 3270 0074 7B81     		strh	r3, [r7, #10]	@ movhi
 830:../LSM9DS1_drivers.c **** 		magTemp[2] = mz;
 3271              		.loc 1 830 0
 3272 0076 40F20003 		movw	r3, #:lower16:mz
 3273 007a C0F20003 		movt	r3, #:upper16:mz
 3274 007e 1B88     		ldrh	r3, [r3, #0]
 3275 0080 BB81     		strh	r3, [r7, #12]	@ movhi
 831:../LSM9DS1_drivers.c **** 		for (j = 0; j < 3; j++)
 3276              		.loc 1 831 0
 3277 0082 4FF00003 		mov	r3, #0
 3278 0086 3B62     		str	r3, [r7, #32]
 3279 0088 4BE0     		b	.L125
 3280              	.L128:
 832:../LSM9DS1_drivers.c **** 		{
 833:../LSM9DS1_drivers.c **** 			if (magTemp[j] > magMax[j]) magMax[j] = magTemp[j];
 3281              		.loc 1 833 0
 3282 008a 3B6A     		ldr	r3, [r7, #32]
 3283 008c 4FEA4303 		lsl	r3, r3, #1
 3284 0090 07F12801 		add	r1, r7, #40
 3285 0094 CB18     		adds	r3, r1, r3
 3286 0096 33F8202C 		ldrh	r2, [r3, #-32]
 3287 009a 3B6A     		ldr	r3, [r7, #32]
 3288 009c 4FEA4303 		lsl	r3, r3, #1
 3289 00a0 07F12801 		add	r1, r7, #40
 3290 00a4 CB18     		adds	r3, r1, r3
 3291 00a6 33F8183C 		ldrh	r3, [r3, #-24]
 3292 00aa 12B2     		sxth	r2, r2
 3293 00ac 1BB2     		sxth	r3, r3
 3294 00ae 9A42     		cmp	r2, r3
 3295 00b0 0FDD     		ble	.L126
 3296              		.loc 1 833 0 is_stmt 0 discriminator 1
 3297 00b2 3B6A     		ldr	r3, [r7, #32]
 3298 00b4 4FEA4303 		lsl	r3, r3, #1
 3299 00b8 07F12802 		add	r2, r7, #40
 3300 00bc D318     		adds	r3, r2, r3
 3301 00be 33F8202C 		ldrh	r2, [r3, #-32]
 3302 00c2 3B6A     		ldr	r3, [r7, #32]
 3303 00c4 4FEA4303 		lsl	r3, r3, #1
 3304 00c8 07F12801 		add	r1, r7, #40
 3305 00cc CB18     		adds	r3, r1, r3
 3306 00ce 23F8182C 		strh	r2, [r3, #-24]	@ movhi
 3307              	.L126:
 834:../LSM9DS1_drivers.c **** 			if (magTemp[j] < magMin[j]) magMin[j] = magTemp[j];
 3308              		.loc 1 834 0 is_stmt 1
 3309 00d2 3B6A     		ldr	r3, [r7, #32]
 3310 00d4 4FEA4303 		lsl	r3, r3, #1
 3311 00d8 07F12802 		add	r2, r7, #40
 3312 00dc D318     		adds	r3, r2, r3
 3313 00de 33F8202C 		ldrh	r2, [r3, #-32]
 3314 00e2 3B6A     		ldr	r3, [r7, #32]
 3315 00e4 4FEA4303 		lsl	r3, r3, #1
 3316 00e8 07F12801 		add	r1, r7, #40
 3317 00ec CB18     		adds	r3, r1, r3
 3318 00ee 33F8103C 		ldrh	r3, [r3, #-16]
 3319 00f2 12B2     		sxth	r2, r2
 3320 00f4 1BB2     		sxth	r3, r3
 3321 00f6 9A42     		cmp	r2, r3
 3322 00f8 0FDA     		bge	.L127
 3323              		.loc 1 834 0 is_stmt 0 discriminator 1
 3324 00fa 3B6A     		ldr	r3, [r7, #32]
 3325 00fc 4FEA4303 		lsl	r3, r3, #1
 3326 0100 07F12802 		add	r2, r7, #40
 3327 0104 D318     		adds	r3, r2, r3
 3328 0106 33F8202C 		ldrh	r2, [r3, #-32]
 3329 010a 3B6A     		ldr	r3, [r7, #32]
 3330 010c 4FEA4303 		lsl	r3, r3, #1
 3331 0110 07F12801 		add	r1, r7, #40
 3332 0114 CB18     		adds	r3, r1, r3
 3333 0116 23F8102C 		strh	r2, [r3, #-16]	@ movhi
 3334              	.L127:
 831:../LSM9DS1_drivers.c **** 		for (j = 0; j < 3; j++)
 3335              		.loc 1 831 0 is_stmt 1
 3336 011a 3B6A     		ldr	r3, [r7, #32]
 3337 011c 03F10103 		add	r3, r3, #1
 3338 0120 3B62     		str	r3, [r7, #32]
 3339              	.L125:
 831:../LSM9DS1_drivers.c **** 		for (j = 0; j < 3; j++)
 3340              		.loc 1 831 0 is_stmt 0 discriminator 1
 3341 0122 3B6A     		ldr	r3, [r7, #32]
 3342 0124 022B     		cmp	r3, #2
 3343 0126 B0DD     		ble	.L128
 3344              	.LBE6:
 821:../LSM9DS1_drivers.c **** 	for (i=0; i<128; i++)
 3345              		.loc 1 821 0 is_stmt 1
 3346 0128 7B6A     		ldr	r3, [r7, #36]
 3347 012a 03F10103 		add	r3, r3, #1
 3348 012e 7B62     		str	r3, [r7, #36]
 3349              	.L123:
 821:../LSM9DS1_drivers.c **** 	for (i=0; i<128; i++)
 3350              		.loc 1 821 0 is_stmt 0 discriminator 1
 3351 0130 7B6A     		ldr	r3, [r7, #36]
 3352 0132 7F2B     		cmp	r3, #127
 3353 0134 7FF77FAF 		ble	.L133
 835:../LSM9DS1_drivers.c **** 		}
 836:../LSM9DS1_drivers.c **** 	}
 837:../LSM9DS1_drivers.c **** 	for (j = 0; j < 3; j++)
 3354              		.loc 1 837 0 is_stmt 1
 3355 0138 4FF00003 		mov	r3, #0
 3356 013c 3B62     		str	r3, [r7, #32]
 3357 013e 49E0     		b	.L130
 3358              	.L132:
 838:../LSM9DS1_drivers.c **** 	{
 839:../LSM9DS1_drivers.c **** 		mBiasRaw[j] = (magMax[j] + magMin[j]) / 2;
 3359              		.loc 1 839 0
 3360 0140 3B6A     		ldr	r3, [r7, #32]
 3361 0142 4FEA4303 		lsl	r3, r3, #1
 3362 0146 07F12802 		add	r2, r7, #40
 3363 014a D318     		adds	r3, r2, r3
 3364 014c 33F8183C 		ldrh	r3, [r3, #-24]
 3365 0150 1AB2     		sxth	r2, r3
 3366 0152 3B6A     		ldr	r3, [r7, #32]
 3367 0154 4FEA4303 		lsl	r3, r3, #1
 3368 0158 07F12801 		add	r1, r7, #40
 3369 015c CB18     		adds	r3, r1, r3
 3370 015e 33F8103C 		ldrh	r3, [r3, #-16]
 3371 0162 1BB2     		sxth	r3, r3
 3372 0164 D318     		adds	r3, r2, r3
 3373 0166 4FEAD372 		lsr	r2, r3, #31
 3374 016a D318     		adds	r3, r2, r3
 3375 016c 4FEA6303 		asr	r3, r3, #1
 3376 0170 99B2     		uxth	r1, r3
 3377 0172 40F20003 		movw	r3, #:lower16:mBiasRaw
 3378 0176 C0F20003 		movt	r3, #:upper16:mBiasRaw
 3379 017a 3A6A     		ldr	r2, [r7, #32]
 3380 017c 23F81210 		strh	r1, [r3, r2, lsl #1]	@ movhi
 840:../LSM9DS1_drivers.c **** 		mBias[j] = calcMag(mBiasRaw[j]);
 3381              		.loc 1 840 0
 3382 0180 40F20003 		movw	r3, #:lower16:mBiasRaw
 3383 0184 C0F20003 		movt	r3, #:upper16:mBiasRaw
 3384 0188 3A6A     		ldr	r2, [r7, #32]
 3385 018a 33F81230 		ldrh	r3, [r3, r2, lsl #1]
 3386 018e 1BB2     		sxth	r3, r3
 3387 0190 1846     		mov	r0, r3
 3388 0192 FFF7FEFF 		bl	calcMag
 3389 0196 0246     		mov	r2, r0	@ float
 3390 0198 40F20003 		movw	r3, #:lower16:mBias
 3391 019c C0F20003 		movt	r3, #:upper16:mBias
 3392 01a0 396A     		ldr	r1, [r7, #32]
 3393 01a2 4FEA8101 		lsl	r1, r1, #2
 3394 01a6 5B18     		adds	r3, r3, r1
 3395 01a8 1A60     		str	r2, [r3, #0]	@ float
 841:../LSM9DS1_drivers.c **** 		if (loadIn)
 3396              		.loc 1 841 0
 3397 01aa FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3398 01ac 002B     		cmp	r3, #0
 3399 01ae 0DD0     		beq	.L131
 842:../LSM9DS1_drivers.c **** 			magOffset(j, mBiasRaw[j]);
 3400              		.loc 1 842 0
 3401 01b0 3B6A     		ldr	r3, [r7, #32]
 3402 01b2 DAB2     		uxtb	r2, r3
 3403 01b4 40F20003 		movw	r3, #:lower16:mBiasRaw
 3404 01b8 C0F20003 		movt	r3, #:upper16:mBiasRaw
 3405 01bc 396A     		ldr	r1, [r7, #32]
 3406 01be 33F81130 		ldrh	r3, [r3, r1, lsl #1]
 3407 01c2 1BB2     		sxth	r3, r3
 3408 01c4 1046     		mov	r0, r2
 3409 01c6 1946     		mov	r1, r3
 3410 01c8 FFF7FEFF 		bl	magOffset
 3411              	.L131:
 837:../LSM9DS1_drivers.c **** 	for (j = 0; j < 3; j++)
 3412              		.loc 1 837 0
 3413 01cc 3B6A     		ldr	r3, [r7, #32]
 3414 01ce 03F10103 		add	r3, r3, #1
 3415 01d2 3B62     		str	r3, [r7, #32]
 3416              	.L130:
 837:../LSM9DS1_drivers.c **** 	for (j = 0; j < 3; j++)
 3417              		.loc 1 837 0 is_stmt 0 discriminator 1
 3418 01d4 3B6A     		ldr	r3, [r7, #32]
 3419 01d6 022B     		cmp	r3, #2
 3420 01d8 B2DD     		ble	.L132
 843:../LSM9DS1_drivers.c **** 	}
 844:../LSM9DS1_drivers.c **** }
 3421              		.loc 1 844 0 is_stmt 1
 3422 01da 07F12807 		add	r7, r7, #40
 3423 01de BD46     		mov	sp, r7
 3424 01e0 80BD     		pop	{r7, pc}
 3425              		.cfi_endproc
 3426              	.LFE141:
 3428              		.global	__aeabi_d2f
 3429 01e2 00BF     		.section	.text.calcMag,"ax",%progbits
 3430              		.align	2
 3431              		.global	calcMag
 3432              		.thumb
 3433              		.thumb_func
 3435              	calcMag:
 3436              	.LFB142:
 845:../LSM9DS1_drivers.c **** 
 846:../LSM9DS1_drivers.c **** float calcMag(int16_t mag)
 847:../LSM9DS1_drivers.c **** {
 3437              		.loc 1 847 0
 3438              		.cfi_startproc
 3439              		@ args = 0, pretend = 0, frame = 8
 3440              		@ frame_needed = 1, uses_anonymous_args = 0
 3441 0000 80B5     		push	{r7, lr}
 3442              	.LCFI84:
 3443              		.cfi_def_cfa_offset 8
 3444              		.cfi_offset 7, -8
 3445              		.cfi_offset 14, -4
 3446 0002 82B0     		sub	sp, sp, #8
 3447              	.LCFI85:
 3448              		.cfi_def_cfa_offset 16
 3449 0004 00AF     		add	r7, sp, #0
 3450              	.LCFI86:
 3451              		.cfi_def_cfa_register 7
 3452 0006 0346     		mov	r3, r0
 3453 0008 FB80     		strh	r3, [r7, #6]	@ movhi
 848:../LSM9DS1_drivers.c **** 	// Return the mag raw reading times our pre-calculated Gs / (ADC tick):
 849:../LSM9DS1_drivers.c **** 	return ceil(mRes * mag);
 3454              		.loc 1 849 0
 3455 000a B7F90630 		ldrsh	r3, [r7, #6]
 3456 000e 07EE903A 		fmsr	s15, r3	@ int
 3457 0012 B8EEE77A 		fsitos	s14, s15
 3458 0016 40F20003 		movw	r3, #:lower16:mRes
 3459 001a C0F20003 		movt	r3, #:upper16:mRes
 3460 001e D3ED007A 		flds	s15, [r3, #0]
 3461 0022 67EE277A 		fmuls	s15, s14, s15
 3462 0026 17EE900A 		fmrs	r0, s15
 3463 002a FFF7FEFF 		bl	__aeabi_f2d
 3464 002e 0246     		mov	r2, r0
 3465 0030 0B46     		mov	r3, r1
 3466 0032 1046     		mov	r0, r2
 3467 0034 1946     		mov	r1, r3
 3468 0036 FFF7FEFF 		bl	ceil
 3469 003a 0246     		mov	r2, r0
 3470 003c 0B46     		mov	r3, r1
 3471 003e 1046     		mov	r0, r2
 3472 0040 1946     		mov	r1, r3
 3473 0042 FFF7FEFF 		bl	__aeabi_d2f
 3474 0046 0346     		mov	r3, r0	@ float
 850:../LSM9DS1_drivers.c **** }
 3475              		.loc 1 850 0
 3476 0048 1846     		mov	r0, r3	@ float
 3477 004a 07F10807 		add	r7, r7, #8
 3478 004e BD46     		mov	sp, r7
 3479 0050 80BD     		pop	{r7, pc}
 3480              		.cfi_endproc
 3481              	.LFE142:
 3483 0052 00BF     		.section	.text.magOffset,"ax",%progbits
 3484              		.align	2
 3485              		.global	magOffset
 3486              		.thumb
 3487              		.thumb_func
 3489              	magOffset:
 3490              	.LFB143:
 851:../LSM9DS1_drivers.c **** 
 852:../LSM9DS1_drivers.c **** void magOffset(uint8_t axis, int16_t offset)
 853:../LSM9DS1_drivers.c **** {
 3491              		.loc 1 853 0
 3492              		.cfi_startproc
 3493              		@ args = 0, pretend = 0, frame = 16
 3494              		@ frame_needed = 1, uses_anonymous_args = 0
 3495 0000 80B5     		push	{r7, lr}
 3496              	.LCFI87:
 3497              		.cfi_def_cfa_offset 8
 3498              		.cfi_offset 7, -8
 3499              		.cfi_offset 14, -4
 3500 0002 84B0     		sub	sp, sp, #16
 3501              	.LCFI88:
 3502              		.cfi_def_cfa_offset 24
 3503 0004 00AF     		add	r7, sp, #0
 3504              	.LCFI89:
 3505              		.cfi_def_cfa_register 7
 3506 0006 0246     		mov	r2, r0
 3507 0008 0B46     		mov	r3, r1
 3508 000a FA71     		strb	r2, [r7, #7]
 3509 000c BB80     		strh	r3, [r7, #4]	@ movhi
 854:../LSM9DS1_drivers.c **** 	if (axis > 2)
 3510              		.loc 1 854 0
 3511 000e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3512 0010 022B     		cmp	r3, #2
 3513 0012 21D8     		bhi	.L139
 3514              	.L137:
 855:../LSM9DS1_drivers.c **** 		return;
 856:../LSM9DS1_drivers.c **** 	uint8_t msb, lsb;
 857:../LSM9DS1_drivers.c **** 	msb = (offset & 0xFF00) >> 8;
 3515              		.loc 1 857 0
 3516 0014 B7F90430 		ldrsh	r3, [r7, #4]
 3517 0018 03F47F43 		and	r3, r3, #65280
 3518 001c 4FEA2323 		asr	r3, r3, #8
 3519 0020 FB73     		strb	r3, [r7, #15]
 858:../LSM9DS1_drivers.c **** 	lsb = offset & 0x00FF;
 3520              		.loc 1 858 0
 3521 0022 BB88     		ldrh	r3, [r7, #4]	@ movhi
 3522 0024 BB73     		strb	r3, [r7, #14]
 859:../LSM9DS1_drivers.c **** 	mWriteByte(OFFSET_X_REG_L_M + (2 * axis), lsb);
 3523              		.loc 1 859 0
 3524 0026 FB79     		ldrb	r3, [r7, #7]
 3525 0028 4FEA4303 		lsl	r3, r3, #1
 3526 002c DBB2     		uxtb	r3, r3
 3527 002e 03F10503 		add	r3, r3, #5
 3528 0032 DAB2     		uxtb	r2, r3
 3529 0034 BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 3530 0036 1046     		mov	r0, r2
 3531 0038 1946     		mov	r1, r3
 3532 003a FFF7FEFF 		bl	mWriteByte
 860:../LSM9DS1_drivers.c **** 	mWriteByte(OFFSET_X_REG_H_M + (2 * axis), msb);
 3533              		.loc 1 860 0
 3534 003e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3535 0040 03F10303 		add	r3, r3, #3
 3536 0044 DBB2     		uxtb	r3, r3
 3537 0046 4FEA4303 		lsl	r3, r3, #1
 3538 004a DAB2     		uxtb	r2, r3
 3539 004c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 3540 004e 1046     		mov	r0, r2
 3541 0050 1946     		mov	r1, r3
 3542 0052 FFF7FEFF 		bl	mWriteByte
 3543 0056 00E0     		b	.L136
 3544              	.L139:
 855:../LSM9DS1_drivers.c **** 		return;
 3545              		.loc 1 855 0
 3546 0058 00BF     		nop
 3547              	.L136:
 861:../LSM9DS1_drivers.c **** }
 3548              		.loc 1 861 0
 3549 005a 07F11007 		add	r7, r7, #16
 3550 005e BD46     		mov	sp, r7
 3551 0060 80BD     		pop	{r7, pc}
 3552              		.cfi_endproc
 3553              	.LFE143:
 3555 0062 00BF     		.section	.text.accelAvailable,"ax",%progbits
 3556              		.align	2
 3557              		.global	accelAvailable
 3558              		.thumb
 3559              		.thumb_func
 3561              	accelAvailable:
 3562              	.LFB144:
 862:../LSM9DS1_drivers.c **** 
 863:../LSM9DS1_drivers.c **** uint8_t accelAvailable(void)
 864:../LSM9DS1_drivers.c **** {
 3563              		.loc 1 864 0
 3564              		.cfi_startproc
 3565              		@ args = 0, pretend = 0, frame = 8
 3566              		@ frame_needed = 1, uses_anonymous_args = 0
 3567 0000 80B5     		push	{r7, lr}
 3568              	.LCFI90:
 3569              		.cfi_def_cfa_offset 8
 3570              		.cfi_offset 7, -8
 3571              		.cfi_offset 14, -4
 3572 0002 82B0     		sub	sp, sp, #8
 3573              	.LCFI91:
 3574              		.cfi_def_cfa_offset 16
 3575 0004 00AF     		add	r7, sp, #0
 3576              	.LCFI92:
 3577              		.cfi_def_cfa_register 7
 865:../LSM9DS1_drivers.c **** 	uint8_t status = xgReadByte(STATUS_REG_1);
 3578              		.loc 1 865 0
 3579 0006 4FF02700 		mov	r0, #39
 3580 000a FFF7FEFF 		bl	xgReadByte
 3581 000e 0346     		mov	r3, r0
 3582 0010 FB71     		strb	r3, [r7, #7]
 866:../LSM9DS1_drivers.c **** 
 867:../LSM9DS1_drivers.c **** 	return (status & (1<<0));
 3583              		.loc 1 867 0
 3584 0012 FB79     		ldrb	r3, [r7, #7]
 3585 0014 03F00103 		and	r3, r3, #1
 3586 0018 DBB2     		uxtb	r3, r3
 868:../LSM9DS1_drivers.c **** }
 3587              		.loc 1 868 0
 3588 001a 1846     		mov	r0, r3
 3589 001c 07F10807 		add	r7, r7, #8
 3590 0020 BD46     		mov	sp, r7
 3591 0022 80BD     		pop	{r7, pc}
 3592              		.cfi_endproc
 3593              	.LFE144:
 3595              		.section	.text.gyroAvailable,"ax",%progbits
 3596              		.align	2
 3597              		.global	gyroAvailable
 3598              		.thumb
 3599              		.thumb_func
 3601              	gyroAvailable:
 3602              	.LFB145:
 869:../LSM9DS1_drivers.c **** 
 870:../LSM9DS1_drivers.c **** uint8_t gyroAvailable(void)
 871:../LSM9DS1_drivers.c **** {
 3603              		.loc 1 871 0
 3604              		.cfi_startproc
 3605              		@ args = 0, pretend = 0, frame = 8
 3606              		@ frame_needed = 1, uses_anonymous_args = 0
 3607 0000 80B5     		push	{r7, lr}
 3608              	.LCFI93:
 3609              		.cfi_def_cfa_offset 8
 3610              		.cfi_offset 7, -8
 3611              		.cfi_offset 14, -4
 3612 0002 82B0     		sub	sp, sp, #8
 3613              	.LCFI94:
 3614              		.cfi_def_cfa_offset 16
 3615 0004 00AF     		add	r7, sp, #0
 3616              	.LCFI95:
 3617              		.cfi_def_cfa_register 7
 872:../LSM9DS1_drivers.c **** 	uint8_t status = xgReadByte(STATUS_REG_1);
 3618              		.loc 1 872 0
 3619 0006 4FF02700 		mov	r0, #39
 3620 000a FFF7FEFF 		bl	xgReadByte
 3621 000e 0346     		mov	r3, r0
 3622 0010 FB71     		strb	r3, [r7, #7]
 873:../LSM9DS1_drivers.c **** 
 874:../LSM9DS1_drivers.c **** 	return ((status & (1<<1)) >> 1);
 3623              		.loc 1 874 0
 3624 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3625 0014 03F00203 		and	r3, r3, #2
 3626 0018 4FEA6303 		asr	r3, r3, #1
 3627 001c DBB2     		uxtb	r3, r3
 875:../LSM9DS1_drivers.c **** }
 3628              		.loc 1 875 0
 3629 001e 1846     		mov	r0, r3
 3630 0020 07F10807 		add	r7, r7, #8
 3631 0024 BD46     		mov	sp, r7
 3632 0026 80BD     		pop	{r7, pc}
 3633              		.cfi_endproc
 3634              	.LFE145:
 3636              		.section	.text.tempAvailable,"ax",%progbits
 3637              		.align	2
 3638              		.global	tempAvailable
 3639              		.thumb
 3640              		.thumb_func
 3642              	tempAvailable:
 3643              	.LFB146:
 876:../LSM9DS1_drivers.c **** 
 877:../LSM9DS1_drivers.c **** uint8_t tempAvailable(void)
 878:../LSM9DS1_drivers.c **** {
 3644              		.loc 1 878 0
 3645              		.cfi_startproc
 3646              		@ args = 0, pretend = 0, frame = 8
 3647              		@ frame_needed = 1, uses_anonymous_args = 0
 3648 0000 80B5     		push	{r7, lr}
 3649              	.LCFI96:
 3650              		.cfi_def_cfa_offset 8
 3651              		.cfi_offset 7, -8
 3652              		.cfi_offset 14, -4
 3653 0002 82B0     		sub	sp, sp, #8
 3654              	.LCFI97:
 3655              		.cfi_def_cfa_offset 16
 3656 0004 00AF     		add	r7, sp, #0
 3657              	.LCFI98:
 3658              		.cfi_def_cfa_register 7
 879:../LSM9DS1_drivers.c **** 	uint8_t status = xgReadByte(STATUS_REG_1);
 3659              		.loc 1 879 0
 3660 0006 4FF02700 		mov	r0, #39
 3661 000a FFF7FEFF 		bl	xgReadByte
 3662 000e 0346     		mov	r3, r0
 3663 0010 FB71     		strb	r3, [r7, #7]
 880:../LSM9DS1_drivers.c **** 
 881:../LSM9DS1_drivers.c **** 	return ((status & (1<<2)) >> 2);
 3664              		.loc 1 881 0
 3665 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3666 0014 03F00403 		and	r3, r3, #4
 3667 0018 4FEAA303 		asr	r3, r3, #2
 3668 001c DBB2     		uxtb	r3, r3
 882:../LSM9DS1_drivers.c **** }
 3669              		.loc 1 882 0
 3670 001e 1846     		mov	r0, r3
 3671 0020 07F10807 		add	r7, r7, #8
 3672 0024 BD46     		mov	sp, r7
 3673 0026 80BD     		pop	{r7, pc}
 3674              		.cfi_endproc
 3675              	.LFE146:
 3677              		.section	.text.readAccel,"ax",%progbits
 3678              		.align	2
 3679              		.global	readAccel
 3680              		.thumb
 3681              		.thumb_func
 3683              	readAccel:
 3684              	.LFB147:
 883:../LSM9DS1_drivers.c **** 
 884:../LSM9DS1_drivers.c **** int16_t readAccel(lsm9ds1_axis axis)
 885:../LSM9DS1_drivers.c **** {
 3685              		.loc 1 885 0
 3686              		.cfi_startproc
 3687              		@ args = 0, pretend = 0, frame = 16
 3688              		@ frame_needed = 1, uses_anonymous_args = 0
 3689 0000 80B5     		push	{r7, lr}
 3690              	.LCFI99:
 3691              		.cfi_def_cfa_offset 8
 3692              		.cfi_offset 7, -8
 3693              		.cfi_offset 14, -4
 3694 0002 84B0     		sub	sp, sp, #16
 3695              	.LCFI100:
 3696              		.cfi_def_cfa_offset 24
 3697 0004 00AF     		add	r7, sp, #0
 3698              	.LCFI101:
 3699              		.cfi_def_cfa_register 7
 3700 0006 0346     		mov	r3, r0
 3701 0008 FB71     		strb	r3, [r7, #7]
 886:../LSM9DS1_drivers.c **** 	uint8_t temp[2];
 887:../LSM9DS1_drivers.c **** 	int16_t value;
 888:../LSM9DS1_drivers.c **** 	xgReadBytes(OUT_X_L_XL + (2 * axis), temp, 2);
 3702              		.loc 1 888 0
 3703 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3704 000c 03F11403 		add	r3, r3, #20
 3705 0010 DBB2     		uxtb	r3, r3
 3706 0012 4FEA4303 		lsl	r3, r3, #1
 3707 0016 DAB2     		uxtb	r2, r3
 3708 0018 07F10C03 		add	r3, r7, #12
 3709 001c 1046     		mov	r0, r2
 3710 001e 1946     		mov	r1, r3
 3711 0020 4FF00202 		mov	r2, #2
 3712 0024 FFF7FEFF 		bl	xgReadBytes
 889:../LSM9DS1_drivers.c **** 	value = (temp[1] << 8) | temp[0];
 3713              		.loc 1 889 0
 3714 0028 7B7B     		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 3715 002a 4FEA0323 		lsl	r3, r3, #8
 3716 002e 9AB2     		uxth	r2, r3
 3717 0030 3B7B     		ldrb	r3, [r7, #12]	@ zero_extendqisi2
 3718 0032 1343     		orrs	r3, r3, r2
 3719 0034 FB81     		strh	r3, [r7, #14]	@ movhi
 890:../LSM9DS1_drivers.c **** 
 891:../LSM9DS1_drivers.c **** 	if (_autoCalc)
 3720              		.loc 1 891 0
 3721 0036 40F20003 		movw	r3, #:lower16:_autoCalc
 3722 003a C0F20003 		movt	r3, #:upper16:_autoCalc
 3723 003e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3724 0040 002B     		cmp	r3, #0
 3725 0042 0BD0     		beq	.L147
 892:../LSM9DS1_drivers.c **** 		value -= aBiasRaw[axis];
 3726              		.loc 1 892 0
 3727 0044 FA89     		ldrh	r2, [r7, #14]
 3728 0046 F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 3729 0048 40F20003 		movw	r3, #:lower16:aBiasRaw
 3730 004c C0F20003 		movt	r3, #:upper16:aBiasRaw
 3731 0050 33F81130 		ldrh	r3, [r3, r1, lsl #1]
 3732 0054 9BB2     		uxth	r3, r3
 3733 0056 D31A     		subs	r3, r2, r3
 3734 0058 9BB2     		uxth	r3, r3
 3735 005a FB81     		strh	r3, [r7, #14]	@ movhi
 3736              	.L147:
 893:../LSM9DS1_drivers.c **** 
 894:../LSM9DS1_drivers.c **** 	return value;
 3737              		.loc 1 894 0
 3738 005c FB89     		ldrh	r3, [r7, #14]
 3739 005e 1BB2     		sxth	r3, r3
 895:../LSM9DS1_drivers.c **** }
 3740              		.loc 1 895 0
 3741 0060 1846     		mov	r0, r3
 3742 0062 07F11007 		add	r7, r7, #16
 3743 0066 BD46     		mov	sp, r7
 3744 0068 80BD     		pop	{r7, pc}
 3745              		.cfi_endproc
 3746              	.LFE147:
 3748 006a 00BF     		.section	.text.readMag,"ax",%progbits
 3749              		.align	2
 3750              		.global	readMag
 3751              		.thumb
 3752              		.thumb_func
 3754              	readMag:
 3755              	.LFB148:
 896:../LSM9DS1_drivers.c **** 
 897:../LSM9DS1_drivers.c **** int16_t readMag(lsm9ds1_axis axis)
 898:../LSM9DS1_drivers.c **** {
 3756              		.loc 1 898 0
 3757              		.cfi_startproc
 3758              		@ args = 0, pretend = 0, frame = 16
 3759              		@ frame_needed = 1, uses_anonymous_args = 0
 3760 0000 80B5     		push	{r7, lr}
 3761              	.LCFI102:
 3762              		.cfi_def_cfa_offset 8
 3763              		.cfi_offset 7, -8
 3764              		.cfi_offset 14, -4
 3765 0002 84B0     		sub	sp, sp, #16
 3766              	.LCFI103:
 3767              		.cfi_def_cfa_offset 24
 3768 0004 00AF     		add	r7, sp, #0
 3769              	.LCFI104:
 3770              		.cfi_def_cfa_register 7
 3771 0006 0346     		mov	r3, r0
 3772 0008 FB71     		strb	r3, [r7, #7]
 899:../LSM9DS1_drivers.c **** 	uint8_t temp[2];
 900:../LSM9DS1_drivers.c **** 	mReadBytes(OUT_X_L_M + (2 * axis), temp, 2);
 3773              		.loc 1 900 0
 3774 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3775 000c 03F11403 		add	r3, r3, #20
 3776 0010 DBB2     		uxtb	r3, r3
 3777 0012 4FEA4303 		lsl	r3, r3, #1
 3778 0016 DAB2     		uxtb	r2, r3
 3779 0018 07F10C03 		add	r3, r7, #12
 3780 001c 1046     		mov	r0, r2
 3781 001e 1946     		mov	r1, r3
 3782 0020 4FF00202 		mov	r2, #2
 3783 0024 FFF7FEFF 		bl	mReadBytes
 901:../LSM9DS1_drivers.c **** 	return (temp[1] << 8) | temp[0];
 3784              		.loc 1 901 0
 3785 0028 7B7B     		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 3786 002a 4FEA0323 		lsl	r3, r3, #8
 3787 002e 9AB2     		uxth	r2, r3
 3788 0030 3B7B     		ldrb	r3, [r7, #12]	@ zero_extendqisi2
 3789 0032 1343     		orrs	r3, r3, r2
 3790 0034 9BB2     		uxth	r3, r3
 3791 0036 1BB2     		sxth	r3, r3
 902:../LSM9DS1_drivers.c **** }
 3792              		.loc 1 902 0
 3793 0038 1846     		mov	r0, r3
 3794 003a 07F11007 		add	r7, r7, #16
 3795 003e BD46     		mov	sp, r7
 3796 0040 80BD     		pop	{r7, pc}
 3797              		.cfi_endproc
 3798              	.LFE148:
 3800 0042 00BF     		.section	.text.readTemp,"ax",%progbits
 3801              		.align	2
 3802              		.global	readTemp
 3803              		.thumb
 3804              		.thumb_func
 3806              	readTemp:
 3807              	.LFB149:
 903:../LSM9DS1_drivers.c **** 
 904:../LSM9DS1_drivers.c **** void readTemp(void)
 905:../LSM9DS1_drivers.c **** {
 3808              		.loc 1 905 0
 3809              		.cfi_startproc
 3810              		@ args = 0, pretend = 0, frame = 8
 3811              		@ frame_needed = 1, uses_anonymous_args = 0
 3812 0000 80B5     		push	{r7, lr}
 3813              	.LCFI105:
 3814              		.cfi_def_cfa_offset 8
 3815              		.cfi_offset 7, -8
 3816              		.cfi_offset 14, -4
 3817 0002 82B0     		sub	sp, sp, #8
 3818              	.LCFI106:
 3819              		.cfi_def_cfa_offset 16
 3820 0004 00AF     		add	r7, sp, #0
 3821              	.LCFI107:
 3822              		.cfi_def_cfa_register 7
 906:../LSM9DS1_drivers.c **** 	uint8_t temp[2]; // We'll read two bytes from the temperature sensor into temp
 907:../LSM9DS1_drivers.c **** 	xgReadBytes(OUT_TEMP_L, temp, 2); // Read 2 bytes, beginning at OUT_TEMP_L
 3823              		.loc 1 907 0
 3824 0006 07F10403 		add	r3, r7, #4
 3825 000a 4FF01500 		mov	r0, #21
 3826 000e 1946     		mov	r1, r3
 3827 0010 4FF00202 		mov	r2, #2
 3828 0014 FFF7FEFF 		bl	xgReadBytes
 908:../LSM9DS1_drivers.c **** 	temperature = ((int16_t)temp[1] << 8) | temp[0];
 3829              		.loc 1 908 0
 3830 0018 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 3831 001a 4FEA0323 		lsl	r3, r3, #8
 3832 001e 9AB2     		uxth	r2, r3
 3833 0020 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 3834 0022 1343     		orrs	r3, r3, r2
 3835 0024 9AB2     		uxth	r2, r3
 3836 0026 40F20003 		movw	r3, #:lower16:temperature
 3837 002a C0F20003 		movt	r3, #:upper16:temperature
 3838 002e 1A80     		strh	r2, [r3, #0]	@ movhi
 909:../LSM9DS1_drivers.c **** }
 3839              		.loc 1 909 0
 3840 0030 07F10807 		add	r7, r7, #8
 3841 0034 BD46     		mov	sp, r7
 3842 0036 80BD     		pop	{r7, pc}
 3843              		.cfi_endproc
 3844              	.LFE149:
 3846              		.section	.text.readGyro,"ax",%progbits
 3847              		.align	2
 3848              		.global	readGyro
 3849              		.thumb
 3850              		.thumb_func
 3852              	readGyro:
 3853              	.LFB150:
 910:../LSM9DS1_drivers.c **** 
 911:../LSM9DS1_drivers.c **** int16_t readGyro(lsm9ds1_axis axis)
 912:../LSM9DS1_drivers.c **** {
 3854              		.loc 1 912 0
 3855              		.cfi_startproc
 3856              		@ args = 0, pretend = 0, frame = 16
 3857              		@ frame_needed = 1, uses_anonymous_args = 0
 3858 0000 80B5     		push	{r7, lr}
 3859              	.LCFI108:
 3860              		.cfi_def_cfa_offset 8
 3861              		.cfi_offset 7, -8
 3862              		.cfi_offset 14, -4
 3863 0002 84B0     		sub	sp, sp, #16
 3864              	.LCFI109:
 3865              		.cfi_def_cfa_offset 24
 3866 0004 00AF     		add	r7, sp, #0
 3867              	.LCFI110:
 3868              		.cfi_def_cfa_register 7
 3869 0006 0346     		mov	r3, r0
 3870 0008 FB71     		strb	r3, [r7, #7]
 913:../LSM9DS1_drivers.c **** 	uint8_t temp[2];
 914:../LSM9DS1_drivers.c **** 	int16_t value;
 915:../LSM9DS1_drivers.c **** 
 916:../LSM9DS1_drivers.c **** 	xgReadBytes(OUT_X_L_G + (2 * axis), temp, 2);
 3871              		.loc 1 916 0
 3872 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3873 000c 03F10C03 		add	r3, r3, #12
 3874 0010 DBB2     		uxtb	r3, r3
 3875 0012 4FEA4303 		lsl	r3, r3, #1
 3876 0016 DAB2     		uxtb	r2, r3
 3877 0018 07F10C03 		add	r3, r7, #12
 3878 001c 1046     		mov	r0, r2
 3879 001e 1946     		mov	r1, r3
 3880 0020 4FF00202 		mov	r2, #2
 3881 0024 FFF7FEFF 		bl	xgReadBytes
 917:../LSM9DS1_drivers.c **** 
 918:../LSM9DS1_drivers.c **** 	value = (temp[1] << 8) | temp[0];
 3882              		.loc 1 918 0
 3883 0028 7B7B     		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 3884 002a 4FEA0323 		lsl	r3, r3, #8
 3885 002e 9AB2     		uxth	r2, r3
 3886 0030 3B7B     		ldrb	r3, [r7, #12]	@ zero_extendqisi2
 3887 0032 1343     		orrs	r3, r3, r2
 3888 0034 FB81     		strh	r3, [r7, #14]	@ movhi
 919:../LSM9DS1_drivers.c **** 
 920:../LSM9DS1_drivers.c **** 	if (_autoCalc)
 3889              		.loc 1 920 0
 3890 0036 40F20003 		movw	r3, #:lower16:_autoCalc
 3891 003a C0F20003 		movt	r3, #:upper16:_autoCalc
 3892 003e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3893 0040 002B     		cmp	r3, #0
 3894 0042 0BD0     		beq	.L153
 921:../LSM9DS1_drivers.c **** 		value -= gBiasRaw[axis];
 3895              		.loc 1 921 0
 3896 0044 FA89     		ldrh	r2, [r7, #14]
 3897 0046 F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 3898 0048 40F20003 		movw	r3, #:lower16:gBiasRaw
 3899 004c C0F20003 		movt	r3, #:upper16:gBiasRaw
 3900 0050 33F81130 		ldrh	r3, [r3, r1, lsl #1]
 3901 0054 9BB2     		uxth	r3, r3
 3902 0056 D31A     		subs	r3, r2, r3
 3903 0058 9BB2     		uxth	r3, r3
 3904 005a FB81     		strh	r3, [r7, #14]	@ movhi
 3905              	.L153:
 922:../LSM9DS1_drivers.c **** 
 923:../LSM9DS1_drivers.c **** 	return value;
 3906              		.loc 1 923 0
 3907 005c FB89     		ldrh	r3, [r7, #14]
 3908 005e 1BB2     		sxth	r3, r3
 924:../LSM9DS1_drivers.c **** }
 3909              		.loc 1 924 0
 3910 0060 1846     		mov	r0, r3
 3911 0062 07F11007 		add	r7, r7, #16
 3912 0066 BD46     		mov	sp, r7
 3913 0068 80BD     		pop	{r7, pc}
 3914              		.cfi_endproc
 3915              	.LFE150:
 3917 006a 00BF     		.section	.text.calcGyro,"ax",%progbits
 3918              		.align	2
 3919              		.global	calcGyro
 3920              		.thumb
 3921              		.thumb_func
 3923              	calcGyro:
 3924              	.LFB151:
 925:../LSM9DS1_drivers.c **** 
 926:../LSM9DS1_drivers.c **** float calcGyro(int16_t gyro)
 927:../LSM9DS1_drivers.c **** {
 3925              		.loc 1 927 0
 3926              		.cfi_startproc
 3927              		@ args = 0, pretend = 0, frame = 8
 3928              		@ frame_needed = 1, uses_anonymous_args = 0
 3929 0000 80B5     		push	{r7, lr}
 3930              	.LCFI111:
 3931              		.cfi_def_cfa_offset 8
 3932              		.cfi_offset 7, -8
 3933              		.cfi_offset 14, -4
 3934 0002 82B0     		sub	sp, sp, #8
 3935              	.LCFI112:
 3936              		.cfi_def_cfa_offset 16
 3937 0004 00AF     		add	r7, sp, #0
 3938              	.LCFI113:
 3939              		.cfi_def_cfa_register 7
 3940 0006 0346     		mov	r3, r0
 3941 0008 FB80     		strh	r3, [r7, #6]	@ movhi
 928:../LSM9DS1_drivers.c **** 	// Return the gyro raw reading times our pre-calculated DPS / (ADC tick):
 929:../LSM9DS1_drivers.c **** 	return round(gRes * gyro);
 3942              		.loc 1 929 0
 3943 000a B7F90630 		ldrsh	r3, [r7, #6]
 3944 000e 07EE903A 		fmsr	s15, r3	@ int
 3945 0012 B8EEE77A 		fsitos	s14, s15
 3946 0016 40F20003 		movw	r3, #:lower16:gRes
 3947 001a C0F20003 		movt	r3, #:upper16:gRes
 3948 001e D3ED007A 		flds	s15, [r3, #0]
 3949 0022 67EE277A 		fmuls	s15, s14, s15
 3950 0026 17EE900A 		fmrs	r0, s15
 3951 002a FFF7FEFF 		bl	__aeabi_f2d
 3952 002e 0246     		mov	r2, r0
 3953 0030 0B46     		mov	r3, r1
 3954 0032 1046     		mov	r0, r2
 3955 0034 1946     		mov	r1, r3
 3956 0036 FFF7FEFF 		bl	round
 3957 003a 0246     		mov	r2, r0
 3958 003c 0B46     		mov	r3, r1
 3959 003e 1046     		mov	r0, r2
 3960 0040 1946     		mov	r1, r3
 3961 0042 FFF7FEFF 		bl	__aeabi_d2f
 3962 0046 0346     		mov	r3, r0	@ float
 930:../LSM9DS1_drivers.c **** }
 3963              		.loc 1 930 0
 3964 0048 1846     		mov	r0, r3	@ float
 3965 004a 07F10807 		add	r7, r7, #8
 3966 004e BD46     		mov	sp, r7
 3967 0050 80BD     		pop	{r7, pc}
 3968              		.cfi_endproc
 3969              	.LFE151:
 3971 0052 00BF     		.section	.text.calcAccel,"ax",%progbits
 3972              		.align	2
 3973              		.global	calcAccel
 3974              		.thumb
 3975              		.thumb_func
 3977              	calcAccel:
 3978              	.LFB152:
 931:../LSM9DS1_drivers.c **** 
 932:../LSM9DS1_drivers.c **** float calcAccel(int16_t accel)
 933:../LSM9DS1_drivers.c **** {
 3979              		.loc 1 933 0
 3980              		.cfi_startproc
 3981              		@ args = 0, pretend = 0, frame = 8
 3982              		@ frame_needed = 1, uses_anonymous_args = 0
 3983 0000 80B5     		push	{r7, lr}
 3984              	.LCFI114:
 3985              		.cfi_def_cfa_offset 8
 3986              		.cfi_offset 7, -8
 3987              		.cfi_offset 14, -4
 3988 0002 82B0     		sub	sp, sp, #8
 3989              	.LCFI115:
 3990              		.cfi_def_cfa_offset 16
 3991 0004 00AF     		add	r7, sp, #0
 3992              	.LCFI116:
 3993              		.cfi_def_cfa_register 7
 3994 0006 0346     		mov	r3, r0
 3995 0008 FB80     		strh	r3, [r7, #6]	@ movhi
 934:../LSM9DS1_drivers.c **** 	// Return the accel raw reading times our pre-calculated g's / (ADC tick):
 935:../LSM9DS1_drivers.c **** 	return round(aRes * accel);
 3996              		.loc 1 935 0
 3997 000a B7F90630 		ldrsh	r3, [r7, #6]
 3998 000e 07EE903A 		fmsr	s15, r3	@ int
 3999 0012 B8EEE77A 		fsitos	s14, s15
 4000 0016 40F20003 		movw	r3, #:lower16:aRes
 4001 001a C0F20003 		movt	r3, #:upper16:aRes
 4002 001e D3ED007A 		flds	s15, [r3, #0]
 4003 0022 67EE277A 		fmuls	s15, s14, s15
 4004 0026 17EE900A 		fmrs	r0, s15
 4005 002a FFF7FEFF 		bl	__aeabi_f2d
 4006 002e 0246     		mov	r2, r0
 4007 0030 0B46     		mov	r3, r1
 4008 0032 1046     		mov	r0, r2
 4009 0034 1946     		mov	r1, r3
 4010 0036 FFF7FEFF 		bl	round
 4011 003a 0246     		mov	r2, r0
 4012 003c 0B46     		mov	r3, r1
 4013 003e 1046     		mov	r0, r2
 4014 0040 1946     		mov	r1, r3
 4015 0042 FFF7FEFF 		bl	__aeabi_d2f
 4016 0046 0346     		mov	r3, r0	@ float
 936:../LSM9DS1_drivers.c **** }
 4017              		.loc 1 936 0
 4018 0048 1846     		mov	r0, r3	@ float
 4019 004a 07F10807 		add	r7, r7, #8
 4020 004e BD46     		mov	sp, r7
 4021 0050 80BD     		pop	{r7, pc}
 4022              		.cfi_endproc
 4023              	.LFE152:
 4025 0052 00BF     		.section	.text.setGyroScale,"ax",%progbits
 4026              		.align	2
 4027              		.global	setGyroScale
 4028              		.thumb
 4029              		.thumb_func
 4031              	setGyroScale:
 4032              	.LFB153:
 937:../LSM9DS1_drivers.c **** 
 938:../LSM9DS1_drivers.c **** 
 939:../LSM9DS1_drivers.c **** void setGyroScale(uint16_t gScl)
 940:../LSM9DS1_drivers.c **** {
 4033              		.loc 1 940 0
 4034              		.cfi_startproc
 4035              		@ args = 0, pretend = 0, frame = 16
 4036              		@ frame_needed = 1, uses_anonymous_args = 0
 4037 0000 80B5     		push	{r7, lr}
 4038              	.LCFI117:
 4039              		.cfi_def_cfa_offset 8
 4040              		.cfi_offset 7, -8
 4041              		.cfi_offset 14, -4
 4042 0002 84B0     		sub	sp, sp, #16
 4043              	.LCFI118:
 4044              		.cfi_def_cfa_offset 24
 4045 0004 00AF     		add	r7, sp, #0
 4046              	.LCFI119:
 4047              		.cfi_def_cfa_register 7
 4048 0006 0346     		mov	r3, r0
 4049 0008 FB80     		strh	r3, [r7, #6]	@ movhi
 941:../LSM9DS1_drivers.c **** 	// Read current value of CTRL_REG1_G:
 942:../LSM9DS1_drivers.c **** 	uint8_t ctrl1RegValue = xgReadByte(CTRL_REG1_G);
 4050              		.loc 1 942 0
 4051 000a 4FF01000 		mov	r0, #16
 4052 000e FFF7FEFF 		bl	xgReadByte
 4053 0012 0346     		mov	r3, r0
 4054 0014 FB73     		strb	r3, [r7, #15]
 943:../LSM9DS1_drivers.c **** 	// Mask out scale bits (3 & 4):
 944:../LSM9DS1_drivers.c **** 	ctrl1RegValue &= 0xE7;
 4055              		.loc 1 944 0
 4056 0016 FB7B     		ldrb	r3, [r7, #15]
 4057 0018 23F01803 		bic	r3, r3, #24
 4058 001c FB73     		strb	r3, [r7, #15]
 945:../LSM9DS1_drivers.c **** 	switch (gScl)
 4059              		.loc 1 945 0
 4060 001e FB88     		ldrh	r3, [r7, #6]
 4061 0020 B3F5FA7F 		cmp	r3, #500
 4062 0024 03D0     		beq	.L161
 4063 0026 B3F5FA6F 		cmp	r3, #2000
 4064 002a 0CD0     		beq	.L162
 4065 002c 17E0     		b	.L164
 4066              	.L161:
 946:../LSM9DS1_drivers.c **** 	{
 947:../LSM9DS1_drivers.c **** 		case 500:
 948:../LSM9DS1_drivers.c **** 			ctrl1RegValue |= (0x1 << 3);
 4067              		.loc 1 948 0
 4068 002e FB7B     		ldrb	r3, [r7, #15]
 4069 0030 43F00803 		orr	r3, r3, #8
 4070 0034 FB73     		strb	r3, [r7, #15]
 949:../LSM9DS1_drivers.c **** 			settings.gyro.scale = 500;
 4071              		.loc 1 949 0
 4072 0036 40F20003 		movw	r3, #:lower16:settings
 4073 003a C0F20003 		movt	r3, #:upper16:settings
 4074 003e 4FF4FA72 		mov	r2, #500
 4075 0042 DA80     		strh	r2, [r3, #6]	@ movhi
 950:../LSM9DS1_drivers.c **** 			break;
 4076              		.loc 1 950 0
 4077 0044 13E0     		b	.L163
 4078              	.L162:
 951:../LSM9DS1_drivers.c **** 		case 2000:
 952:../LSM9DS1_drivers.c **** 			ctrl1RegValue |= (0x3 << 3);
 4079              		.loc 1 952 0
 4080 0046 FB7B     		ldrb	r3, [r7, #15]
 4081 0048 43F01803 		orr	r3, r3, #24
 4082 004c FB73     		strb	r3, [r7, #15]
 953:../LSM9DS1_drivers.c **** 			settings.gyro.scale = 2000;
 4083              		.loc 1 953 0
 4084 004e 40F20003 		movw	r3, #:lower16:settings
 4085 0052 C0F20003 		movt	r3, #:upper16:settings
 4086 0056 4FF4FA62 		mov	r2, #2000
 4087 005a DA80     		strh	r2, [r3, #6]	@ movhi
 954:../LSM9DS1_drivers.c **** 			break;
 4088              		.loc 1 954 0
 4089 005c 07E0     		b	.L163
 4090              	.L164:
 955:../LSM9DS1_drivers.c **** 		default: // Otherwise we'll set it to 245 dps (0x0 << 4)
 956:../LSM9DS1_drivers.c **** 			settings.gyro.scale = 245;
 4091              		.loc 1 956 0
 4092 005e 40F20003 		movw	r3, #:lower16:settings
 4093 0062 C0F20003 		movt	r3, #:upper16:settings
 4094 0066 4FF0F502 		mov	r2, #245
 4095 006a DA80     		strh	r2, [r3, #6]	@ movhi
 957:../LSM9DS1_drivers.c **** 			break;
 4096              		.loc 1 957 0
 4097 006c 00BF     		nop
 4098              	.L163:
 958:../LSM9DS1_drivers.c **** 	}
 959:../LSM9DS1_drivers.c **** 	xgWriteByte(CTRL_REG1_G, ctrl1RegValue);
 4099              		.loc 1 959 0
 4100 006e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 4101 0070 4FF01000 		mov	r0, #16
 4102 0074 1946     		mov	r1, r3
 4103 0076 FFF7FEFF 		bl	xgWriteByte
 960:../LSM9DS1_drivers.c **** 
 961:../LSM9DS1_drivers.c **** 	calcgRes();
 4104              		.loc 1 961 0
 4105 007a FFF7FEFF 		bl	calcgRes
 962:../LSM9DS1_drivers.c **** }
 4106              		.loc 1 962 0
 4107 007e 07F11007 		add	r7, r7, #16
 4108 0082 BD46     		mov	sp, r7
 4109 0084 80BD     		pop	{r7, pc}
 4110              		.cfi_endproc
 4111              	.LFE153:
 4113 0086 00BF     		.section	.text.setAccelScale,"ax",%progbits
 4114              		.align	2
 4115              		.global	setAccelScale
 4116              		.thumb
 4117              		.thumb_func
 4119              	setAccelScale:
 4120              	.LFB154:
 963:../LSM9DS1_drivers.c **** 
 964:../LSM9DS1_drivers.c **** void setAccelScale(uint8_t aScl)
 965:../LSM9DS1_drivers.c **** {
 4121              		.loc 1 965 0
 4122              		.cfi_startproc
 4123              		@ args = 0, pretend = 0, frame = 16
 4124              		@ frame_needed = 1, uses_anonymous_args = 0
 4125 0000 80B5     		push	{r7, lr}
 4126              	.LCFI120:
 4127              		.cfi_def_cfa_offset 8
 4128              		.cfi_offset 7, -8
 4129              		.cfi_offset 14, -4
 4130 0002 84B0     		sub	sp, sp, #16
 4131              	.LCFI121:
 4132              		.cfi_def_cfa_offset 24
 4133 0004 00AF     		add	r7, sp, #0
 4134              	.LCFI122:
 4135              		.cfi_def_cfa_register 7
 4136 0006 0346     		mov	r3, r0
 4137 0008 FB71     		strb	r3, [r7, #7]
 966:../LSM9DS1_drivers.c **** 	// We need to preserve the other bytes in CTRL_REG6_XL. So, first read it:
 967:../LSM9DS1_drivers.c **** 	uint8_t tempRegValue = xgReadByte(CTRL_REG6_XL);
 4138              		.loc 1 967 0
 4139 000a 4FF02000 		mov	r0, #32
 4140 000e FFF7FEFF 		bl	xgReadByte
 4141 0012 0346     		mov	r3, r0
 4142 0014 FB73     		strb	r3, [r7, #15]
 968:../LSM9DS1_drivers.c **** 	// Mask out accel scale bits:
 969:../LSM9DS1_drivers.c **** 	tempRegValue &= 0xE7;
 4143              		.loc 1 969 0
 4144 0016 FB7B     		ldrb	r3, [r7, #15]
 4145 0018 23F01803 		bic	r3, r3, #24
 4146 001c FB73     		strb	r3, [r7, #15]
 970:../LSM9DS1_drivers.c **** 
 971:../LSM9DS1_drivers.c **** 	switch (aScl)
 4147              		.loc 1 971 0
 4148 001e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4149 0020 082B     		cmp	r3, #8
 4150 0022 0FD0     		beq	.L168
 4151 0024 102B     		cmp	r3, #16
 4152 0026 19D0     		beq	.L169
 4153 0028 042B     		cmp	r3, #4
 4154 002a 23D1     		bne	.L171
 4155              	.L167:
 972:../LSM9DS1_drivers.c **** 	{
 973:../LSM9DS1_drivers.c **** 		case 4:
 974:../LSM9DS1_drivers.c **** 			tempRegValue |= (0x2 << 3);
 4156              		.loc 1 974 0
 4157 002c FB7B     		ldrb	r3, [r7, #15]
 4158 002e 43F01003 		orr	r3, r3, #16
 4159 0032 FB73     		strb	r3, [r7, #15]
 975:../LSM9DS1_drivers.c **** 			settings.accel.scale = 4;
 4160              		.loc 1 975 0
 4161 0034 40F20003 		movw	r3, #:lower16:settings
 4162 0038 C0F20003 		movt	r3, #:upper16:settings
 4163 003c 4FF00402 		mov	r2, #4
 4164 0040 DA75     		strb	r2, [r3, #23]
 976:../LSM9DS1_drivers.c **** 			break;
 4165              		.loc 1 976 0
 4166 0042 1FE0     		b	.L170
 4167              	.L168:
 977:../LSM9DS1_drivers.c **** 		case 8:
 978:../LSM9DS1_drivers.c **** 			tempRegValue |= (0x3 << 3);
 4168              		.loc 1 978 0
 4169 0044 FB7B     		ldrb	r3, [r7, #15]
 4170 0046 43F01803 		orr	r3, r3, #24
 4171 004a FB73     		strb	r3, [r7, #15]
 979:../LSM9DS1_drivers.c **** 			settings.accel.scale = 8;
 4172              		.loc 1 979 0
 4173 004c 40F20003 		movw	r3, #:lower16:settings
 4174 0050 C0F20003 		movt	r3, #:upper16:settings
 4175 0054 4FF00802 		mov	r2, #8
 4176 0058 DA75     		strb	r2, [r3, #23]
 980:../LSM9DS1_drivers.c **** 			break;
 4177              		.loc 1 980 0
 4178 005a 13E0     		b	.L170
 4179              	.L169:
 981:../LSM9DS1_drivers.c **** 		case 16:
 982:../LSM9DS1_drivers.c **** 			tempRegValue |= (0x1 << 3);
 4180              		.loc 1 982 0
 4181 005c FB7B     		ldrb	r3, [r7, #15]
 4182 005e 43F00803 		orr	r3, r3, #8
 4183 0062 FB73     		strb	r3, [r7, #15]
 983:../LSM9DS1_drivers.c **** 			settings.accel.scale = 16;
 4184              		.loc 1 983 0
 4185 0064 40F20003 		movw	r3, #:lower16:settings
 4186 0068 C0F20003 		movt	r3, #:upper16:settings
 4187 006c 4FF01002 		mov	r2, #16
 4188 0070 DA75     		strb	r2, [r3, #23]
 984:../LSM9DS1_drivers.c **** 			break;
 4189              		.loc 1 984 0
 4190 0072 07E0     		b	.L170
 4191              	.L171:
 985:../LSM9DS1_drivers.c **** 		default: // Otherwise it'll be set to 2g (0x0 << 3)
 986:../LSM9DS1_drivers.c **** 			settings.accel.scale = 2;
 4192              		.loc 1 986 0
 4193 0074 40F20003 		movw	r3, #:lower16:settings
 4194 0078 C0F20003 		movt	r3, #:upper16:settings
 4195 007c 4FF00202 		mov	r2, #2
 4196 0080 DA75     		strb	r2, [r3, #23]
 987:../LSM9DS1_drivers.c **** 			break;
 4197              		.loc 1 987 0
 4198 0082 00BF     		nop
 4199              	.L170:
 988:../LSM9DS1_drivers.c **** 	}
 989:../LSM9DS1_drivers.c **** 	xgWriteByte(CTRL_REG6_XL, tempRegValue);
 4200              		.loc 1 989 0
 4201 0084 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 4202 0086 4FF02000 		mov	r0, #32
 4203 008a 1946     		mov	r1, r3
 4204 008c FFF7FEFF 		bl	xgWriteByte
 990:../LSM9DS1_drivers.c **** 
 991:../LSM9DS1_drivers.c **** 	// Then calculate a new aRes, which relies on aScale being set correctly:
 992:../LSM9DS1_drivers.c **** 	calcaRes();
 4205              		.loc 1 992 0
 4206 0090 FFF7FEFF 		bl	calcaRes
 993:../LSM9DS1_drivers.c **** }
 4207              		.loc 1 993 0
 4208 0094 07F11007 		add	r7, r7, #16
 4209 0098 BD46     		mov	sp, r7
 4210 009a 80BD     		pop	{r7, pc}
 4211              		.cfi_endproc
 4212              	.LFE154:
 4214              		.section	.text.setMagScale,"ax",%progbits
 4215              		.align	2
 4216              		.global	setMagScale
 4217              		.thumb
 4218              		.thumb_func
 4220              	setMagScale:
 4221              	.LFB155:
 994:../LSM9DS1_drivers.c **** 
 995:../LSM9DS1_drivers.c **** void setMagScale(uint8_t mScl)
 996:../LSM9DS1_drivers.c **** {
 4222              		.loc 1 996 0
 4223              		.cfi_startproc
 4224              		@ args = 0, pretend = 0, frame = 16
 4225              		@ frame_needed = 1, uses_anonymous_args = 0
 4226 0000 80B5     		push	{r7, lr}
 4227              	.LCFI123:
 4228              		.cfi_def_cfa_offset 8
 4229              		.cfi_offset 7, -8
 4230              		.cfi_offset 14, -4
 4231 0002 84B0     		sub	sp, sp, #16
 4232              	.LCFI124:
 4233              		.cfi_def_cfa_offset 24
 4234 0004 00AF     		add	r7, sp, #0
 4235              	.LCFI125:
 4236              		.cfi_def_cfa_register 7
 4237 0006 0346     		mov	r3, r0
 4238 0008 FB71     		strb	r3, [r7, #7]
 997:../LSM9DS1_drivers.c **** 	// We need to preserve the other bytes in CTRL_REG6_XM. So, first read it:
 998:../LSM9DS1_drivers.c **** 	uint8_t temp = mReadByte(CTRL_REG2_M);
 4239              		.loc 1 998 0
 4240 000a 4FF02100 		mov	r0, #33
 4241 000e FFF7FEFF 		bl	mReadByte
 4242 0012 0346     		mov	r3, r0
 4243 0014 FB73     		strb	r3, [r7, #15]
 999:../LSM9DS1_drivers.c **** 	// Then mask out the mag scale bits:
1000:../LSM9DS1_drivers.c **** 	temp &= 0xFF^(0x3 << 5);
 4244              		.loc 1 1000 0
 4245 0016 FB7B     		ldrb	r3, [r7, #15]
 4246 0018 23F06003 		bic	r3, r3, #96
 4247 001c FB73     		strb	r3, [r7, #15]
1001:../LSM9DS1_drivers.c **** 
1002:../LSM9DS1_drivers.c **** 	switch (mScl)
 4248              		.loc 1 1002 0
 4249 001e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4250 0020 0C2B     		cmp	r3, #12
 4251 0022 10D0     		beq	.L175
 4252 0024 102B     		cmp	r3, #16
 4253 0026 1BD0     		beq	.L176
 4254 0028 082B     		cmp	r3, #8
 4255 002a 26D1     		bne	.L178
 4256              	.L174:
1003:../LSM9DS1_drivers.c **** 	{
1004:../LSM9DS1_drivers.c **** 		case 8:
1005:../LSM9DS1_drivers.c **** 			temp |= (0x1 << 5);
 4257              		.loc 1 1005 0
 4258 002c FB7B     		ldrb	r3, [r7, #15]
 4259 002e 43F02003 		orr	r3, r3, #32
 4260 0032 FB73     		strb	r3, [r7, #15]
1006:../LSM9DS1_drivers.c **** 			settings.mag.scale = 8;
 4261              		.loc 1 1006 0
 4262 0034 40F20003 		movw	r3, #:lower16:settings
 4263 0038 C0F20003 		movt	r3, #:upper16:settings
 4264 003c 4FF00802 		mov	r2, #8
 4265 0040 83F82020 		strb	r2, [r3, #32]
1007:../LSM9DS1_drivers.c **** 			break;
 4266              		.loc 1 1007 0
 4267 0044 22E0     		b	.L177
 4268              	.L175:
1008:../LSM9DS1_drivers.c **** 		case 12:
1009:../LSM9DS1_drivers.c **** 			temp |= (0x2 << 5);
 4269              		.loc 1 1009 0
 4270 0046 FB7B     		ldrb	r3, [r7, #15]
 4271 0048 43F04003 		orr	r3, r3, #64
 4272 004c FB73     		strb	r3, [r7, #15]
1010:../LSM9DS1_drivers.c **** 			settings.mag.scale = 12;
 4273              		.loc 1 1010 0
 4274 004e 40F20003 		movw	r3, #:lower16:settings
 4275 0052 C0F20003 		movt	r3, #:upper16:settings
 4276 0056 4FF00C02 		mov	r2, #12
 4277 005a 83F82020 		strb	r2, [r3, #32]
1011:../LSM9DS1_drivers.c **** 			break;
 4278              		.loc 1 1011 0
 4279 005e 15E0     		b	.L177
 4280              	.L176:
1012:../LSM9DS1_drivers.c **** 		case 16:
1013:../LSM9DS1_drivers.c **** 			temp |= (0x3 << 5);
 4281              		.loc 1 1013 0
 4282 0060 FB7B     		ldrb	r3, [r7, #15]
 4283 0062 43F06003 		orr	r3, r3, #96
 4284 0066 FB73     		strb	r3, [r7, #15]
1014:../LSM9DS1_drivers.c **** 			settings.mag.scale = 16;
 4285              		.loc 1 1014 0
 4286 0068 40F20003 		movw	r3, #:lower16:settings
 4287 006c C0F20003 		movt	r3, #:upper16:settings
 4288 0070 4FF01002 		mov	r2, #16
 4289 0074 83F82020 		strb	r2, [r3, #32]
1015:../LSM9DS1_drivers.c **** 			break;
 4290              		.loc 1 1015 0
 4291 0078 08E0     		b	.L177
 4292              	.L178:
1016:../LSM9DS1_drivers.c **** 		default: // Otherwise we'll default to 4 gauss (00)
1017:../LSM9DS1_drivers.c **** 			settings.mag.scale = 4;
 4293              		.loc 1 1017 0
 4294 007a 40F20003 		movw	r3, #:lower16:settings
 4295 007e C0F20003 		movt	r3, #:upper16:settings
 4296 0082 4FF00402 		mov	r2, #4
 4297 0086 83F82020 		strb	r2, [r3, #32]
1018:../LSM9DS1_drivers.c **** 			break;
 4298              		.loc 1 1018 0
 4299 008a 00BF     		nop
 4300              	.L177:
1019:../LSM9DS1_drivers.c **** 	}
1020:../LSM9DS1_drivers.c **** 
1021:../LSM9DS1_drivers.c **** 	// And write the new register value back into CTRL_REG6_XM:
1022:../LSM9DS1_drivers.c **** 	mWriteByte(CTRL_REG2_M, temp);
 4301              		.loc 1 1022 0
 4302 008c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 4303 008e 4FF02100 		mov	r0, #33
 4304 0092 1946     		mov	r1, r3
 4305 0094 FFF7FEFF 		bl	mWriteByte
1023:../LSM9DS1_drivers.c **** 
1024:../LSM9DS1_drivers.c **** 	// We've updated the sensor, but we also need to update our class variables
1025:../LSM9DS1_drivers.c **** 	// First update mScale:
1026:../LSM9DS1_drivers.c **** 	//mScale = mScl;
1027:../LSM9DS1_drivers.c **** 	// Then calculate a new mRes, which relies on mScale being set correctly:
1028:../LSM9DS1_drivers.c **** 	calcmRes();
 4306              		.loc 1 1028 0
 4307 0098 FFF7FEFF 		bl	calcmRes
1029:../LSM9DS1_drivers.c **** }
 4308              		.loc 1 1029 0
 4309 009c 07F11007 		add	r7, r7, #16
 4310 00a0 BD46     		mov	sp, r7
 4311 00a2 80BD     		pop	{r7, pc}
 4312              		.cfi_endproc
 4313              	.LFE155:
 4315              		.section	.text.setGyroODR,"ax",%progbits
 4316              		.align	2
 4317              		.global	setGyroODR
 4318              		.thumb
 4319              		.thumb_func
 4321              	setGyroODR:
 4322              	.LFB156:
1030:../LSM9DS1_drivers.c **** 
1031:../LSM9DS1_drivers.c **** void setGyroODR(uint8_t gRate)
1032:../LSM9DS1_drivers.c **** {
 4323              		.loc 1 1032 0
 4324              		.cfi_startproc
 4325              		@ args = 0, pretend = 0, frame = 16
 4326              		@ frame_needed = 1, uses_anonymous_args = 0
 4327 0000 80B5     		push	{r7, lr}
 4328              	.LCFI126:
 4329              		.cfi_def_cfa_offset 8
 4330              		.cfi_offset 7, -8
 4331              		.cfi_offset 14, -4
 4332 0002 84B0     		sub	sp, sp, #16
 4333              	.LCFI127:
 4334              		.cfi_def_cfa_offset 24
 4335 0004 00AF     		add	r7, sp, #0
 4336              	.LCFI128:
 4337              		.cfi_def_cfa_register 7
 4338 0006 0346     		mov	r3, r0
 4339 0008 FB71     		strb	r3, [r7, #7]
1033:../LSM9DS1_drivers.c **** 	// Only do this if gRate is not 0 (which would disable the gyro)
1034:../LSM9DS1_drivers.c **** 	if ((gRate & 0x07) != 0)
 4340              		.loc 1 1034 0
 4341 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4342 000c 03F00703 		and	r3, r3, #7
 4343 0010 002B     		cmp	r3, #0
 4344 0012 20D0     		beq	.L179
 4345              	.LBB7:
1035:../LSM9DS1_drivers.c **** 	{
1036:../LSM9DS1_drivers.c **** 		// We need to preserve the other bytes in CTRL_REG1_G. So, first read it:
1037:../LSM9DS1_drivers.c **** 		uint8_t temp = xgReadByte(CTRL_REG1_G);
 4346              		.loc 1 1037 0
 4347 0014 4FF01000 		mov	r0, #16
 4348 0018 FFF7FEFF 		bl	xgReadByte
 4349 001c 0346     		mov	r3, r0
 4350 001e FB73     		strb	r3, [r7, #15]
1038:../LSM9DS1_drivers.c **** 		// Then mask out the gyro ODR bits:
1039:../LSM9DS1_drivers.c **** 		temp &= 0xFF^(0x7 << 5);
 4351              		.loc 1 1039 0
 4352 0020 FB7B     		ldrb	r3, [r7, #15]
 4353 0022 03F01F03 		and	r3, r3, #31
 4354 0026 FB73     		strb	r3, [r7, #15]
1040:../LSM9DS1_drivers.c **** 		temp |= (gRate & 0x07) << 5;
 4355              		.loc 1 1040 0
 4356 0028 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4357 002a 4FEA4313 		lsl	r3, r3, #5
 4358 002e DAB2     		uxtb	r2, r3
 4359 0030 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 4360 0032 1343     		orrs	r3, r3, r2
 4361 0034 DBB2     		uxtb	r3, r3
 4362 0036 FB73     		strb	r3, [r7, #15]
1041:../LSM9DS1_drivers.c **** 		// Update our settings struct
1042:../LSM9DS1_drivers.c **** 		settings.gyro.sampleRate = gRate & 0x07;
 4363              		.loc 1 1042 0
 4364 0038 FB79     		ldrb	r3, [r7, #7]
 4365 003a 03F00703 		and	r3, r3, #7
 4366 003e DAB2     		uxtb	r2, r3
 4367 0040 40F20003 		movw	r3, #:lower16:settings
 4368 0044 C0F20003 		movt	r3, #:upper16:settings
 4369 0048 1A72     		strb	r2, [r3, #8]
1043:../LSM9DS1_drivers.c **** 		// And write the new register value back into CTRL_REG1_G:
1044:../LSM9DS1_drivers.c **** 		xgWriteByte(CTRL_REG1_G, temp);
 4370              		.loc 1 1044 0
 4371 004a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 4372 004c 4FF01000 		mov	r0, #16
 4373 0050 1946     		mov	r1, r3
 4374 0052 FFF7FEFF 		bl	xgWriteByte
 4375              	.L179:
 4376              	.LBE7:
1045:../LSM9DS1_drivers.c **** 	}
1046:../LSM9DS1_drivers.c **** }
 4377              		.loc 1 1046 0
 4378 0056 07F11007 		add	r7, r7, #16
 4379 005a BD46     		mov	sp, r7
 4380 005c 80BD     		pop	{r7, pc}
 4381              		.cfi_endproc
 4382              	.LFE156:
 4384 005e 00BF     		.section	.text.setAccelODR,"ax",%progbits
 4385              		.align	2
 4386              		.global	setAccelODR
 4387              		.thumb
 4388              		.thumb_func
 4390              	setAccelODR:
 4391              	.LFB157:
1047:../LSM9DS1_drivers.c **** 
1048:../LSM9DS1_drivers.c **** void setAccelODR(uint8_t aRate)
1049:../LSM9DS1_drivers.c **** {
 4392              		.loc 1 1049 0
 4393              		.cfi_startproc
 4394              		@ args = 0, pretend = 0, frame = 16
 4395              		@ frame_needed = 1, uses_anonymous_args = 0
 4396 0000 80B5     		push	{r7, lr}
 4397              	.LCFI129:
 4398              		.cfi_def_cfa_offset 8
 4399              		.cfi_offset 7, -8
 4400              		.cfi_offset 14, -4
 4401 0002 84B0     		sub	sp, sp, #16
 4402              	.LCFI130:
 4403              		.cfi_def_cfa_offset 24
 4404 0004 00AF     		add	r7, sp, #0
 4405              	.LCFI131:
 4406              		.cfi_def_cfa_register 7
 4407 0006 0346     		mov	r3, r0
 4408 0008 FB71     		strb	r3, [r7, #7]
1050:../LSM9DS1_drivers.c **** 	// Only do this if aRate is not 0 (which would disable the accel)
1051:../LSM9DS1_drivers.c **** 	if ((aRate & 0x07) != 0)
 4409              		.loc 1 1051 0
 4410 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4411 000c 03F00703 		and	r3, r3, #7
 4412 0010 002B     		cmp	r3, #0
 4413 0012 20D0     		beq	.L181
 4414              	.LBB8:
1052:../LSM9DS1_drivers.c **** 	{
1053:../LSM9DS1_drivers.c **** 		// We need to preserve the other bytes in CTRL_REG1_XM. So, first read it:
1054:../LSM9DS1_drivers.c **** 		uint8_t temp = xgReadByte(CTRL_REG6_XL);
 4415              		.loc 1 1054 0
 4416 0014 4FF02000 		mov	r0, #32
 4417 0018 FFF7FEFF 		bl	xgReadByte
 4418 001c 0346     		mov	r3, r0
 4419 001e FB73     		strb	r3, [r7, #15]
1055:../LSM9DS1_drivers.c **** 		// Then mask out the accel ODR bits:
1056:../LSM9DS1_drivers.c **** 		temp &= 0x1F;
 4420              		.loc 1 1056 0
 4421 0020 FB7B     		ldrb	r3, [r7, #15]
 4422 0022 03F01F03 		and	r3, r3, #31
 4423 0026 FB73     		strb	r3, [r7, #15]
1057:../LSM9DS1_drivers.c **** 		// Then shift in our new ODR bits:
1058:../LSM9DS1_drivers.c **** 		temp |= ((aRate & 0x07) << 5);
 4424              		.loc 1 1058 0
 4425 0028 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4426 002a 4FEA4313 		lsl	r3, r3, #5
 4427 002e DAB2     		uxtb	r2, r3
 4428 0030 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 4429 0032 1343     		orrs	r3, r3, r2
 4430 0034 DBB2     		uxtb	r3, r3
 4431 0036 FB73     		strb	r3, [r7, #15]
1059:../LSM9DS1_drivers.c **** 		settings.accel.sampleRate = aRate & 0x07;
 4432              		.loc 1 1059 0
 4433 0038 FB79     		ldrb	r3, [r7, #7]
 4434 003a 03F00703 		and	r3, r3, #7
 4435 003e DAB2     		uxtb	r2, r3
 4436 0040 40F20003 		movw	r3, #:lower16:settings
 4437 0044 C0F20003 		movt	r3, #:upper16:settings
 4438 0048 1A76     		strb	r2, [r3, #24]
1060:../LSM9DS1_drivers.c **** 		// And write the new register value back into CTRL_REG1_XM:
1061:../LSM9DS1_drivers.c **** 		xgWriteByte(CTRL_REG6_XL, temp);
 4439              		.loc 1 1061 0
 4440 004a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 4441 004c 4FF02000 		mov	r0, #32
 4442 0050 1946     		mov	r1, r3
 4443 0052 FFF7FEFF 		bl	xgWriteByte
 4444              	.L181:
 4445              	.LBE8:
1062:../LSM9DS1_drivers.c **** 	}
1063:../LSM9DS1_drivers.c **** }
 4446              		.loc 1 1063 0
 4447 0056 07F11007 		add	r7, r7, #16
 4448 005a BD46     		mov	sp, r7
 4449 005c 80BD     		pop	{r7, pc}
 4450              		.cfi_endproc
 4451              	.LFE157:
 4453 005e 00BF     		.section	.text.setMagODR,"ax",%progbits
 4454              		.align	2
 4455              		.global	setMagODR
 4456              		.thumb
 4457              		.thumb_func
 4459              	setMagODR:
 4460              	.LFB158:
1064:../LSM9DS1_drivers.c **** 
1065:../LSM9DS1_drivers.c **** void setMagODR(uint8_t mRate)
1066:../LSM9DS1_drivers.c **** {
 4461              		.loc 1 1066 0
 4462              		.cfi_startproc
 4463              		@ args = 0, pretend = 0, frame = 16
 4464              		@ frame_needed = 1, uses_anonymous_args = 0
 4465 0000 80B5     		push	{r7, lr}
 4466              	.LCFI132:
 4467              		.cfi_def_cfa_offset 8
 4468              		.cfi_offset 7, -8
 4469              		.cfi_offset 14, -4
 4470 0002 84B0     		sub	sp, sp, #16
 4471              	.LCFI133:
 4472              		.cfi_def_cfa_offset 24
 4473 0004 00AF     		add	r7, sp, #0
 4474              	.LCFI134:
 4475              		.cfi_def_cfa_register 7
 4476 0006 0346     		mov	r3, r0
 4477 0008 FB71     		strb	r3, [r7, #7]
1067:../LSM9DS1_drivers.c **** 	// We need to preserve the other bytes in CTRL_REG5_XM. So, first read it:
1068:../LSM9DS1_drivers.c **** 	uint8_t temp = mReadByte(CTRL_REG1_M);
 4478              		.loc 1 1068 0
 4479 000a 4FF02000 		mov	r0, #32
 4480 000e FFF7FEFF 		bl	mReadByte
 4481 0012 0346     		mov	r3, r0
 4482 0014 FB73     		strb	r3, [r7, #15]
1069:../LSM9DS1_drivers.c **** 	// Then mask out the mag ODR bits:
1070:../LSM9DS1_drivers.c **** 	temp &= 0xFF^(0x7 << 2);
 4483              		.loc 1 1070 0
 4484 0016 FB7B     		ldrb	r3, [r7, #15]
 4485 0018 23F01C03 		bic	r3, r3, #28
 4486 001c FB73     		strb	r3, [r7, #15]
1071:../LSM9DS1_drivers.c **** 	// Then shift in our new ODR bits:
1072:../LSM9DS1_drivers.c **** 	temp |= ((mRate & 0x07) << 2);
 4487              		.loc 1 1072 0
 4488 001e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4489 0020 03F00703 		and	r3, r3, #7
 4490 0024 4FEA8303 		lsl	r3, r3, #2
 4491 0028 DAB2     		uxtb	r2, r3
 4492 002a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 4493 002c 1343     		orrs	r3, r3, r2
 4494 002e DBB2     		uxtb	r3, r3
 4495 0030 FB73     		strb	r3, [r7, #15]
1073:../LSM9DS1_drivers.c **** 	settings.mag.sampleRate = mRate & 0x07;
 4496              		.loc 1 1073 0
 4497 0032 FB79     		ldrb	r3, [r7, #7]
 4498 0034 03F00703 		and	r3, r3, #7
 4499 0038 DAB2     		uxtb	r2, r3
 4500 003a 40F20003 		movw	r3, #:lower16:settings
 4501 003e C0F20003 		movt	r3, #:upper16:settings
 4502 0042 83F82120 		strb	r2, [r3, #33]
1074:../LSM9DS1_drivers.c **** 	// And write the new register value back into CTRL_REG5_XM:
1075:../LSM9DS1_drivers.c **** 	mWriteByte(CTRL_REG1_M, temp);
 4503              		.loc 1 1075 0
 4504 0046 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 4505 0048 4FF02000 		mov	r0, #32
 4506 004c 1946     		mov	r1, r3
 4507 004e FFF7FEFF 		bl	mWriteByte
1076:../LSM9DS1_drivers.c **** }
 4508              		.loc 1 1076 0
 4509 0052 07F11007 		add	r7, r7, #16
 4510 0056 BD46     		mov	sp, r7
 4511 0058 80BD     		pop	{r7, pc}
 4512              		.cfi_endproc
 4513              	.LFE158:
 4515 005a 00BF     		.section	.text.configInt,"ax",%progbits
 4516              		.align	2
 4517              		.global	configInt
 4518              		.thumb
 4519              		.thumb_func
 4521              	configInt:
 4522              	.LFB159:
1077:../LSM9DS1_drivers.c **** 
1078:../LSM9DS1_drivers.c **** void configInt(interrupt_select interupt, uint8_t generator, h_lactive activeLow, pp_od pushPull)
1079:../LSM9DS1_drivers.c **** {
 4523              		.loc 1 1079 0
 4524              		.cfi_startproc
 4525              		@ args = 0, pretend = 0, frame = 16
 4526              		@ frame_needed = 1, uses_anonymous_args = 0
 4527 0000 80B5     		push	{r7, lr}
 4528              	.LCFI135:
 4529              		.cfi_def_cfa_offset 8
 4530              		.cfi_offset 7, -8
 4531              		.cfi_offset 14, -4
 4532 0002 84B0     		sub	sp, sp, #16
 4533              	.LCFI136:
 4534              		.cfi_def_cfa_offset 24
 4535 0004 00AF     		add	r7, sp, #0
 4536              	.LCFI137:
 4537              		.cfi_def_cfa_register 7
 4538 0006 F871     		strb	r0, [r7, #7]
 4539 0008 B971     		strb	r1, [r7, #6]
 4540 000a 7A71     		strb	r2, [r7, #5]
 4541 000c 3B71     		strb	r3, [r7, #4]
1080:../LSM9DS1_drivers.c **** 	// Write to INT1_CTRL or INT2_CTRL. [interupt] should already be one of
1081:../LSM9DS1_drivers.c **** 	// those two values.
1082:../LSM9DS1_drivers.c **** 	// [generator] should be an OR'd list of values from the interrupt_generators enum
1083:../LSM9DS1_drivers.c **** 	xgWriteByte(interupt, generator);
 4542              		.loc 1 1083 0
 4543 000e FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 4544 0010 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 4545 0012 1046     		mov	r0, r2
 4546 0014 1946     		mov	r1, r3
 4547 0016 FFF7FEFF 		bl	xgWriteByte
1084:../LSM9DS1_drivers.c **** 
1085:../LSM9DS1_drivers.c **** 	// Configure CTRL_REG8
1086:../LSM9DS1_drivers.c **** 	uint8_t temp;
1087:../LSM9DS1_drivers.c **** 	temp = xgReadByte(CTRL_REG8);
 4548              		.loc 1 1087 0
 4549 001a 4FF02200 		mov	r0, #34
 4550 001e FFF7FEFF 		bl	xgReadByte
 4551 0022 0346     		mov	r3, r0
 4552 0024 FB73     		strb	r3, [r7, #15]
1088:../LSM9DS1_drivers.c **** 
1089:../LSM9DS1_drivers.c **** 	if (activeLow) temp |= (1<<5);
 4553              		.loc 1 1089 0
 4554 0026 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 4555 0028 002B     		cmp	r3, #0
 4556 002a 04D0     		beq	.L185
 4557              		.loc 1 1089 0 is_stmt 0 discriminator 1
 4558 002c FB7B     		ldrb	r3, [r7, #15]
 4559 002e 43F02003 		orr	r3, r3, #32
 4560 0032 FB73     		strb	r3, [r7, #15]
 4561 0034 03E0     		b	.L186
 4562              	.L185:
1090:../LSM9DS1_drivers.c **** 	else temp &= ~(1<<5);
 4563              		.loc 1 1090 0 is_stmt 1
 4564 0036 FB7B     		ldrb	r3, [r7, #15]
 4565 0038 23F02003 		bic	r3, r3, #32
 4566 003c FB73     		strb	r3, [r7, #15]
 4567              	.L186:
1091:../LSM9DS1_drivers.c **** 
1092:../LSM9DS1_drivers.c **** 	if (pushPull) temp &= ~(1<<4);
 4568              		.loc 1 1092 0
 4569 003e 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 4570 0040 002B     		cmp	r3, #0
 4571 0042 04D0     		beq	.L187
 4572              		.loc 1 1092 0 is_stmt 0 discriminator 1
 4573 0044 FB7B     		ldrb	r3, [r7, #15]
 4574 0046 23F01003 		bic	r3, r3, #16
 4575 004a FB73     		strb	r3, [r7, #15]
 4576 004c 03E0     		b	.L188
 4577              	.L187:
1093:../LSM9DS1_drivers.c **** 	else temp |= (1<<4);
 4578              		.loc 1 1093 0 is_stmt 1
 4579 004e FB7B     		ldrb	r3, [r7, #15]
 4580 0050 43F01003 		orr	r3, r3, #16
 4581 0054 FB73     		strb	r3, [r7, #15]
 4582              	.L188:
1094:../LSM9DS1_drivers.c **** 
1095:../LSM9DS1_drivers.c **** 	xgWriteByte(CTRL_REG8, temp);
 4583              		.loc 1 1095 0
 4584 0056 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 4585 0058 4FF02200 		mov	r0, #34
 4586 005c 1946     		mov	r1, r3
 4587 005e FFF7FEFF 		bl	xgWriteByte
1096:../LSM9DS1_drivers.c **** }
 4588              		.loc 1 1096 0
 4589 0062 07F11007 		add	r7, r7, #16
 4590 0066 BD46     		mov	sp, r7
 4591 0068 80BD     		pop	{r7, pc}
 4592              		.cfi_endproc
 4593              	.LFE159:
 4595 006a 00BF     		.section	.text.configInactivity,"ax",%progbits
 4596              		.align	2
 4597              		.global	configInactivity
 4598              		.thumb
 4599              		.thumb_func
 4601              	configInactivity:
 4602              	.LFB160:
1097:../LSM9DS1_drivers.c **** 
1098:../LSM9DS1_drivers.c **** 
1099:../LSM9DS1_drivers.c **** void configInactivity(uint8_t duration, uint8_t threshold, bool sleepOn)
1100:../LSM9DS1_drivers.c **** {
 4603              		.loc 1 1100 0
 4604              		.cfi_startproc
 4605              		@ args = 0, pretend = 0, frame = 16
 4606              		@ frame_needed = 1, uses_anonymous_args = 0
 4607 0000 80B5     		push	{r7, lr}
 4608              	.LCFI138:
 4609              		.cfi_def_cfa_offset 8
 4610              		.cfi_offset 7, -8
 4611              		.cfi_offset 14, -4
 4612 0002 84B0     		sub	sp, sp, #16
 4613              	.LCFI139:
 4614              		.cfi_def_cfa_offset 24
 4615 0004 00AF     		add	r7, sp, #0
 4616              	.LCFI140:
 4617              		.cfi_def_cfa_register 7
 4618 0006 1346     		mov	r3, r2
 4619 0008 0246     		mov	r2, r0
 4620 000a FA71     		strb	r2, [r7, #7]
 4621 000c 0A46     		mov	r2, r1
 4622 000e BA71     		strb	r2, [r7, #6]
 4623 0010 7B71     		strb	r3, [r7, #5]
1101:../LSM9DS1_drivers.c **** 	uint8_t temp = 0;
 4624              		.loc 1 1101 0
 4625 0012 4FF00003 		mov	r3, #0
 4626 0016 FB73     		strb	r3, [r7, #15]
1102:../LSM9DS1_drivers.c **** 
1103:../LSM9DS1_drivers.c **** 	temp = threshold & 0x7F;
 4627              		.loc 1 1103 0
 4628 0018 BB79     		ldrb	r3, [r7, #6]
 4629 001a 03F07F03 		and	r3, r3, #127
 4630 001e FB73     		strb	r3, [r7, #15]
1104:../LSM9DS1_drivers.c **** 	if (sleepOn) temp |= (1<<7);
 4631              		.loc 1 1104 0
 4632 0020 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 4633 0022 002B     		cmp	r3, #0
 4634 0024 03D0     		beq	.L190
 4635              		.loc 1 1104 0 is_stmt 0 discriminator 1
 4636 0026 FB7B     		ldrb	r3, [r7, #15]
 4637 0028 63F07F03 		orn	r3, r3, #127
 4638 002c FB73     		strb	r3, [r7, #15]
 4639              	.L190:
1105:../LSM9DS1_drivers.c **** 	xgWriteByte(ACT_THS, temp);
 4640              		.loc 1 1105 0 is_stmt 1
 4641 002e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 4642 0030 4FF00400 		mov	r0, #4
 4643 0034 1946     		mov	r1, r3
 4644 0036 FFF7FEFF 		bl	xgWriteByte
1106:../LSM9DS1_drivers.c **** 
1107:../LSM9DS1_drivers.c **** 	xgWriteByte(ACT_DUR, duration);
 4645              		.loc 1 1107 0
 4646 003a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4647 003c 4FF00500 		mov	r0, #5
 4648 0040 1946     		mov	r1, r3
 4649 0042 FFF7FEFF 		bl	xgWriteByte
1108:../LSM9DS1_drivers.c **** }
 4650              		.loc 1 1108 0
 4651 0046 07F11007 		add	r7, r7, #16
 4652 004a BD46     		mov	sp, r7
 4653 004c 80BD     		pop	{r7, pc}
 4654              		.cfi_endproc
 4655              	.LFE160:
 4657 004e 00BF     		.section	.text.getInactivity,"ax",%progbits
 4658              		.align	2
 4659              		.global	getInactivity
 4660              		.thumb
 4661              		.thumb_func
 4663              	getInactivity:
 4664              	.LFB161:
1109:../LSM9DS1_drivers.c **** 
1110:../LSM9DS1_drivers.c **** 
1111:../LSM9DS1_drivers.c **** uint8_t getInactivity(void)
1112:../LSM9DS1_drivers.c **** {
 4665              		.loc 1 1112 0
 4666              		.cfi_startproc
 4667              		@ args = 0, pretend = 0, frame = 8
 4668              		@ frame_needed = 1, uses_anonymous_args = 0
 4669 0000 80B5     		push	{r7, lr}
 4670              	.LCFI141:
 4671              		.cfi_def_cfa_offset 8
 4672              		.cfi_offset 7, -8
 4673              		.cfi_offset 14, -4
 4674 0002 82B0     		sub	sp, sp, #8
 4675              	.LCFI142:
 4676              		.cfi_def_cfa_offset 16
 4677 0004 00AF     		add	r7, sp, #0
 4678              	.LCFI143:
 4679              		.cfi_def_cfa_register 7
1113:../LSM9DS1_drivers.c **** 	uint8_t temp = xgReadByte(STATUS_REG_0);
 4680              		.loc 1 1113 0
 4681 0006 4FF01700 		mov	r0, #23
 4682 000a FFF7FEFF 		bl	xgReadByte
 4683 000e 0346     		mov	r3, r0
 4684 0010 FB71     		strb	r3, [r7, #7]
1114:../LSM9DS1_drivers.c **** 	temp &= (0x10);
 4685              		.loc 1 1114 0
 4686 0012 FB79     		ldrb	r3, [r7, #7]
 4687 0014 03F01003 		and	r3, r3, #16
 4688 0018 FB71     		strb	r3, [r7, #7]
1115:../LSM9DS1_drivers.c **** 	return temp;
 4689              		.loc 1 1115 0
 4690 001a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
1116:../LSM9DS1_drivers.c **** }
 4691              		.loc 1 1116 0
 4692 001c 1846     		mov	r0, r3
 4693 001e 07F10807 		add	r7, r7, #8
 4694 0022 BD46     		mov	sp, r7
 4695 0024 80BD     		pop	{r7, pc}
 4696              		.cfi_endproc
 4697              	.LFE161:
 4699 0026 00BF     		.section	.text.configAccelInt,"ax",%progbits
 4700              		.align	2
 4701              		.global	configAccelInt
 4702              		.thumb
 4703              		.thumb_func
 4705              	configAccelInt:
 4706              	.LFB162:
1117:../LSM9DS1_drivers.c **** 
1118:../LSM9DS1_drivers.c **** void configAccelInt(uint8_t generator, bool andInterrupts)
1119:../LSM9DS1_drivers.c **** {
 4707              		.loc 1 1119 0
 4708              		.cfi_startproc
 4709              		@ args = 0, pretend = 0, frame = 16
 4710              		@ frame_needed = 1, uses_anonymous_args = 0
 4711 0000 80B5     		push	{r7, lr}
 4712              	.LCFI144:
 4713              		.cfi_def_cfa_offset 8
 4714              		.cfi_offset 7, -8
 4715              		.cfi_offset 14, -4
 4716 0002 84B0     		sub	sp, sp, #16
 4717              	.LCFI145:
 4718              		.cfi_def_cfa_offset 24
 4719 0004 00AF     		add	r7, sp, #0
 4720              	.LCFI146:
 4721              		.cfi_def_cfa_register 7
 4722 0006 0246     		mov	r2, r0
 4723 0008 0B46     		mov	r3, r1
 4724 000a FA71     		strb	r2, [r7, #7]
 4725 000c BB71     		strb	r3, [r7, #6]
1120:../LSM9DS1_drivers.c **** 	// Use variables from accel_interrupt_generator, OR'd together to create
1121:../LSM9DS1_drivers.c **** 	// the [generator]value.
1122:../LSM9DS1_drivers.c **** 	uint8_t temp = generator;
 4726              		.loc 1 1122 0
 4727 000e FB79     		ldrb	r3, [r7, #7]
 4728 0010 FB73     		strb	r3, [r7, #15]
1123:../LSM9DS1_drivers.c **** 	if (andInterrupts) temp |= 0x80;
 4729              		.loc 1 1123 0
 4730 0012 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 4731 0014 002B     		cmp	r3, #0
 4732 0016 03D0     		beq	.L194
 4733              		.loc 1 1123 0 is_stmt 0 discriminator 1
 4734 0018 FB7B     		ldrb	r3, [r7, #15]
 4735 001a 63F07F03 		orn	r3, r3, #127
 4736 001e FB73     		strb	r3, [r7, #15]
 4737              	.L194:
1124:../LSM9DS1_drivers.c **** 	xgWriteByte(INT_GEN_CFG_XL, temp);
 4738              		.loc 1 1124 0 is_stmt 1
 4739 0020 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 4740 0022 4FF00600 		mov	r0, #6
 4741 0026 1946     		mov	r1, r3
 4742 0028 FFF7FEFF 		bl	xgWriteByte
1125:../LSM9DS1_drivers.c **** }
 4743              		.loc 1 1125 0
 4744 002c 07F11007 		add	r7, r7, #16
 4745 0030 BD46     		mov	sp, r7
 4746 0032 80BD     		pop	{r7, pc}
 4747              		.cfi_endproc
 4748              	.LFE162:
 4750              		.section	.text.configAccelThs,"ax",%progbits
 4751              		.align	2
 4752              		.global	configAccelThs
 4753              		.thumb
 4754              		.thumb_func
 4756              	configAccelThs:
 4757              	.LFB163:
1126:../LSM9DS1_drivers.c **** 
1127:../LSM9DS1_drivers.c **** void configAccelThs(uint8_t threshold, lsm9ds1_axis axis, uint8_t duration, bool wait)
1128:../LSM9DS1_drivers.c **** {
 4758              		.loc 1 1128 0
 4759              		.cfi_startproc
 4760              		@ args = 0, pretend = 0, frame = 16
 4761              		@ frame_needed = 1, uses_anonymous_args = 0
 4762 0000 80B5     		push	{r7, lr}
 4763              	.LCFI147:
 4764              		.cfi_def_cfa_offset 8
 4765              		.cfi_offset 7, -8
 4766              		.cfi_offset 14, -4
 4767 0002 84B0     		sub	sp, sp, #16
 4768              	.LCFI148:
 4769              		.cfi_def_cfa_offset 24
 4770 0004 00AF     		add	r7, sp, #0
 4771              	.LCFI149:
 4772              		.cfi_def_cfa_register 7
 4773 0006 F871     		strb	r0, [r7, #7]
 4774 0008 B971     		strb	r1, [r7, #6]
 4775 000a 7A71     		strb	r2, [r7, #5]
 4776 000c 3B71     		strb	r3, [r7, #4]
1129:../LSM9DS1_drivers.c **** 	// Write threshold value to INT_GEN_THS_?_XL.
1130:../LSM9DS1_drivers.c **** 	// axis will be 0, 1, or 2 (x, y, z respectively)
1131:../LSM9DS1_drivers.c **** 	xgWriteByte(INT_GEN_THS_X_XL + axis, threshold);
 4777              		.loc 1 1131 0
 4778 000e BB79     		ldrb	r3, [r7, #6]
 4779 0010 03F10703 		add	r3, r3, #7
 4780 0014 DAB2     		uxtb	r2, r3
 4781 0016 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4782 0018 1046     		mov	r0, r2
 4783 001a 1946     		mov	r1, r3
 4784 001c FFF7FEFF 		bl	xgWriteByte
1132:../LSM9DS1_drivers.c **** 
1133:../LSM9DS1_drivers.c **** 	// Write duration and wait to INT_GEN_DUR_XL
1134:../LSM9DS1_drivers.c **** 	uint8_t temp;
1135:../LSM9DS1_drivers.c **** 	temp = (duration & 0x7F);
 4785              		.loc 1 1135 0
 4786 0020 7B79     		ldrb	r3, [r7, #5]
 4787 0022 03F07F03 		and	r3, r3, #127
 4788 0026 FB73     		strb	r3, [r7, #15]
1136:../LSM9DS1_drivers.c **** 	if (wait) temp |= 0x80;
 4789              		.loc 1 1136 0
 4790 0028 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 4791 002a 002B     		cmp	r3, #0
 4792 002c 03D0     		beq	.L196
 4793              		.loc 1 1136 0 is_stmt 0 discriminator 1
 4794 002e FB7B     		ldrb	r3, [r7, #15]
 4795 0030 63F07F03 		orn	r3, r3, #127
 4796 0034 FB73     		strb	r3, [r7, #15]
 4797              	.L196:
1137:../LSM9DS1_drivers.c **** 	xgWriteByte(INT_GEN_DUR_XL, temp);
 4798              		.loc 1 1137 0 is_stmt 1
 4799 0036 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 4800 0038 4FF00A00 		mov	r0, #10
 4801 003c 1946     		mov	r1, r3
 4802 003e FFF7FEFF 		bl	xgWriteByte
1138:../LSM9DS1_drivers.c **** }
 4803              		.loc 1 1138 0
 4804 0042 07F11007 		add	r7, r7, #16
 4805 0046 BD46     		mov	sp, r7
 4806 0048 80BD     		pop	{r7, pc}
 4807              		.cfi_endproc
 4808              	.LFE163:
 4810 004a 00BF     		.section	.text.getAccelIntSrc,"ax",%progbits
 4811              		.align	2
 4812              		.global	getAccelIntSrc
 4813              		.thumb
 4814              		.thumb_func
 4816              	getAccelIntSrc:
 4817              	.LFB164:
1139:../LSM9DS1_drivers.c **** 
1140:../LSM9DS1_drivers.c **** uint8_t getAccelIntSrc(void)
1141:../LSM9DS1_drivers.c **** {
 4818              		.loc 1 1141 0
 4819              		.cfi_startproc
 4820              		@ args = 0, pretend = 0, frame = 8
 4821              		@ frame_needed = 1, uses_anonymous_args = 0
 4822 0000 80B5     		push	{r7, lr}
 4823              	.LCFI150:
 4824              		.cfi_def_cfa_offset 8
 4825              		.cfi_offset 7, -8
 4826              		.cfi_offset 14, -4
 4827 0002 82B0     		sub	sp, sp, #8
 4828              	.LCFI151:
 4829              		.cfi_def_cfa_offset 16
 4830 0004 00AF     		add	r7, sp, #0
 4831              	.LCFI152:
 4832              		.cfi_def_cfa_register 7
1142:../LSM9DS1_drivers.c **** 	uint8_t intSrc = xgReadByte(INT_GEN_SRC_XL);
 4833              		.loc 1 1142 0
 4834 0006 4FF02600 		mov	r0, #38
 4835 000a FFF7FEFF 		bl	xgReadByte
 4836 000e 0346     		mov	r3, r0
 4837 0010 FB71     		strb	r3, [r7, #7]
1143:../LSM9DS1_drivers.c **** 
1144:../LSM9DS1_drivers.c **** 	// Check if the IA_XL (interrupt active) bit is set
1145:../LSM9DS1_drivers.c **** 	if (intSrc & (1<<6))
 4838              		.loc 1 1145 0
 4839 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4840 0014 03F04003 		and	r3, r3, #64
 4841 0018 002B     		cmp	r3, #0
 4842 001a 04D0     		beq	.L198
1146:../LSM9DS1_drivers.c **** 	{
1147:../LSM9DS1_drivers.c **** 		return (intSrc & 0x3F);
 4843              		.loc 1 1147 0
 4844 001c FB79     		ldrb	r3, [r7, #7]
 4845 001e 03F03F03 		and	r3, r3, #63
 4846 0022 DBB2     		uxtb	r3, r3
 4847 0024 01E0     		b	.L199
 4848              	.L198:
1148:../LSM9DS1_drivers.c **** 	}
1149:../LSM9DS1_drivers.c **** 
1150:../LSM9DS1_drivers.c **** 	return 0;
 4849              		.loc 1 1150 0
 4850 0026 4FF00003 		mov	r3, #0
 4851              	.L199:
1151:../LSM9DS1_drivers.c **** }
 4852              		.loc 1 1151 0
 4853 002a 1846     		mov	r0, r3
 4854 002c 07F10807 		add	r7, r7, #8
 4855 0030 BD46     		mov	sp, r7
 4856 0032 80BD     		pop	{r7, pc}
 4857              		.cfi_endproc
 4858              	.LFE164:
 4860              		.section	.text.configGyroInt,"ax",%progbits
 4861              		.align	2
 4862              		.global	configGyroInt
 4863              		.thumb
 4864              		.thumb_func
 4866              	configGyroInt:
 4867              	.LFB165:
1152:../LSM9DS1_drivers.c **** 
1153:../LSM9DS1_drivers.c **** void configGyroInt(uint8_t generator, bool aoi, bool latch)
1154:../LSM9DS1_drivers.c **** {
 4868              		.loc 1 1154 0
 4869              		.cfi_startproc
 4870              		@ args = 0, pretend = 0, frame = 16
 4871              		@ frame_needed = 1, uses_anonymous_args = 0
 4872 0000 80B5     		push	{r7, lr}
 4873              	.LCFI153:
 4874              		.cfi_def_cfa_offset 8
 4875              		.cfi_offset 7, -8
 4876              		.cfi_offset 14, -4
 4877 0002 84B0     		sub	sp, sp, #16
 4878              	.LCFI154:
 4879              		.cfi_def_cfa_offset 24
 4880 0004 00AF     		add	r7, sp, #0
 4881              	.LCFI155:
 4882              		.cfi_def_cfa_register 7
 4883 0006 1346     		mov	r3, r2
 4884 0008 0246     		mov	r2, r0
 4885 000a FA71     		strb	r2, [r7, #7]
 4886 000c 0A46     		mov	r2, r1
 4887 000e BA71     		strb	r2, [r7, #6]
 4888 0010 7B71     		strb	r3, [r7, #5]
1155:../LSM9DS1_drivers.c **** 	// Use variables from accel_interrupt_generator, OR'd together to create
1156:../LSM9DS1_drivers.c **** 	// the [generator]value.
1157:../LSM9DS1_drivers.c **** 	uint8_t temp = generator;
 4889              		.loc 1 1157 0
 4890 0012 FB79     		ldrb	r3, [r7, #7]
 4891 0014 FB73     		strb	r3, [r7, #15]
1158:../LSM9DS1_drivers.c **** 	if (aoi) temp |= 0x80;
 4892              		.loc 1 1158 0
 4893 0016 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 4894 0018 002B     		cmp	r3, #0
 4895 001a 03D0     		beq	.L201
 4896              		.loc 1 1158 0 is_stmt 0 discriminator 1
 4897 001c FB7B     		ldrb	r3, [r7, #15]
 4898 001e 63F07F03 		orn	r3, r3, #127
 4899 0022 FB73     		strb	r3, [r7, #15]
 4900              	.L201:
1159:../LSM9DS1_drivers.c **** 	if (latch) temp |= 0x40;
 4901              		.loc 1 1159 0 is_stmt 1
 4902 0024 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 4903 0026 002B     		cmp	r3, #0
 4904 0028 03D0     		beq	.L202
 4905              		.loc 1 1159 0 is_stmt 0 discriminator 1
 4906 002a FB7B     		ldrb	r3, [r7, #15]
 4907 002c 43F04003 		orr	r3, r3, #64
 4908 0030 FB73     		strb	r3, [r7, #15]
 4909              	.L202:
1160:../LSM9DS1_drivers.c **** 	xgWriteByte(INT_GEN_CFG_G, temp);
 4910              		.loc 1 1160 0 is_stmt 1
 4911 0032 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 4912 0034 4FF03000 		mov	r0, #48
 4913 0038 1946     		mov	r1, r3
 4914 003a FFF7FEFF 		bl	xgWriteByte
1161:../LSM9DS1_drivers.c **** }
 4915              		.loc 1 1161 0
 4916 003e 07F11007 		add	r7, r7, #16
 4917 0042 BD46     		mov	sp, r7
 4918 0044 80BD     		pop	{r7, pc}
 4919              		.cfi_endproc
 4920              	.LFE165:
 4922 0046 00BF     		.section	.text.configGyroThs,"ax",%progbits
 4923              		.align	2
 4924              		.global	configGyroThs
 4925              		.thumb
 4926              		.thumb_func
 4928              	configGyroThs:
 4929              	.LFB166:
1162:../LSM9DS1_drivers.c **** 
1163:../LSM9DS1_drivers.c **** 
1164:../LSM9DS1_drivers.c **** void configGyroThs(int16_t threshold, lsm9ds1_axis axis, uint8_t duration, bool wait)
1165:../LSM9DS1_drivers.c **** {
 4930              		.loc 1 1165 0
 4931              		.cfi_startproc
 4932              		@ args = 0, pretend = 0, frame = 16
 4933              		@ frame_needed = 1, uses_anonymous_args = 0
 4934 0000 80B5     		push	{r7, lr}
 4935              	.LCFI156:
 4936              		.cfi_def_cfa_offset 8
 4937              		.cfi_offset 7, -8
 4938              		.cfi_offset 14, -4
 4939 0002 84B0     		sub	sp, sp, #16
 4940              	.LCFI157:
 4941              		.cfi_def_cfa_offset 24
 4942 0004 00AF     		add	r7, sp, #0
 4943              	.LCFI158:
 4944              		.cfi_def_cfa_register 7
 4945 0006 F880     		strh	r0, [r7, #6]	@ movhi
 4946 0008 7971     		strb	r1, [r7, #5]
 4947 000a 3A71     		strb	r2, [r7, #4]
 4948 000c FB70     		strb	r3, [r7, #3]
1166:../LSM9DS1_drivers.c **** 	uint8_t buffer[2];
1167:../LSM9DS1_drivers.c **** 	buffer[0] = (threshold & 0x7F00) >> 8;
 4949              		.loc 1 1167 0
 4950 000e FB88     		ldrh	r3, [r7, #6]
 4951 0010 03F4FE43 		and	r3, r3, #32512
 4952 0014 4FEA2323 		asr	r3, r3, #8
 4953 0018 DBB2     		uxtb	r3, r3
 4954 001a 3B73     		strb	r3, [r7, #12]
1168:../LSM9DS1_drivers.c **** 	buffer[1] = (threshold & 0x00FF);
 4955              		.loc 1 1168 0
 4956 001c FB88     		ldrh	r3, [r7, #6]	@ movhi
 4957 001e DBB2     		uxtb	r3, r3
 4958 0020 7B73     		strb	r3, [r7, #13]
1169:../LSM9DS1_drivers.c **** 	// Write threshold value to INT_GEN_THS_?H_G and  INT_GEN_THS_?L_G.
1170:../LSM9DS1_drivers.c **** 	// axis will be 0, 1, or 2 (x, y, z respectively)
1171:../LSM9DS1_drivers.c **** 	xgWriteByte(INT_GEN_THS_XH_G + (axis * 2), buffer[0]);
 4959              		.loc 1 1171 0
 4960 0022 7B79     		ldrb	r3, [r7, #5]
 4961 0024 4FEA4303 		lsl	r3, r3, #1
 4962 0028 DBB2     		uxtb	r3, r3
 4963 002a 03F13103 		add	r3, r3, #49
 4964 002e DAB2     		uxtb	r2, r3
 4965 0030 3B7B     		ldrb	r3, [r7, #12]	@ zero_extendqisi2
 4966 0032 1046     		mov	r0, r2
 4967 0034 1946     		mov	r1, r3
 4968 0036 FFF7FEFF 		bl	xgWriteByte
1172:../LSM9DS1_drivers.c **** 	xgWriteByte(INT_GEN_THS_XH_G + 1 + (axis * 2), buffer[1]);
 4969              		.loc 1 1172 0
 4970 003a 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 4971 003c 03F11903 		add	r3, r3, #25
 4972 0040 DBB2     		uxtb	r3, r3
 4973 0042 4FEA4303 		lsl	r3, r3, #1
 4974 0046 DAB2     		uxtb	r2, r3
 4975 0048 7B7B     		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4976 004a 1046     		mov	r0, r2
 4977 004c 1946     		mov	r1, r3
 4978 004e FFF7FEFF 		bl	xgWriteByte
1173:../LSM9DS1_drivers.c **** 
1174:../LSM9DS1_drivers.c **** 	// Write duration and wait to INT_GEN_DUR_XL
1175:../LSM9DS1_drivers.c **** 	uint8_t temp;
1176:../LSM9DS1_drivers.c **** 	temp = (duration & 0x7F);
 4979              		.loc 1 1176 0
 4980 0052 3B79     		ldrb	r3, [r7, #4]
 4981 0054 03F07F03 		and	r3, r3, #127
 4982 0058 FB73     		strb	r3, [r7, #15]
1177:../LSM9DS1_drivers.c **** 	if (wait) temp |= 0x80;
 4983              		.loc 1 1177 0
 4984 005a FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 4985 005c 002B     		cmp	r3, #0
 4986 005e 03D0     		beq	.L204
 4987              		.loc 1 1177 0 is_stmt 0 discriminator 1
 4988 0060 FB7B     		ldrb	r3, [r7, #15]
 4989 0062 63F07F03 		orn	r3, r3, #127
 4990 0066 FB73     		strb	r3, [r7, #15]
 4991              	.L204:
1178:../LSM9DS1_drivers.c **** 	xgWriteByte(INT_GEN_DUR_G, temp);
 4992              		.loc 1 1178 0 is_stmt 1
 4993 0068 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 4994 006a 4FF03700 		mov	r0, #55
 4995 006e 1946     		mov	r1, r3
 4996 0070 FFF7FEFF 		bl	xgWriteByte
1179:../LSM9DS1_drivers.c **** }
 4997              		.loc 1 1179 0
 4998 0074 07F11007 		add	r7, r7, #16
 4999 0078 BD46     		mov	sp, r7
 5000 007a 80BD     		pop	{r7, pc}
 5001              		.cfi_endproc
 5002              	.LFE166:
 5004              		.section	.text.getGyroIntSrc,"ax",%progbits
 5005              		.align	2
 5006              		.global	getGyroIntSrc
 5007              		.thumb
 5008              		.thumb_func
 5010              	getGyroIntSrc:
 5011              	.LFB167:
1180:../LSM9DS1_drivers.c **** 
1181:../LSM9DS1_drivers.c **** 
1182:../LSM9DS1_drivers.c **** uint8_t getGyroIntSrc()
1183:../LSM9DS1_drivers.c **** {
 5012              		.loc 1 1183 0
 5013              		.cfi_startproc
 5014              		@ args = 0, pretend = 0, frame = 8
 5015              		@ frame_needed = 1, uses_anonymous_args = 0
 5016 0000 80B5     		push	{r7, lr}
 5017              	.LCFI159:
 5018              		.cfi_def_cfa_offset 8
 5019              		.cfi_offset 7, -8
 5020              		.cfi_offset 14, -4
 5021 0002 82B0     		sub	sp, sp, #8
 5022              	.LCFI160:
 5023              		.cfi_def_cfa_offset 16
 5024 0004 00AF     		add	r7, sp, #0
 5025              	.LCFI161:
 5026              		.cfi_def_cfa_register 7
1184:../LSM9DS1_drivers.c **** 	uint8_t intSrc = xgReadByte(INT_GEN_SRC_G);
 5027              		.loc 1 1184 0
 5028 0006 4FF01400 		mov	r0, #20
 5029 000a FFF7FEFF 		bl	xgReadByte
 5030 000e 0346     		mov	r3, r0
 5031 0010 FB71     		strb	r3, [r7, #7]
1185:../LSM9DS1_drivers.c **** 
1186:../LSM9DS1_drivers.c **** 	// Check if the IA_G (interrupt active) bit is set
1187:../LSM9DS1_drivers.c **** 	if (intSrc & (1<<6))
 5032              		.loc 1 1187 0
 5033 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5034 0014 03F04003 		and	r3, r3, #64
 5035 0018 002B     		cmp	r3, #0
 5036 001a 04D0     		beq	.L206
1188:../LSM9DS1_drivers.c **** 	{
1189:../LSM9DS1_drivers.c **** 		return (intSrc & 0x3F);
 5037              		.loc 1 1189 0
 5038 001c FB79     		ldrb	r3, [r7, #7]
 5039 001e 03F03F03 		and	r3, r3, #63
 5040 0022 DBB2     		uxtb	r3, r3
 5041 0024 01E0     		b	.L207
 5042              	.L206:
1190:../LSM9DS1_drivers.c **** 	}
1191:../LSM9DS1_drivers.c **** 
1192:../LSM9DS1_drivers.c **** 	return 0;
 5043              		.loc 1 1192 0
 5044 0026 4FF00003 		mov	r3, #0
 5045              	.L207:
1193:../LSM9DS1_drivers.c **** }
 5046              		.loc 1 1193 0
 5047 002a 1846     		mov	r0, r3
 5048 002c 07F10807 		add	r7, r7, #8
 5049 0030 BD46     		mov	sp, r7
 5050 0032 80BD     		pop	{r7, pc}
 5051              		.cfi_endproc
 5052              	.LFE167:
 5054              		.section	.text.configMagInt,"ax",%progbits
 5055              		.align	2
 5056              		.global	configMagInt
 5057              		.thumb
 5058              		.thumb_func
 5060              	configMagInt:
 5061              	.LFB168:
1194:../LSM9DS1_drivers.c **** 
1195:../LSM9DS1_drivers.c **** 
1196:../LSM9DS1_drivers.c **** void configMagInt(uint8_t generator, h_lactive activeLow, bool latch)
1197:../LSM9DS1_drivers.c **** {
 5062              		.loc 1 1197 0
 5063              		.cfi_startproc
 5064              		@ args = 0, pretend = 0, frame = 16
 5065              		@ frame_needed = 1, uses_anonymous_args = 0
 5066 0000 80B5     		push	{r7, lr}
 5067              	.LCFI162:
 5068              		.cfi_def_cfa_offset 8
 5069              		.cfi_offset 7, -8
 5070              		.cfi_offset 14, -4
 5071 0002 84B0     		sub	sp, sp, #16
 5072              	.LCFI163:
 5073              		.cfi_def_cfa_offset 24
 5074 0004 00AF     		add	r7, sp, #0
 5075              	.LCFI164:
 5076              		.cfi_def_cfa_register 7
 5077 0006 1346     		mov	r3, r2
 5078 0008 0246     		mov	r2, r0
 5079 000a FA71     		strb	r2, [r7, #7]
 5080 000c 0A46     		mov	r2, r1
 5081 000e BA71     		strb	r2, [r7, #6]
 5082 0010 7B71     		strb	r3, [r7, #5]
1198:../LSM9DS1_drivers.c **** 	// Mask out non-generator bits (0-4)
1199:../LSM9DS1_drivers.c **** 	uint8_t config = (generator & 0xE0);
 5083              		.loc 1 1199 0
 5084 0012 FB79     		ldrb	r3, [r7, #7]
 5085 0014 23F01F03 		bic	r3, r3, #31
 5086 0018 FB73     		strb	r3, [r7, #15]
1200:../LSM9DS1_drivers.c **** 	// IEA bit is 0 for active-low, 1 for active-high.
1201:../LSM9DS1_drivers.c **** 	if (activeLow == INT_ACTIVE_HIGH) config |= (1<<2);
 5087              		.loc 1 1201 0
 5088 001a BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 5089 001c 002B     		cmp	r3, #0
 5090 001e 03D1     		bne	.L209
 5091              		.loc 1 1201 0 is_stmt 0 discriminator 1
 5092 0020 FB7B     		ldrb	r3, [r7, #15]
 5093 0022 43F00403 		orr	r3, r3, #4
 5094 0026 FB73     		strb	r3, [r7, #15]
 5095              	.L209:
1202:../LSM9DS1_drivers.c **** 	// IEL bit is 0 for latched, 1 for not-latched
1203:../LSM9DS1_drivers.c **** 	if (!latch) config |= (1<<1);
 5096              		.loc 1 1203 0 is_stmt 1
 5097 0028 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 5098 002a 002B     		cmp	r3, #0
 5099 002c 03D1     		bne	.L210
 5100              		.loc 1 1203 0 is_stmt 0 discriminator 1
 5101 002e FB7B     		ldrb	r3, [r7, #15]
 5102 0030 43F00203 		orr	r3, r3, #2
 5103 0034 FB73     		strb	r3, [r7, #15]
 5104              	.L210:
1204:../LSM9DS1_drivers.c **** 	// As long as we have at least 1 generator, enable the interrupt
1205:../LSM9DS1_drivers.c **** 	if (generator != 0) config |= (1<<0);
 5105              		.loc 1 1205 0 is_stmt 1
 5106 0036 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5107 0038 002B     		cmp	r3, #0
 5108 003a 03D0     		beq	.L211
 5109              		.loc 1 1205 0 is_stmt 0 discriminator 1
 5110 003c FB7B     		ldrb	r3, [r7, #15]
 5111 003e 43F00103 		orr	r3, r3, #1
 5112 0042 FB73     		strb	r3, [r7, #15]
 5113              	.L211:
1206:../LSM9DS1_drivers.c **** 
1207:../LSM9DS1_drivers.c **** 	mWriteByte(INT_CFG_M, config);
 5114              		.loc 1 1207 0 is_stmt 1
 5115 0044 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 5116 0046 4FF03000 		mov	r0, #48
 5117 004a 1946     		mov	r1, r3
 5118 004c FFF7FEFF 		bl	mWriteByte
1208:../LSM9DS1_drivers.c **** }
 5119              		.loc 1 1208 0
 5120 0050 07F11007 		add	r7, r7, #16
 5121 0054 BD46     		mov	sp, r7
 5122 0056 80BD     		pop	{r7, pc}
 5123              		.cfi_endproc
 5124              	.LFE168:
 5126              		.section	.text.configMagThs,"ax",%progbits
 5127              		.align	2
 5128              		.global	configMagThs
 5129              		.thumb
 5130              		.thumb_func
 5132              	configMagThs:
 5133              	.LFB169:
1209:../LSM9DS1_drivers.c **** 
1210:../LSM9DS1_drivers.c **** 
1211:../LSM9DS1_drivers.c **** void configMagThs(uint16_t threshold)
1212:../LSM9DS1_drivers.c **** {
 5134              		.loc 1 1212 0
 5135              		.cfi_startproc
 5136              		@ args = 0, pretend = 0, frame = 8
 5137              		@ frame_needed = 1, uses_anonymous_args = 0
 5138 0000 80B5     		push	{r7, lr}
 5139              	.LCFI165:
 5140              		.cfi_def_cfa_offset 8
 5141              		.cfi_offset 7, -8
 5142              		.cfi_offset 14, -4
 5143 0002 82B0     		sub	sp, sp, #8
 5144              	.LCFI166:
 5145              		.cfi_def_cfa_offset 16
 5146 0004 00AF     		add	r7, sp, #0
 5147              	.LCFI167:
 5148              		.cfi_def_cfa_register 7
 5149 0006 0346     		mov	r3, r0
 5150 0008 FB80     		strh	r3, [r7, #6]	@ movhi
1213:../LSM9DS1_drivers.c **** 	// Write high eight bits of [threshold] to INT_THS_H_M
1214:../LSM9DS1_drivers.c **** 	mWriteByte(INT_THS_H_M, (uint8_t)((threshold & 0x7F00) >> 8));
 5151              		.loc 1 1214 0
 5152 000a FB88     		ldrh	r3, [r7, #6]
 5153 000c 03F4FE43 		and	r3, r3, #32512
 5154 0010 4FEA2323 		asr	r3, r3, #8
 5155 0014 DBB2     		uxtb	r3, r3
 5156 0016 4FF03300 		mov	r0, #51
 5157 001a 1946     		mov	r1, r3
 5158 001c FFF7FEFF 		bl	mWriteByte
1215:../LSM9DS1_drivers.c **** 	// Write low eight bits of [threshold] to INT_THS_L_M
1216:../LSM9DS1_drivers.c **** 	mWriteByte(INT_THS_L_M, (uint8_t)(threshold & 0x00FF));
 5159              		.loc 1 1216 0
 5160 0020 FB88     		ldrh	r3, [r7, #6]	@ movhi
 5161 0022 DBB2     		uxtb	r3, r3
 5162 0024 4FF03200 		mov	r0, #50
 5163 0028 1946     		mov	r1, r3
 5164 002a FFF7FEFF 		bl	mWriteByte
1217:../LSM9DS1_drivers.c **** }
 5165              		.loc 1 1217 0
 5166 002e 07F10807 		add	r7, r7, #8
 5167 0032 BD46     		mov	sp, r7
 5168 0034 80BD     		pop	{r7, pc}
 5169              		.cfi_endproc
 5170              	.LFE169:
 5172 0036 00BF     		.section	.text.getMagIntSrc,"ax",%progbits
 5173              		.align	2
 5174              		.global	getMagIntSrc
 5175              		.thumb
 5176              		.thumb_func
 5178              	getMagIntSrc:
 5179              	.LFB170:
1218:../LSM9DS1_drivers.c **** 
1219:../LSM9DS1_drivers.c **** uint8_t getMagIntSrc(void)
1220:../LSM9DS1_drivers.c **** {
 5180              		.loc 1 1220 0
 5181              		.cfi_startproc
 5182              		@ args = 0, pretend = 0, frame = 8
 5183              		@ frame_needed = 1, uses_anonymous_args = 0
 5184 0000 80B5     		push	{r7, lr}
 5185              	.LCFI168:
 5186              		.cfi_def_cfa_offset 8
 5187              		.cfi_offset 7, -8
 5188              		.cfi_offset 14, -4
 5189 0002 82B0     		sub	sp, sp, #8
 5190              	.LCFI169:
 5191              		.cfi_def_cfa_offset 16
 5192 0004 00AF     		add	r7, sp, #0
 5193              	.LCFI170:
 5194              		.cfi_def_cfa_register 7
1221:../LSM9DS1_drivers.c **** 	uint8_t intSrc = mReadByte(INT_SRC_M);
 5195              		.loc 1 1221 0
 5196 0006 4FF03000 		mov	r0, #48
 5197 000a FFF7FEFF 		bl	mReadByte
 5198 000e 0346     		mov	r3, r0
 5199 0010 FB71     		strb	r3, [r7, #7]
1222:../LSM9DS1_drivers.c **** 
1223:../LSM9DS1_drivers.c **** 	// Check if the INT (interrupt active) bit is set
1224:../LSM9DS1_drivers.c **** 	if (intSrc & (1<<0))
 5200              		.loc 1 1224 0
 5201 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5202 0014 03F00103 		and	r3, r3, #1
 5203 0018 002B     		cmp	r3, #0
 5204 001a 04D0     		beq	.L214
1225:../LSM9DS1_drivers.c **** 	{
1226:../LSM9DS1_drivers.c **** 		return (intSrc & 0xFE);
 5205              		.loc 1 1226 0
 5206 001c FB79     		ldrb	r3, [r7, #7]
 5207 001e 23F00103 		bic	r3, r3, #1
 5208 0022 DBB2     		uxtb	r3, r3
 5209 0024 01E0     		b	.L215
 5210              	.L214:
1227:../LSM9DS1_drivers.c **** 	}
1228:../LSM9DS1_drivers.c **** 
1229:../LSM9DS1_drivers.c **** 	return 0;
 5211              		.loc 1 1229 0
 5212 0026 4FF00003 		mov	r3, #0
 5213              	.L215:
1230:../LSM9DS1_drivers.c **** }
 5214              		.loc 1 1230 0
 5215 002a 1846     		mov	r0, r3
 5216 002c 07F10807 		add	r7, r7, #8
 5217 0030 BD46     		mov	sp, r7
 5218 0032 80BD     		pop	{r7, pc}
 5219              		.cfi_endproc
 5220              	.LFE170:
 5222              		.section	.text.sleepGyro,"ax",%progbits
 5223              		.align	2
 5224              		.global	sleepGyro
 5225              		.thumb
 5226              		.thumb_func
 5228              	sleepGyro:
 5229              	.LFB171:
1231:../LSM9DS1_drivers.c **** 
1232:../LSM9DS1_drivers.c **** void sleepGyro(bool enable)
1233:../LSM9DS1_drivers.c **** {
 5230              		.loc 1 1233 0
 5231              		.cfi_startproc
 5232              		@ args = 0, pretend = 0, frame = 16
 5233              		@ frame_needed = 1, uses_anonymous_args = 0
 5234 0000 80B5     		push	{r7, lr}
 5235              	.LCFI171:
 5236              		.cfi_def_cfa_offset 8
 5237              		.cfi_offset 7, -8
 5238              		.cfi_offset 14, -4
 5239 0002 84B0     		sub	sp, sp, #16
 5240              	.LCFI172:
 5241              		.cfi_def_cfa_offset 24
 5242 0004 00AF     		add	r7, sp, #0
 5243              	.LCFI173:
 5244              		.cfi_def_cfa_register 7
 5245 0006 0346     		mov	r3, r0
 5246 0008 FB71     		strb	r3, [r7, #7]
1234:../LSM9DS1_drivers.c **** 	uint8_t temp = xgReadByte(CTRL_REG9);
 5247              		.loc 1 1234 0
 5248 000a 4FF02300 		mov	r0, #35
 5249 000e FFF7FEFF 		bl	xgReadByte
 5250 0012 0346     		mov	r3, r0
 5251 0014 FB73     		strb	r3, [r7, #15]
1235:../LSM9DS1_drivers.c **** 	if (enable) temp |= (1<<6);
 5252              		.loc 1 1235 0
 5253 0016 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5254 0018 002B     		cmp	r3, #0
 5255 001a 04D0     		beq	.L217
 5256              		.loc 1 1235 0 is_stmt 0 discriminator 1
 5257 001c FB7B     		ldrb	r3, [r7, #15]
 5258 001e 43F04003 		orr	r3, r3, #64
 5259 0022 FB73     		strb	r3, [r7, #15]
 5260 0024 03E0     		b	.L218
 5261              	.L217:
1236:../LSM9DS1_drivers.c **** 	else temp &= ~(1<<6);
 5262              		.loc 1 1236 0 is_stmt 1
 5263 0026 FB7B     		ldrb	r3, [r7, #15]
 5264 0028 23F04003 		bic	r3, r3, #64
 5265 002c FB73     		strb	r3, [r7, #15]
 5266              	.L218:
1237:../LSM9DS1_drivers.c **** 	xgWriteByte(CTRL_REG9, temp);
 5267              		.loc 1 1237 0
 5268 002e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 5269 0030 4FF02300 		mov	r0, #35
 5270 0034 1946     		mov	r1, r3
 5271 0036 FFF7FEFF 		bl	xgWriteByte
1238:../LSM9DS1_drivers.c **** }
 5272              		.loc 1 1238 0
 5273 003a 07F11007 		add	r7, r7, #16
 5274 003e BD46     		mov	sp, r7
 5275 0040 80BD     		pop	{r7, pc}
 5276              		.cfi_endproc
 5277              	.LFE171:
 5279 0042 00BF     		.section	.text.getFIFOSamples,"ax",%progbits
 5280              		.align	2
 5281              		.global	getFIFOSamples
 5282              		.thumb
 5283              		.thumb_func
 5285              	getFIFOSamples:
 5286              	.LFB172:
1239:../LSM9DS1_drivers.c **** 
1240:../LSM9DS1_drivers.c **** 
1241:../LSM9DS1_drivers.c **** uint8_t getFIFOSamples(void)
1242:../LSM9DS1_drivers.c **** {
 5287              		.loc 1 1242 0
 5288              		.cfi_startproc
 5289              		@ args = 0, pretend = 0, frame = 0
 5290              		@ frame_needed = 1, uses_anonymous_args = 0
 5291 0000 80B5     		push	{r7, lr}
 5292              	.LCFI174:
 5293              		.cfi_def_cfa_offset 8
 5294              		.cfi_offset 7, -8
 5295              		.cfi_offset 14, -4
 5296 0002 00AF     		add	r7, sp, #0
 5297              	.LCFI175:
 5298              		.cfi_def_cfa_register 7
1243:../LSM9DS1_drivers.c **** 	return (xgReadByte(FIFO_SRC) & 0x3F);
 5299              		.loc 1 1243 0
 5300 0004 4FF02F00 		mov	r0, #47
 5301 0008 FFF7FEFF 		bl	xgReadByte
 5302 000c 0346     		mov	r3, r0
 5303 000e 03F03F03 		and	r3, r3, #63
 5304 0012 DBB2     		uxtb	r3, r3
1244:../LSM9DS1_drivers.c **** }
 5305              		.loc 1 1244 0
 5306 0014 1846     		mov	r0, r3
 5307 0016 80BD     		pop	{r7, pc}
 5308              		.cfi_endproc
 5309              	.LFE172:
 5311              		.section	.text.mReadBytes,"ax",%progbits
 5312              		.align	2
 5313              		.global	mReadBytes
 5314              		.thumb
 5315              		.thumb_func
 5317              	mReadBytes:
 5318              	.LFB173:
1245:../LSM9DS1_drivers.c **** 
1246:../LSM9DS1_drivers.c **** 
1247:../LSM9DS1_drivers.c **** void mReadBytes(uint8_t subAddress, uint8_t * dest, uint8_t count)
1248:../LSM9DS1_drivers.c **** {
 5319              		.loc 1 1248 0
 5320              		.cfi_startproc
 5321              		@ args = 0, pretend = 0, frame = 8
 5322              		@ frame_needed = 1, uses_anonymous_args = 0
 5323 0000 80B5     		push	{r7, lr}
 5324              	.LCFI176:
 5325              		.cfi_def_cfa_offset 8
 5326              		.cfi_offset 7, -8
 5327              		.cfi_offset 14, -4
 5328 0002 82B0     		sub	sp, sp, #8
 5329              	.LCFI177:
 5330              		.cfi_def_cfa_offset 16
 5331 0004 00AF     		add	r7, sp, #0
 5332              	.LCFI178:
 5333              		.cfi_def_cfa_register 7
 5334 0006 3960     		str	r1, [r7, #0]
 5335 0008 1346     		mov	r3, r2
 5336 000a 0246     		mov	r2, r0
 5337 000c FA71     		strb	r2, [r7, #7]
 5338 000e BB71     		strb	r3, [r7, #6]
1249:../LSM9DS1_drivers.c **** 	// Whether we're using I2C or SPI, read multiple bytes using the
1250:../LSM9DS1_drivers.c **** 	// accelerometer-specific I2C address or SPI CS pin.
1251:../LSM9DS1_drivers.c **** 	if (settings.device.commInterface == IMU_MODE_I2C)
 5339              		.loc 1 1251 0
 5340 0010 40F20003 		movw	r3, #:lower16:settings
 5341 0014 C0F20003 		movt	r3, #:upper16:settings
 5342 0018 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5343 001a 012B     		cmp	r3, #1
 5344 001c 0CD1     		bne	.L222
1252:../LSM9DS1_drivers.c **** 		I2CreadBytes(_mAddress, subAddress, dest, count);
 5345              		.loc 1 1252 0
 5346 001e 40F20003 		movw	r3, #:lower16:_mAddress
 5347 0022 C0F20003 		movt	r3, #:upper16:_mAddress
 5348 0026 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 5349 0028 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 5350 002a BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 5351 002c 0846     		mov	r0, r1
 5352 002e 1146     		mov	r1, r2
 5353 0030 3A68     		ldr	r2, [r7, #0]
 5354 0032 FFF7FEFF 		bl	I2CreadBytes
 5355 0036 12E0     		b	.L221
 5356              	.L222:
1253:../LSM9DS1_drivers.c **** 	else if (settings.device.commInterface == IMU_MODE_SPI)
 5357              		.loc 1 1253 0
 5358 0038 40F20003 		movw	r3, #:lower16:settings
 5359 003c C0F20003 		movt	r3, #:upper16:settings
 5360 0040 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5361 0042 002B     		cmp	r3, #0
 5362 0044 0BD1     		bne	.L221
1254:../LSM9DS1_drivers.c **** 		SPIreadBytes(_mAddress, subAddress, dest, count);
 5363              		.loc 1 1254 0
 5364 0046 40F20003 		movw	r3, #:lower16:_mAddress
 5365 004a C0F20003 		movt	r3, #:upper16:_mAddress
 5366 004e 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 5367 0050 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 5368 0052 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 5369 0054 0846     		mov	r0, r1
 5370 0056 1146     		mov	r1, r2
 5371 0058 3A68     		ldr	r2, [r7, #0]
 5372 005a FFF7FEFF 		bl	SPIreadBytes
 5373              	.L221:
1255:../LSM9DS1_drivers.c **** }
 5374              		.loc 1 1255 0
 5375 005e 07F10807 		add	r7, r7, #8
 5376 0062 BD46     		mov	sp, r7
 5377 0064 80BD     		pop	{r7, pc}
 5378              		.cfi_endproc
 5379              	.LFE173:
 5381              		.section	.text.myDelay,"ax",%progbits
 5382              		.align	2
 5383              		.global	myDelay
 5384              		.thumb
 5385              		.thumb_func
 5387              	myDelay:
 5388              	.LFB174:
1256:../LSM9DS1_drivers.c **** 
1257:../LSM9DS1_drivers.c **** void myDelay(volatile unsigned int delay)
1258:../LSM9DS1_drivers.c **** {
 5389              		.loc 1 1258 0
 5390              		.cfi_startproc
 5391              		@ args = 0, pretend = 0, frame = 16
 5392              		@ frame_needed = 1, uses_anonymous_args = 0
 5393              		@ link register save eliminated.
 5394 0000 80B4     		push	{r7}
 5395              	.LCFI179:
 5396              		.cfi_def_cfa_offset 4
 5397              		.cfi_offset 7, -4
 5398 0002 85B0     		sub	sp, sp, #20
 5399              	.LCFI180:
 5400              		.cfi_def_cfa_offset 24
 5401 0004 00AF     		add	r7, sp, #0
 5402              	.LCFI181:
 5403              		.cfi_def_cfa_register 7
 5404 0006 7860     		str	r0, [r7, #4]
1259:../LSM9DS1_drivers.c **** 	volatile unsigned int i = 0;
 5405              		.loc 1 1259 0
 5406 0008 4FF00003 		mov	r3, #0
 5407 000c FB60     		str	r3, [r7, #12]
1260:../LSM9DS1_drivers.c **** 
1261:../LSM9DS1_drivers.c **** 	for(i = 0; i < delay; i++)
 5408              		.loc 1 1261 0
 5409 000e 4FF00003 		mov	r3, #0
 5410 0012 FB60     		str	r3, [r7, #12]
 5411 0014 03E0     		b	.L225
 5412              	.L226:
 5413              		.loc 1 1261 0 is_stmt 0 discriminator 2
 5414 0016 FB68     		ldr	r3, [r7, #12]
 5415 0018 03F10103 		add	r3, r3, #1
 5416 001c FB60     		str	r3, [r7, #12]
 5417              	.L225:
 5418              		.loc 1 1261 0 discriminator 1
 5419 001e FA68     		ldr	r2, [r7, #12]
 5420 0020 7B68     		ldr	r3, [r7, #4]
 5421 0022 9A42     		cmp	r2, r3
 5422 0024 F7D3     		bcc	.L226
1262:../LSM9DS1_drivers.c **** 	{
1263:../LSM9DS1_drivers.c **** 		;
1264:../LSM9DS1_drivers.c **** 	}
1265:../LSM9DS1_drivers.c **** }
 5423              		.loc 1 1265 0 is_stmt 1
 5424 0026 07F11407 		add	r7, r7, #20
 5425 002a BD46     		mov	sp, r7
 5426 002c 80BC     		pop	{r7}
 5427 002e 7047     		bx	lr
 5428              		.cfi_endproc
 5429              	.LFE174:
 5431              		.text
 5432              	.Letext0:
 5433              		.file 2 "c:\\dave-3.1.10\\arm-gcc\\bin\\../lib/gcc/arm-none-eabi/4.7.4/../../../../arm-none-eabi/i
 5434              		.file 3 "../LSM9DS1_Types.h"
 5435              		.file 4 "C:\\DAVE3_workspace\\mojWorkspace\\Bachelor\\Dave\\Generated\\inc\\DAVESupport/../../inc/
 5436              		.file 5 "C:\\DAVE3_workspace\\mojWorkspace\\Bachelor\\Dave\\Generated\\inc\\DAVESupport/../../inc/
 5437              		.file 6 "c:\\dave-3.1.10\\arm-gcc\\bin\\../lib/gcc/arm-none-eabi/4.7.4/../../../../arm-none-eabi/i
 5438              		.file 7 "c:\\dave-3.1.10\\arm-gcc\\bin\\../lib/gcc/arm-none-eabi/4.7.4/../../../../arm-none-eabi/i
 5439              		.file 8 "c:\\dave-3.1.10\\arm-gcc\\bin\\../lib/gcc/arm-none-eabi/4.7.4/include/stddef.h"
 5440              		.file 9 "c:\\dave-3.1.10\\arm-gcc\\bin\\../lib/gcc/arm-none-eabi/4.7.4/../../../../arm-none-eabi/i
 5441              		.file 10 "c:\\dave-3.1.10\\arm-gcc\\bin\\../lib/gcc/arm-none-eabi/4.7.4/../../../../arm-none-eabi/
 5442              		.file 11 "../LSM9DS1_drivers.h"
 5443              		.file 12 "C:\\DAVE-3.1.10\\eclipse\\/../CMSIS/Include/core_cm4.h"
 5444              		.file 13 "../timerFunctionsLSM.h"
DEFINED SYMBOLS
                            *ABS*:00000000 LSM9DS1_drivers.c
                            *COM*:00000004 TimerId
                            *COM*:00000004 Status
                            *COM*:00000004 WriteTimerId
                            *COM*:00000004 WriteTimerStatus
                            *COM*:00000004 TimerIdReadBytes
                            *COM*:00000004 StatusReadBytes
                            *COM*:00000028 settings
                            *COM*:0000000c gBias
                            *COM*:0000000c aBias
                            *COM*:0000000c mBias
                            *COM*:00000006 gBiasRaw
                            *COM*:00000006 aBiasRaw
                            *COM*:00000006 mBiasRaw
                            *COM*:00000001 _autoCalc
                            *COM*:00000001 _mAddress
                            *COM*:00000001 _xgAddress
                            *COM*:00000004 gRes
                            *COM*:00000004 aRes
                            *COM*:00000004 mRes
                            *COM*:00000002 gx
                            *COM*:00000002 gy
                            *COM*:00000002 gz
                            *COM*:00000002 ax
                            *COM*:00000002 ay
                            *COM*:00000002 az
                            *COM*:00000002 mx
                            *COM*:00000002 my
                            *COM*:00000002 mz
                            *COM*:00000002 temperature
                            *COM*:00000014 lk
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:54     .bss:00000000 indexAccel
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:51     .bss:00000000 $d
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:61     .data:00000000 magSensitivity
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:58     .data:00000000 $d
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:71     .bss:00000004 accelMeasurements
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:77     .bss:00000008 gyroMeasurements
                            *COM*:00001770 poms
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:81     .text.init:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:86     .text.init:00000000 init
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:362    .text.begin:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:367    .text.begin:00000000 begin
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:476    .text.constrainScales:00000000 constrainScales
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:582    .text.calcgRes:00000000 calcgRes
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:666    .text.calcmRes:00000000 calcmRes
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:624    .text.calcaRes:00000000 calcaRes
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:758    .text.initI2C:00000000 initI2C
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:785    .text.initSPI:00000000 initSPI
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:930    .text.mReadByte:00000000 mReadByte
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1036   .text.xgReadByte:00000000 xgReadByte
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1408   .text.initGyro:00000000 initGyro
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1790   .text.initAccel:00000000 initAccel
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1970   .text.initMag:00000000 initMag
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:471    .text.constrainScales:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:577    .text.calcgRes:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:614    .text.calcgRes:00000030 $d
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:619    .text.calcaRes:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:656    .text.calcaRes:00000030 $d
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:661    .text.calcmRes:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:691    .text.calcmRes:00000020 $d
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:706    .text.calcmRes:00000054 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:753    .text.initI2C:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:780    .text.initSPI:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:807    .text.I2CreadByte:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:812    .text.I2CreadByte:00000000 I2CreadByte
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:925    .text.mReadByte:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1000   .text.SPIreadByte:00000000 SPIreadByte
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:995    .text.SPIreadByte:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1031   .text.xgReadByte:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1101   .text.xgReadBytes:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1106   .text.xgReadBytes:00000000 xgReadBytes
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1176   .text.I2CreadBytes:00000000 I2CreadBytes
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1371   .text.SPIreadBytes:00000000 SPIreadBytes
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1171   .text.I2CreadBytes:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1366   .text.SPIreadBytes:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1403   .text.initGyro:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1631   .text.xgWriteByte:00000000 xgWriteByte
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1626   .text.xgWriteByte:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1682   .text.I2CwriteByte:00000000 I2CwriteByte
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1677   .text.I2CwriteByte:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1785   .text.initAccel:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:1965   .text.initMag:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:2135   .text.mWriteByte:00000000 mWriteByte
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:2130   .text.mWriteByte:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:2182   .text.enableFIFO:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:2187   .text.enableFIFO:00000000 enableFIFO
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:2239   .text.setFIFO:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:2244   .text.setFIFO:00000000 setFIFO
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:2292   .text.readGyro1:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:2297   .text.readGyro1:00000000 readGyro1
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3923   .text.calcGyro:00000000 calcGyro
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:2479   .text.readAccel1:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:2484   .text.readAccel1:00000000 readAccel1
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3977   .text.calcAccel:00000000 calcAccel
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:2696   .text.toAscii:00000000 toAscii
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:2691   .text.toAscii:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:2788   .text.calibrate:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:2793   .text.calibrate:00000000 calibrate
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3042   .text.magAvailable:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3047   .text.magAvailable:00000000 magAvailable
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3089   .text.readMag1:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3094   .text.readMag1:00000000 readMag1
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:5317   .text.mReadBytes:00000000 mReadBytes
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3435   .text.calcMag:00000000 calcMag
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3197   .text.calibrateMag:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3202   .text.calibrateMag:00000000 calibrateMag
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3489   .text.magOffset:00000000 magOffset
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3430   .text.calcMag:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3484   .text.magOffset:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3556   .text.accelAvailable:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3561   .text.accelAvailable:00000000 accelAvailable
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3596   .text.gyroAvailable:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3601   .text.gyroAvailable:00000000 gyroAvailable
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3637   .text.tempAvailable:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3642   .text.tempAvailable:00000000 tempAvailable
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3678   .text.readAccel:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3683   .text.readAccel:00000000 readAccel
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3749   .text.readMag:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3754   .text.readMag:00000000 readMag
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3801   .text.readTemp:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3806   .text.readTemp:00000000 readTemp
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3847   .text.readGyro:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3852   .text.readGyro:00000000 readGyro
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3918   .text.calcGyro:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:3972   .text.calcAccel:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4026   .text.setGyroScale:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4031   .text.setGyroScale:00000000 setGyroScale
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4114   .text.setAccelScale:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4119   .text.setAccelScale:00000000 setAccelScale
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4215   .text.setMagScale:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4220   .text.setMagScale:00000000 setMagScale
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4316   .text.setGyroODR:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4321   .text.setGyroODR:00000000 setGyroODR
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4385   .text.setAccelODR:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4390   .text.setAccelODR:00000000 setAccelODR
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4454   .text.setMagODR:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4459   .text.setMagODR:00000000 setMagODR
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4516   .text.configInt:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4521   .text.configInt:00000000 configInt
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4596   .text.configInactivity:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4601   .text.configInactivity:00000000 configInactivity
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4658   .text.getInactivity:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4663   .text.getInactivity:00000000 getInactivity
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4700   .text.configAccelInt:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4705   .text.configAccelInt:00000000 configAccelInt
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4751   .text.configAccelThs:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4756   .text.configAccelThs:00000000 configAccelThs
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4811   .text.getAccelIntSrc:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4816   .text.getAccelIntSrc:00000000 getAccelIntSrc
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4861   .text.configGyroInt:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4866   .text.configGyroInt:00000000 configGyroInt
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4923   .text.configGyroThs:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:4928   .text.configGyroThs:00000000 configGyroThs
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:5005   .text.getGyroIntSrc:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:5010   .text.getGyroIntSrc:00000000 getGyroIntSrc
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:5055   .text.configMagInt:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:5060   .text.configMagInt:00000000 configMagInt
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:5127   .text.configMagThs:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:5132   .text.configMagThs:00000000 configMagThs
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:5173   .text.getMagIntSrc:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:5178   .text.getMagIntSrc:00000000 getMagIntSrc
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:5223   .text.sleepGyro:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:5228   .text.sleepGyro:00000000 sleepGyro
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:5280   .text.getFIFOSamples:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:5285   .text.getFIFOSamples:00000000 getFIFOSamples
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:5312   .text.mReadBytes:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:5382   .text.myDelay:00000000 $t
C:\Users\Mateusz\AppData\Local\Temp\ccMKkq0k.s:5387   .text.myDelay:00000000 myDelay
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.35166846b5321d4273ad8c4248893ac3
                           .group:00000000 wm4.LSM9DS1_drivers.h.9.225085f752270af24a0df342ed7d3479
                           .group:00000000 wm4.LSM9DS1_Registers.h.9.72af380d6da01de607f77d245bf32825
                           .group:00000000 wm4.newlib.h.8.a9901dc52d1357e3e94003403d43f8b5
                           .group:00000000 wm4.features.h.22.b72b3baab2bb2eab3661375590100b6b
                           .group:00000000 wm4.config.h.193.5fb8ef056cdff92dec3dee9552839d8c
                           .group:00000000 wm4._ansi.h.23.7aefdac4826acebbfc9f3822a0aeb14c
                           .group:00000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:00000000 wm4.XMC4500.h.45.215f4b8c79f46c7645c15373868d08c0
                           .group:00000000 wm4.core_cm4.h.47.41af406cb4cda82c972f112a9cd0a024
                           .group:00000000 wm4.core_cmInstr.h.39.3d3d1b4a79aef37532666dc6ee87c6ac
                           .group:00000000 wm4.core_cm4_simd.h.43.b5d1d38735af6366227b4256d330cf13
                           .group:00000000 wm4.core_cm4.h.178.e5ef5ce66d198d7f00f9d0076e267c41
                           .group:00000000 wm4.system_XMC4500.h.29.827f68baa362c84f2abae4ab67dde7c9
                           .group:00000000 wm4.XMC4500.h.198.8e022f279ff353ed081df898dc7b9cf3
                           .group:00000000 wm4.stddef.h.40.50cf36416e06376af8a9dca28536f2e4
                           .group:00000000 wm4.types.h.60.e75c47576398c648cdcf9000ace5e3d8
                           .group:00000000 wm4.MULTIPLEXER.h.46.4a863fbae1c79f0db26da3ce2dc30d02
                           .group:00000000 wm4.CCU8PWMLIB.h.74.725ec81203769525cc7a424597055f47
                           .group:00000000 wm4.MOTORLIB.h.62.951091d95913dd2ff36d761323a1771d
                           .group:00000000 wm4.DBG001.h.116.d6d9e7459a0faa3905c97c1d2edb339d
                           .group:00000000 wm4.uc_id.h.35.fa57ecd9f559d2767f56c96da2848c12
                           .group:00000000 wm4.CLK001_Const.h.50.e5e9c2ddc89f4cc9e7b93e9648fa94e4
                           .group:00000000 wm4.CLK001_Conf.h.81.82a8db895dc146da001475dd68223522
                           .group:00000000 wm4.Usic.h.54.8af9f733ba5771eeb374435d205ea54b
                           .group:00000000 wm4.UART001_Conf.h.53.ea28968cb6c53b1be9f53a4d9f42a86f
                           .group:00000000 wm4.IO004.h.53.442ea5eb47ad9eedc675253aa35f3107
                           .group:00000000 wm4.SYSTM001.h.64.6ecb31c49bc3e7691644fdcdfc11b5cd
                           .group:00000000 wm4.I2C001.h.97.5277d52889d6c741e048ea45ee1277b5
                           .group:00000000 wm4.I2C001_Conf.h.58.e471e519f7471a50493b6f4fe912ee0d
                           .group:00000000 wm4.stdio.h.31.f48311dde756a2aec27351b58a280fb9
                           .group:00000000 wm4.stddef.h.161.e50ff8a9d5d1abbc15641da28ac571bf
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4._default_types.h.6.5e12cd604db8ce00b62bb2f02708eaf3
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4.stddef.h.161.c6104a0666cf681b6269ddc9b4f516d4
                           .group:00000000 wm4.reent.h.16.9e42f0e588b85e70b2bf6572af57ce64
                           .group:00000000 wm4.types.h.23.0d949686bbcadd1621462d4fa1f884f9
                           .group:00000000 wm4.types.h.2.e9cec8c90ab35f77d9f499e06ae02400
                           .group:00000000 wm4.types.h.80.1f2c84c0d57dd52dd9936095d9ac218e
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.63.dfdea6580b080784d08faace69b6ed76
                           .group:00000000 wm4.inttypes.h.14.da8ab5c14bc76feb3bf694db03b8ec46
                           .group:00000000 wm4.inttypes.h.20.54b7c434bb63171d5145327a6d429f51
                           .group:00000000 wm4.math.h.35.cc9264b0ced3bd063c5784e64e89cf51
                           .group:00000000 wm4.stdlib.h.13.603ed7eb09a1561ab06840b7c0fcff58
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.53.c69c7609933ff56d59c757cec2d13230

UNDEFINED SYMBOLS
addressTimer
subAddressTimer
timerHandlerI2CreadByte
makeTimer
indexI2CreadByte
removeTimer
DataReceive2
addressTimerI2CReadBytes
subAddressTimerI2CReadBytes
timerHandlerI2CreadBytes
indexI2CreadBytes
accelerationXYZ
addressTimerWrite
subAddressTimerWrite
dataWrite
timerHandlerI2CwriteByte
indexI2CwriteByte
__aeabi_f2d
__aeabi_ddiv
__aeabi_d2iz
__aeabi_d2f
ceil
round
